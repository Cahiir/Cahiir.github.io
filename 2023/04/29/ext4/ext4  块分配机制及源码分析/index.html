

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Cahir">
  <meta name="keywords" content="">
  
    <meta name="description" content="ext4块分配机制及源码分析对于文件系统来说，碎片问题是永恒的话题，碎片少的文件系统不仅能够存储更多的数据而且能够带来显著的性能提升，为此ext4文件系统从inode分配到块分配都做了相当多的努力。本文主要是结合源码分析ext4文件系统的块分配机制，所采用的源码版本是4.20。 ext4文件系统采用多种分配方式相结合的方式解决碎片问题，此外还需要考虑到分配效率、大文件小文件、超大文件、分配后的读写">
<meta property="og:type" content="article">
<meta property="og:title" content="Cahir">
<meta property="og:url" content="http://example.com/2023/04/29/ext4/ext4%20%20%E5%9D%97%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Cahir">
<meta property="og:description" content="ext4块分配机制及源码分析对于文件系统来说，碎片问题是永恒的话题，碎片少的文件系统不仅能够存储更多的数据而且能够带来显著的性能提升，为此ext4文件系统从inode分配到块分配都做了相当多的努力。本文主要是结合源码分析ext4文件系统的块分配机制，所采用的源码版本是4.20。 ext4文件系统采用多种分配方式相结合的方式解决碎片问题，此外还需要考虑到分配效率、大文件小文件、超大文件、分配后的读写">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/assets/image-20210926201914119.png">
<meta property="og:image" content="http://example.com/assets/image-20210919211523460.png">
<meta property="article:published_time" content="2023-04-29T03:22:37.269Z">
<meta property="article:modified_time" content="2023-04-29T03:22:37.270Z">
<meta property="article:author" content="Cahir">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/assets/image-20210926201914119.png">
  
  
  
  <title>Cahir</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cahir</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-29 11:22" pubdate>
          2023年4月29日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          73k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          606 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            
              <div class="markdown-body">
                
                <h1 id="ext4块分配机制及源码分析"><a href="#ext4块分配机制及源码分析" class="headerlink" title="ext4块分配机制及源码分析"></a>ext4块分配机制及源码分析</h1><p>对于文件系统来说，碎片问题是永恒的话题，碎片少的文件系统不仅能够存储更多的数据而且能够带来显著的性能提升，为此ext4文件系统从inode分配到块分配都做了相当多的努力。本文主要是结合源码分析ext4文件系统的块分配机制，所采用的源码版本是4.20。</p>
<p>ext4文件系统采用多种分配方式相结合的方式解决碎片问题，此外还需要考虑到分配效率、大文件小文件、超大文件、分配后的读写效率等问题，其机制不可谓不复杂，限于当前的水平难免有叙述错误和未叙述到的地方，欢迎一起交流。</p>
<h2 id="块分配机制"><a href="#块分配机制" class="headerlink" title="块分配机制"></a>块分配机制</h2><h3 id="预分配"><a href="#预分配" class="headerlink" title="预分配"></a>预分配</h3><p>给文件预留空间，当需要分配的时候从预留的空间里面分配能够降低碎片数量。ext4文件系统考虑到大文件和小文件的不同需求，对于大文件，ext4采用per inode的方式给每个文件预留分配空间；对于小文件，ext4的策略是尽量让这些文件都集中存储在一起，采用的方式per_cpu locality group的方式。至于什么是per_inode，什么是per_cpu locality group就留到具体的章节详说吧。</p>
<h3 id="mballoc多块分配"><a href="#mballoc多块分配" class="headerlink" title="mballoc多块分配"></a>mballoc多块分配</h3><p>相比于ext2文件系统的块分配器一次性只能分配一个数据块，效率低下；ext4采用了多块分配机制，一次性能够分配多块的空间，效率非常高的同时碎片也会相当的少。ext4的开发人员参考了linux内核内存管理的buddy算法来实现多块分配，如果读者熟悉内存管理的buddy算法的话，理解起来会快很多。</p>
<h3 id="延迟分配"><a href="#延迟分配" class="headerlink" title="延迟分配"></a>延迟分配</h3><p>缓存IO的写命令会先将数据写入页缓存中，然后立即返回，待到某个特定的时候再将缓存中的数据回写到磁盘上。ext4利用此机制，在数据写到页缓存中的时候不做磁盘空间的分配，当写IO持续累积在统一回写到磁盘上的时候再统一地进行分配磁盘空间，一次性大的磁盘空间分配所产生的碎片肯定比多次小IO产生的碎片少，再结合mballoc多块分配一次性分配多块物理磁盘空间能够继续减少碎片。</p>
<p>但是延迟分配有一个缺点，那就是在回写时会进行磁盘空间的分配，这会一定程度上影响刷盘的效率，而且会导致部分IO的延时会突然拔高一段时间，对于追求延时稳定的上层应用来说会有影响，例如数据库系统的某一次SQL执行时间突然变长等。</p>
<h3 id="bigAlloc"><a href="#bigAlloc" class="headerlink" title="bigAlloc"></a>bigAlloc</h3><p>在ext4的块组中有一个块叫做block bitmap数据块位图，用于记录块组中的块使用情况，一个ext4块一般情况下是4k，也就是32768个bit位，一个bit位代表一个4k块的使用情况，32768个bit位就能表示128M的空间的使用情况，这也是一般情况下ext4的一个块组是128M的原因。</p>
<p>但是随着单个磁盘空间的越来越大(TB级)，如果ext4文件系统任然采用4k为一个文件块的方式来管理数据，那么相对应的位图等元数据也会增多，这方面的管理开销也会越来越大。</p>
<p>暴力地增大单个块的大小是个看起来简单的方法，但是由于块大小跟内核的内存管理、页缓存块缓存管理极为紧密，简单地增加文件块大小对于代码开发的工作量将是巨大的。聪明的内核开发者引入了bigalloc的策略，随之而来的是一个叫<strong>“block cluster”</strong>的概念，它是一系列4k的块的集合，当需要分配空间时以block cluster为单位进行分配而不是以4k 块为单位进行分配，与此同时，块组里面数据块位图的一个bit位也不在表示一个4k块，而是一个block cluster，当然我们的块组的大小也随之增大了(block cluster的大小在文件系统格式化的时候就决定了，因此块组的大小也就决定了)。</p>
<p><strong>关于bigalloc特性，内核有一个“历史包袱”，那就是当初开发者在修改代码时并没有将内核代码的所有“blocks”都换成“cluster”，估计是为了尽快上线功能吧，因此后续我们在分析代码的时候一会儿代码是block，一会儿代码是cluster，这会让人很迷惑，需要记住的一点是看到block，其实它是cluster。</strong></p>
<p>block cluster的大小一般设置为64k，如果文件系统只存储大文件，那么可以将block cluster设置为1M。假如一次性给文件分配了1M的空间，而文件并没有用完这片空间，那么下次在文件要分配的时候会将这部分未用完的空间也利用上就不分配了。值得注意的是，如果设置了过大的block cluster，而文件系统又存储了很多的小文件，那么会浪费很多的空间。</p>
<h3 id="持久预分配"><a href="#持久预分配" class="headerlink" title="持久预分配"></a>持久预分配</h3><p>有的上层应用需要在文件开始写入数据之前就准备好足够的空间，例如下载软件会先创建同等大小的文件然后将下载的数据写入到文件等，ext4文件系统提供了持久预分配接口，能够一次性就给文件分配好所有的空间，效率更高，碎片更少。</p>
<h3 id="其他策略"><a href="#其他策略" class="headerlink" title="其他策略"></a>其他策略</h3><p>除了上述的几大分配策略以外，ext4还有很多的小策略以及分配inode的策略也会影响文件系统的性能：</p>
<p>1）在文件刚刚创建的时候ext4文件系统会为其分配8k的空间，然后在文件close的时候回收未用完的空间，以应对创建文件立马写入的场景以及临时小文件场景。</p>
<p>2）尽量将文件数据和文件的inode放在同一个块组中，以减少磁盘寻址耗时(机械硬盘)。</p>
<p>3） 如果启用了flexible块组特性，当4个以上的块组组成一个flexible块组的时候，将flexible块组内的第一个块组的inode分配给目录而不是普通文件。</p>
<p>4）ext4尽量将文件inode与它的目录inode放在同一个块组中，普遍认为目录下的文件是“相关的”，读取某一个文件也会同时读取其他文件。</p>
<p>5）ext4文件系统在分配inode的时候会将顶层的目录尽量分散开，而底层的目录尽量聚集在一起。</p>
<p>6）针对下层块设备是Raid的场景ext4采用与stripe对齐的方式分配，可以加速读写。你可以在创建文件系统时通过设置参数”-E stride&#x3D;?, stripe&#x3D;?”指定按照stripe对齐得方式分配，stride就是raid的chunk size 除以文件系统的block大小的倍数，stripe就是stride * raid的数据盘个数。对于raid5或者raid6这种来说满条带的写能够提升非常大的性能，因为raid引擎不用多次读取计算和写入校验值。至于你的raid的chunk size应该配置多大就得根据上层业务经常下发的IO大小决定，如果IO太大可以指定较小的chunk size使得数据能够分到各个磁盘上，如果经常下发的IO太小可以指定较大一点的chunk size，最好有benchmark可以测试这些参数带来的影响，选择最合适的参数。</p>
<p>7）ext4最终还可以用e4defrag工具整理碎片文件。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>代码流程主要是梳理预分配和多块分配的公共流程和数据结构，而bigalloc、延迟分配以及各种小策略会穿插在其中，持久预分配单独分析。</p>
<p>我们的流程从ext4_ext_map_blocks()函数开始，这个函数的作用是将一段连续的逻辑块号映射到连续的物理块号，在开始梳理流程之前我们需要了解一个结构体：ext4_map_blocks。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	文件系统将磁盘空间划分为4k的块(通常是4k)，每一个4k的块有一个物理块号，物理块号从0开始，由于当前存放文件系统的磁盘空间可能是个分区，因此在通用块层根据下发的物理块号计算真正在磁盘上的sector(通常是512B)时要加上分区的sector偏移。</span><br><span class="hljs-comment">	逻辑块号是相对于文件而言的，对于上层应用来说文件的内容是连续的，而实际的存储物理块号可能不连续，这个4k的块相对于文件起始位置的块号就是逻辑块号。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	ext4_map_blocks用来描述逻辑块号和物理块号的映射关系</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_map_blocks</span> &#123;</span><br>	<span class="hljs-type">ext4_fsblk_t</span> m_pblk; <span class="hljs-comment">// 物理块号，相对于文件系统而言的</span><br>	<span class="hljs-type">ext4_lblk_t</span> m_lblk; <span class="hljs-comment">// 逻辑块号，相对于文件的</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m_len; <span class="hljs-comment">// 长度，单位为文件块</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m_flags; <span class="hljs-comment">// 映射关系的各种标记，参考EXT4_MAP_NEW附近的宏定义</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>ext4_ext_map_blocks()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 我们首先来看参数：</span><br><span class="hljs-comment">		handle_t *handle: 是ext4文件系统的日志系统，此处用于保护分配时的元数据的修改</span><br><span class="hljs-comment">		struct inode *inode: 要分配的文件的inode</span><br><span class="hljs-comment">		struct ext4_map_blocks *map: 映射关系，找到了逻辑块号的物理块号就填入其中</span><br><span class="hljs-comment">		int flags: 调用方对于此次分配行动的“要求”，参考EXT4_GET_BLOCKS_CREATE附件的宏定义</span><br><span class="hljs-comment">	其次是返回值：</span><br><span class="hljs-comment">		返回此次映射的长度，这个值可能会小于调用方要求的长度(ext4_map_blocks里的m_len)，调用方需要处理这种情况</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ext4_ext_map_blocks</span><span class="hljs-params">(<span class="hljs-type">handle_t</span> *handle, <span class="hljs-keyword">struct</span> inode *inode,</span><br><span class="hljs-params">			<span class="hljs-keyword">struct</span> ext4_map_blocks *<span class="hljs-built_in">map</span>, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_ext_path</span> *<span class="hljs-title">path</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_extent</span> <span class="hljs-title">newex</span>, *<span class="hljs-title">ex</span>, *<span class="hljs-title">ex2</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(inode-&gt;i_sb);<br>	<span class="hljs-type">ext4_fsblk_t</span> newblock = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> free_on_err = <span class="hljs-number">0</span>, err = <span class="hljs-number">0</span>, depth, ret;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> allocated = <span class="hljs-number">0</span>, offset = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> allocated_clusters = <span class="hljs-number">0</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_allocation_request</span> <span class="hljs-title">ar</span>;</span><br>	<span class="hljs-type">ext4_lblk_t</span> cluster_offset;<br>	<span class="hljs-type">bool</span> map_from_cluster = <span class="hljs-literal">false</span>;<br><br>	ext_debug(<span class="hljs-string">&quot;blocks %u/%u requested for inode %lu\n&quot;</span>,<br>		  <span class="hljs-built_in">map</span>-&gt;m_lblk, <span class="hljs-built_in">map</span>-&gt;m_len, inode-&gt;i_ino);<br>	trace_ext4_ext_map_blocks_enter(inode, <span class="hljs-built_in">map</span>-&gt;m_lblk, <span class="hljs-built_in">map</span>-&gt;m_len, flags);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	ext4_ext_map_blocks()函数实在太长了，我们将其分为两个部分分析，此处为第一部分，主要是从ext4的extent树中采用二分法的方式寻找有无已经映射了的extent，查找期间如果某个extent树节点没有加载到页缓存中，则会发起读IO从磁盘读取并加载到页缓存中，并且加载的extent(包括空洞)会记录到ext4_inode_info的struct ext4_es_tree i_es_tree红黑树中方便查询。</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	此处涉及到很多的ext4文件系统extent树的知识，这里的分析从简。</span><br><span class="hljs-comment">    */</span><br>    <br>	<span class="hljs-comment">/* find extent for this block */</span><br>    <span class="hljs-comment">// path表示的是从extent树的根节点到extent所经过的所有extent_idx路径</span><br>	path = ext4_find_extent(inode, <span class="hljs-built_in">map</span>-&gt;m_lblk, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">if</span> (IS_ERR(path)) &#123;<br>		err = PTR_ERR(path);<br>		path = <span class="hljs-literal">NULL</span>;<br>		<span class="hljs-keyword">goto</span> out2;<br>	&#125;<br><br>	depth = ext_depth(inode);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * consistent leaf must not be empty;</span><br><span class="hljs-comment">	 * this situation is possible, though, _during_ tree modification;</span><br><span class="hljs-comment">	 * this is why assert can&#x27;t be put in ext4_find_extent()</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (unlikely(path[depth].p_ext == <span class="hljs-literal">NULL</span> &amp;&amp; depth != <span class="hljs-number">0</span>)) &#123;<br>		EXT4_ERROR_INODE(inode, <span class="hljs-string">&quot;bad extent address &quot;</span><br>				 <span class="hljs-string">&quot;lblock: %lu, depth: %d pblock %lld&quot;</span>,<br>				 (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) <span class="hljs-built_in">map</span>-&gt;m_lblk, depth,<br>				 path[depth].p_block);<br>		err = -EFSCORRUPTED;<br>		<span class="hljs-keyword">goto</span> out2;<br>	&#125;<br><br>	ex = path[depth].p_ext;<br>	<span class="hljs-keyword">if</span> (ex) &#123; <span class="hljs-comment">// 如果找到了extent，证明已经映射了</span><br>		<span class="hljs-type">ext4_lblk_t</span> ee_block = le32_to_cpu(ex-&gt;ee_block); <span class="hljs-comment">// 起始逻辑块</span><br>		<span class="hljs-type">ext4_fsblk_t</span> ee_start = ext4_ext_pblock(ex); <span class="hljs-comment">// 起始物理块</span><br>		<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ee_len;<br><br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * unwritten extents are treated as holes, except that</span><br><span class="hljs-comment">		 * we split out initialized portions during a write.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">// 如果一个extent是初始化了的则ee_len &lt;= 32768，</span><br>		<span class="hljs-comment">// 如果一个extent是没有初始化的则ee_len &gt; 32768，且真实长度为ee_len - 32768</span><br>		<span class="hljs-comment">// 因此初始化了的最大长度为32768，未初始化的最大长度为INVALID_U16（65535）- 32768 = 32767</span><br>		ee_len = ext4_ext_get_actual_len(ex);<br><br>		trace_ext4_ext_show_extent(inode, ee_block, ee_start, ee_len);<br><br>		<span class="hljs-comment">/* if found extent covers block, simply return it */</span><br>		<span class="hljs-keyword">if</span> (in_range(<span class="hljs-built_in">map</span>-&gt;m_lblk, ee_block, ee_len)) &#123;<br>			newblock = <span class="hljs-built_in">map</span>-&gt;m_lblk - ee_block + ee_start;<br>			<span class="hljs-comment">/* number of remaining blocks in the extent */</span><br>			allocated = ee_len - (<span class="hljs-built_in">map</span>-&gt;m_lblk - ee_block); <span class="hljs-comment">// 分配的长度可能小于要求分配的长度</span><br>			ext_debug(<span class="hljs-string">&quot;%u fit into %u:%d -&gt; %llu\n&quot;</span>, <span class="hljs-built_in">map</span>-&gt;m_lblk,<br>				  ee_block, ee_len, newblock);<br><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * If the extent is initialized check whether the</span><br><span class="hljs-comment">			 * caller wants to convert it to unwritten.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-comment">// 调用者想要清零</span><br>			<span class="hljs-keyword">if</span> ((!ext4_ext_is_unwritten(ex)) &amp;&amp;<br>			    (flags &amp; EXT4_GET_BLOCKS_CONVERT_UNWRITTEN)) &#123;<br>				allocated = convert_initialized_extent(<br>						handle, inode, <span class="hljs-built_in">map</span>, &amp;path,<br>						allocated);<br>				<span class="hljs-keyword">goto</span> out2;<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!ext4_ext_is_unwritten(ex))<br>				<span class="hljs-keyword">goto</span> out;<br><br>			ret = ext4_ext_handle_unwritten_extents(<br>				handle, inode, <span class="hljs-built_in">map</span>, &amp;path, flags,<br>				allocated, newblock);<br>			<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>				err = ret;<br>			<span class="hljs-keyword">else</span><br>				allocated = ret;<br>			<span class="hljs-keyword">goto</span> out2;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		到这里就说明传入的逻辑块范围没有映射物理块，</span><br><span class="hljs-comment">		如果调用者不需要我们分配实际的空间此处就返回了，可能的情况有两种：</span><br><span class="hljs-comment">			1、ext4的延迟分配就是这样的，写IO流程里面不需要分配空间，回刷的时候才分配空间。</span><br><span class="hljs-comment">			2、可能这段空间是文件空洞，不需要分配物理块，只需要内存中有记录即可</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> ((flags &amp; EXT4_GET_BLOCKS_CREATE) == <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-type">ext4_lblk_t</span> hole_start, hole_len;<br><br>		hole_start = <span class="hljs-built_in">map</span>-&gt;m_lblk;<br>		hole_len = ext4_ext_determine_hole(inode, path, &amp;hole_start);<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">			记录这个空洞到ext4_inode_info的struct ext4_es_tree i_es_tree红黑树中</span><br><span class="hljs-comment">		 */</span><br>		ext4_ext_put_gap_in_cache(inode, hole_start, hole_len);<br><br>		<span class="hljs-comment">/* Update hole_len to reflect hole size after map-&gt;m_lblk */</span><br>		<span class="hljs-keyword">if</span> (hole_start != <span class="hljs-built_in">map</span>-&gt;m_lblk)<br>			hole_len -= <span class="hljs-built_in">map</span>-&gt;m_lblk - hole_start;<br>		<span class="hljs-built_in">map</span>-&gt;m_pblk = <span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">map</span>-&gt;m_len = <span class="hljs-type">min_t</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-built_in">map</span>-&gt;m_len, hole_len);<br><br>		<span class="hljs-keyword">goto</span> out2;<br>	&#125;<br>    <br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面开始梳理ext4_ext_map_blocks()函数的后半段，也就是分配物理块，不过首先我们需要了解一些结构体以及一些宏：</p>
<p>1）struct ext4_extent</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	ext4_extent是extent树的叶子节点，用于在物理磁盘上描述逻辑块号和物理块号的映射关系。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_extent</span> &#123;</span><br>	__le32	ee_block;	<span class="hljs-comment">/* extent包含的第一个逻辑块 */</span><br>	__le16	ee_len;		<span class="hljs-comment">/* extent包含的数据块的个数 */</span><br>	__le16	ee_start_hi;	<span class="hljs-comment">/* 物理数据块的高16位 */</span><br>	__le32	ee_start_lo;	<span class="hljs-comment">/* 物理数据块的低32位 */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>2）struct ext4_allocation_request</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	ext4_allocation_request表示的是一次分配的具体请求。</span><br><span class="hljs-comment">	ext4_lblk_t是logic block的意思，代表逻辑块号</span><br><span class="hljs-comment">	ext4_fsblk_t是物理块号</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_allocation_request</span> &#123;</span> <span class="hljs-comment">// 块分配请求</span><br>	<span class="hljs-comment">/* 要分配物理块的文件inode */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span>;</span><br>	<span class="hljs-comment">/* 要分配的长度 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;<br>	<span class="hljs-comment">/* 要分配物理块号的逻辑块号 */</span><br>	<span class="hljs-type">ext4_lblk_t</span> logical;<br>	<span class="hljs-comment">/* the closest logical allocated block to the left */</span><br>	<span class="hljs-type">ext4_lblk_t</span> lleft;<br>	<span class="hljs-comment">/* the closest logical allocated block to the right */</span><br>	<span class="hljs-type">ext4_lblk_t</span> lright;<br>	<span class="hljs-comment">/* phys. target (a hint) */</span><br>    <span class="hljs-comment">// 目标物理块号，分配器会首先看看在某些“相邻”的物理位置能不能分配，这些相邻的物理位置相当程度地保证数据局部性，具体可参考ext4_ext_find_goal()函数</span><br>	<span class="hljs-type">ext4_fsblk_t</span> goal; <br>	<span class="hljs-comment">/* phys. block for the closest logical allocated block to the left */</span><br>	<span class="hljs-type">ext4_fsblk_t</span> pleft;<br>	<span class="hljs-comment">/* phys. block for the closest logical allocated block to the right */</span><br>	<span class="hljs-type">ext4_fsblk_t</span> pright;<br>	<span class="hljs-comment">/* flags. see above EXT4_MB_HINT_* */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>3）EXT4_LBLK_COFF</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	s是ext4_sb_info，字段s_cluster_ratio表示的是一个block cluster的block数目，它的值是2的幂，因此这个宏表示的是lblk在cluster里面的偏移。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXT4_LBLK_COFF(s, lblk) ((lblk) &amp;				\</span><br><span class="hljs-meta">				 ((ext4_lblk_t) (s)-&gt;s_cluster_ratio - 1))</span><br></code></pre></td></tr></table></figure>

<p>开始分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">ext4_ext_map_blocks</span><span class="hljs-params">(<span class="hljs-type">handle_t</span> *handle, <span class="hljs-keyword">struct</span> inode *inode,</span><br><span class="hljs-params">			<span class="hljs-keyword">struct</span> ext4_map_blocks *<span class="hljs-built_in">map</span>, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    ......<br>	<span class="hljs-comment">// 开始分配物理块</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Okay, we need to do block allocation.</span><br><span class="hljs-comment">	 */</span><br>	newex.ee_block = cpu_to_le32(<span class="hljs-built_in">map</span>-&gt;m_lblk); <span class="hljs-comment">// 起始逻辑块</span><br>	cluster_offset = EXT4_LBLK_COFF(sbi, <span class="hljs-built_in">map</span>-&gt;m_lblk); <span class="hljs-comment">// 起始逻辑块在cluster内的偏移</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * If we are doing bigalloc, check to see if the extent returned</span><br><span class="hljs-comment">	 * by ext4_find_extent() implies a cluster we can use.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">// bigalloc上一次分配的cluster可能还没有用完，剩余的空间可以用于这一次的分配</span><br>    <span class="hljs-comment">// 值得注意的时候如果本次的起始位置在cluster内的偏移是0，那么证明这一次是新分配一个cluster，因此也就没有必要检查了</span><br>    <span class="hljs-comment">// ext4_extent ex可以理解为离这一次分配逻辑块段左边最近的逻辑块段</span><br>    <span class="hljs-comment">// 此时cluster、extent、request region之间的重叠关系就决定了能否使用前面分配的cluster未使用的区域</span><br>	<span class="hljs-keyword">if</span> (cluster_offset &amp;&amp; ex &amp;&amp;<br>		<span class="hljs-comment">// 检查重叠关系</span><br>	    get_implied_cluster_alloc(inode-&gt;i_sb, <span class="hljs-built_in">map</span>, ex, path)) &#123;<br>		ar.len = allocated = <span class="hljs-built_in">map</span>-&gt;m_len;<br>		newblock = <span class="hljs-built_in">map</span>-&gt;m_pblk;<br>		map_from_cluster = <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">goto</span> got_allocated_blocks;<br>	&#125;<br><br>	<span class="hljs-comment">/* find neighbour allocated blocks */</span><br>    <span class="hljs-comment">// 如果没法利用左边的extent分配的cluster未使用完的区域，则搜索右边有无可用区域</span><br>    <span class="hljs-comment">// 设想当前要分配的这段逻辑块段是在一个空洞内，那么它的前后逻辑块都是被分配了的extent</span><br>    <span class="hljs-comment">// 往ext4_allocation_request里记录要分配的起始逻辑块地址</span><br>	ar.lleft = <span class="hljs-built_in">map</span>-&gt;m_lblk;<br>    <span class="hljs-comment">// 首先记录左边的extent的逻辑块和物理块地址，在预估后续的文件大小时使用</span><br>	err = ext4_ext_search_left(inode, path, &amp;ar.lleft, &amp;ar.pleft);<br>	<span class="hljs-keyword">if</span> (err)<br>		<span class="hljs-keyword">goto</span> out2;<br>	ar.lright = <span class="hljs-built_in">map</span>-&gt;m_lblk;<br>	ex2 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 搜索右边的extent，找到离分配段最近的extent，存到ex2中</span><br>	err = ext4_ext_search_right(inode, path, &amp;ar.lright, &amp;ar.pright, &amp;ex2);<br>	<span class="hljs-keyword">if</span> (err)<br>		<span class="hljs-keyword">goto</span> out2;<br><br>	<span class="hljs-comment">/* Check if the extent after searching to the right implies a</span><br><span class="hljs-comment">	 * cluster we can use. */</span><br>	<span class="hljs-comment">// 如果右边有extent则可以看看有没有未使用的cluster的区域，有则将这段区域分配出去</span><br>	<span class="hljs-keyword">if</span> ((sbi-&gt;s_cluster_ratio &gt; <span class="hljs-number">1</span>) &amp;&amp; ex2 &amp;&amp;<br>	    get_implied_cluster_alloc(inode-&gt;i_sb, <span class="hljs-built_in">map</span>, ex2, path)) &#123;<br>		ar.len = allocated = <span class="hljs-built_in">map</span>-&gt;m_len;<br>		newblock = <span class="hljs-built_in">map</span>-&gt;m_pblk;<br>		map_from_cluster = <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">goto</span> got_allocated_blocks;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		如果要分配的长度大于最大值，将分配长度对齐到最大值</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;m_len &gt; EXT_INIT_MAX_LEN &amp;&amp;<br>	    !(flags &amp; EXT4_GET_BLOCKS_UNWRIT_EXT))<br>		<span class="hljs-built_in">map</span>-&gt;m_len = EXT_INIT_MAX_LEN;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;m_len &gt; EXT_UNWRITTEN_MAX_LEN &amp;&amp;<br>		 (flags &amp; EXT4_GET_BLOCKS_UNWRIT_EXT))<br>		<span class="hljs-built_in">map</span>-&gt;m_len = EXT_UNWRITTEN_MAX_LEN;<br><br>	<span class="hljs-comment">/* Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */</span><br>	newex.ee_len = cpu_to_le16(<span class="hljs-built_in">map</span>-&gt;m_len);<br>    <span class="hljs-comment">// 检查分配的区域跟右边的extent是否有重叠，有则缩短分配的长度</span><br>	err = ext4_ext_check_overlap(sbi, inode, &amp;newex, path);<br>	<span class="hljs-keyword">if</span> (err)<br>        <span class="hljs-comment">// err表示有重叠，那么用新的调整了的分配长度</span><br>		allocated = ext4_ext_get_actual_len(&amp;newex);<br>	<span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 否则使用调用者传入的长度</span><br>		allocated = <span class="hljs-built_in">map</span>-&gt;m_len;<br><br>	<span class="hljs-comment">/* 分配一个新的物理块段 */</span><br>	ar.inode = inode;<br>    <span class="hljs-comment">// 先找到目标区域，开始分配的时候先检查能否从目标区域分配物理块</span><br>	ar.goal = ext4_ext_find_goal(inode, path, <span class="hljs-built_in">map</span>-&gt;m_lblk);<br>	ar.logical = <span class="hljs-built_in">map</span>-&gt;m_lblk;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * We calculate the offset from the beginning of the cluster</span><br><span class="hljs-comment">	 * for the logical block number, since when we allocate a</span><br><span class="hljs-comment">	 * physical cluster, the physical block should start at the</span><br><span class="hljs-comment">	 * same offset from the beginning of the cluster.  This is</span><br><span class="hljs-comment">	 * needed so that future calls to get_implied_cluster_alloc()</span><br><span class="hljs-comment">	 * work correctly.</span><br><span class="hljs-comment">	 */</span><br>	offset = EXT4_LBLK_COFF(sbi, <span class="hljs-built_in">map</span>-&gt;m_lblk); <span class="hljs-comment">// 起始逻辑块在cluster内的偏移</span><br>	ar.len = EXT4_NUM_B2C(sbi, offset+allocated); <span class="hljs-comment">// 把要分配的长度换算成cluster数量</span><br>    											  <span class="hljs-comment">// 有可能因为偏移的原因占用多个cluster</span><br>	<span class="hljs-comment">// 将goal和logical都对齐到cluster，方便分配</span><br>    ar.goal -= offset; <br>	ar.logical -= offset;<br>    <span class="hljs-comment">// 如果inode是普通文件，则置上EXT4_MB_HINT_DATA标记</span><br>	<span class="hljs-keyword">if</span> (S_ISREG(inode-&gt;i_mode))<br>		ar.flags = EXT4_MB_HINT_DATA;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-comment">/* disable in-core preallocation for non-regular files */</span><br>		ar.flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 将调用者的“要求”一一转换到ext4_allocation_request中</span><br>	<span class="hljs-keyword">if</span> (flags &amp; EXT4_GET_BLOCKS_NO_NORMALIZE)<br>		ar.flags |= EXT4_MB_HINT_NOPREALLOC;<br>	<span class="hljs-keyword">if</span> (flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE)<br>		ar.flags |= EXT4_MB_DELALLOC_RESERVED;<br>	<span class="hljs-keyword">if</span> (flags &amp; EXT4_GET_BLOCKS_METADATA_NOFAIL)<br>		ar.flags |= EXT4_MB_USE_RESERVED;<br>	<br>	newblock = ext4_mb_new_blocks(handle, &amp;ar, &amp;err); <span class="hljs-comment">// 核心分配函数！</span><br>	<span class="hljs-keyword">if</span> (!newblock)<br>		<span class="hljs-keyword">goto</span> out2;<br>	ext_debug(<span class="hljs-string">&quot;allocate new block: goal %llu, found %llu/%u\n&quot;</span>,<br>		  ar.goal, newblock, allocated);<br>	free_on_err = <span class="hljs-number">1</span>;<br>	allocated_clusters = ar.len;<br>	ar.len = EXT4_C2B(sbi, ar.len) - offset; <span class="hljs-comment">// 分配到的cluster还原到要分配的长度</span><br>	<span class="hljs-keyword">if</span> (ar.len &gt; allocated)<br>		ar.len = allocated;<br>    <br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>get_implied_cluster_alloc()函数：</p>
<p>cluster、extent、request region之间的重叠关系决定了此次分配的具体长度，能够走到这个函数的证明request region的<strong>起始逻辑地址</strong>是不在extent的逻辑地址范围内的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_implied_cluster_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params">				     <span class="hljs-keyword">struct</span> ext4_map_blocks *<span class="hljs-built_in">map</span>,</span><br><span class="hljs-params">				     <span class="hljs-keyword">struct</span> ext4_extent *ex,</span><br><span class="hljs-params">				     <span class="hljs-keyword">struct</span> ext4_ext_path *path)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br>	<span class="hljs-type">ext4_lblk_t</span> c_offset = EXT4_LBLK_COFF(sbi, <span class="hljs-built_in">map</span>-&gt;m_lblk);<br>	<span class="hljs-type">ext4_lblk_t</span> ex_cluster_start, ex_cluster_end;<br>	<span class="hljs-type">ext4_lblk_t</span> rr_cluster_start;<br>	<span class="hljs-type">ext4_lblk_t</span> ee_block = le32_to_cpu(ex-&gt;ee_block);<br>	<span class="hljs-type">ext4_fsblk_t</span> ee_start = ext4_ext_pblock(ex);<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ee_len = ext4_ext_get_actual_len(ex);<br><br>	<span class="hljs-comment">/* The extent passed in that we are trying to match */</span><br>	ex_cluster_start = EXT4_B2C(sbi, ee_block); <span class="hljs-comment">// extent起始逻辑地址所在的cluster</span><br>	ex_cluster_end = EXT4_B2C(sbi, ee_block + ee_len - <span class="hljs-number">1</span>); <span class="hljs-comment">// extent结束逻辑地址所在的cluster</span><br><br>	<span class="hljs-comment">/* The requested region passed into ext4_map_blocks() */</span><br>    <span class="hljs-comment">// request region的起始逻辑地址所在的cluster</span><br>	rr_cluster_start = EXT4_B2C(sbi, <span class="hljs-built_in">map</span>-&gt;m_lblk);<br>	<span class="hljs-comment">// 当起始cluster或者结束cluster重合时才有可能分配</span><br>	<span class="hljs-keyword">if</span> ((rr_cluster_start == ex_cluster_end) ||<br>	    (rr_cluster_start == ex_cluster_start)) &#123;<br>       	<span class="hljs-comment">/*</span><br><span class="hljs-comment">       	 第一种情况，”|==|“表示分配的长度以及起始物理块: </span><br><span class="hljs-comment">       	 *		 |--- cluster # N--|</span><br><span class="hljs-comment"> 		 *    |--- extent ---|	|---- requested region ---|</span><br><span class="hljs-comment"> 		 *			            |==|</span><br><span class="hljs-comment">       	 */</span><br>		<span class="hljs-keyword">if</span> (rr_cluster_start == ex_cluster_end)<br>			ee_start += ee_len - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// EXT4_PBLK_CMASK表示的是ee_start所在的cluster的起始的物理地址</span><br>        <span class="hljs-comment">// c_offset表示的是requested region的起始逻辑地址在cluster内的偏移量</span><br>		<span class="hljs-built_in">map</span>-&gt;m_pblk = EXT4_PBLK_CMASK(sbi, ee_start) + c_offset;<br>		<span class="hljs-built_in">map</span>-&gt;m_len = min(<span class="hljs-built_in">map</span>-&gt;m_len,<br>				 (<span class="hljs-type">unsigned</span>) sbi-&gt;s_cluster_ratio - c_offset);<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 第二种情况:</span><br><span class="hljs-comment">		 	细分之下有两种情况，这也是第51行代码取最小值的原因：</span><br><span class="hljs-comment">         *   |--------- cluster # N ----------------|</span><br><span class="hljs-comment">         *	   |--- requested region --|   |------- extent ----|</span><br><span class="hljs-comment">         *	   |=======================|</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">		 *   |--------- cluster # N-------------|</span><br><span class="hljs-comment">		 *		       |------- extent ----|</span><br><span class="hljs-comment">		 *	   |--- requested region ---|</span><br><span class="hljs-comment">		 *	   |=======|</span><br><span class="hljs-comment">		 */</span><br><br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;m_lblk &lt; ee_block)<br>			<span class="hljs-built_in">map</span>-&gt;m_len = min(<span class="hljs-built_in">map</span>-&gt;m_len, ee_block - <span class="hljs-built_in">map</span>-&gt;m_lblk);<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 第三种情况，此时要考虑到右边的extent的分配情况，其实这里没有画出来，细分之下也类似第二种情况有两种，因此第63行也有个取最小值的动作：</span><br><span class="hljs-comment">		 *</span><br><span class="hljs-comment">		 *          |------------- cluster # N-------------|</span><br><span class="hljs-comment">		 * |----- ex -----|                  |---- ex_right ----|</span><br><span class="hljs-comment">		 *                  |------ requested region ------|</span><br><span class="hljs-comment">		 *                  |================|</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;m_lblk &gt; ee_block) &#123;<br>			<span class="hljs-type">ext4_lblk_t</span> next = ext4_ext_next_allocated_block(path);<br>			<span class="hljs-built_in">map</span>-&gt;m_len = min(<span class="hljs-built_in">map</span>-&gt;m_len, next - <span class="hljs-built_in">map</span>-&gt;m_lblk);<br>		&#125;<br><br>		trace_ext4_get_implied_cluster_alloc_exit(sb, <span class="hljs-built_in">map</span>, <span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br><br>	trace_ext4_get_implied_cluster_alloc_exit(sb, <span class="hljs-built_in">map</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上是bigalloc的情况下从前面已经分配了的cluster未用完的区域分配的情况，接下来分析分配新物理块的流程：</p>
<p>这个流程主要有两个函数：ext4_ext_find_goal()函数和ext4_mb_new_blocks()函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 返回的是一个物理块号，分配的时候检查从这个物理块号起始分配是否可行</span><br><span class="hljs-type">static</span> <span class="hljs-type">ext4_fsblk_t</span> <span class="hljs-title function_">ext4_ext_find_goal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode,</span><br><span class="hljs-params">			      <span class="hljs-keyword">struct</span> ext4_ext_path *path,</span><br><span class="hljs-params">			      <span class="hljs-type">ext4_lblk_t</span> block)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (path) &#123;<br>		<span class="hljs-type">int</span> depth = path-&gt;p_depth;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_extent</span> *<span class="hljs-title">ex</span>;</span><br><br>		ex = path[depth].p_ext; <span class="hljs-comment">// path的终点是数据extent，即ext4_extent</span><br>		                        <span class="hljs-comment">// path是从根节点到叶子节点的路径</span><br>		<span class="hljs-keyword">if</span> (ex) &#123;<br>			<span class="hljs-type">ext4_fsblk_t</span> ext_pblk = ext4_ext_pblock(ex);<br>			<span class="hljs-type">ext4_lblk_t</span> ext_block = le32_to_cpu(ex-&gt;ee_block);<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">				举两个例子:</span><br><span class="hljs-comment">				|---request region---|  |---extent---|</span><br><span class="hljs-comment">				|-&gt; goal</span><br><span class="hljs-comment">				或者</span><br><span class="hljs-comment">				|---extent---|  |---request region---|</span><br><span class="hljs-comment">								|-&gt; goal</span><br><span class="hljs-comment">			*/</span><br>			<span class="hljs-keyword">if</span> (block &gt; ext_block) <span class="hljs-comment">// 寻找与其最近的空闲物理块，左边或者右边</span><br>				<span class="hljs-keyword">return</span> ext_pblk + (block - ext_block);<br>			<span class="hljs-keyword">else</span><br>				<span class="hljs-keyword">return</span> ext_pblk - (ext_block - block);<br>		&#125;<br><br>		<span class="hljs-comment">/* it looks like index is empty;</span><br><span class="hljs-comment">		 * try to find starting block from index itself */</span><br>		<span class="hljs-keyword">if</span> (path[depth].p_bh) <span class="hljs-comment">// index节点为空</span><br>			<span class="hljs-keyword">return</span> path[depth].p_bh-&gt;b_blocknr; <span class="hljs-comment">// 最后一个extent block对应的物理块号</span><br>	&#125;<br><br>	<span class="hljs-comment">/* OK. use inode&#x27;s group */</span><br>	<span class="hljs-keyword">return</span> ext4_inode_to_goal_block(inode); <span class="hljs-comment">// inode刚刚创建时，没有path</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_inode_to_goal_block()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">ext4_fsblk_t</span> <span class="hljs-title function_">ext4_inode_to_goal_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_inode_info</span> *<span class="hljs-title">ei</span> =</span> EXT4_I(inode);<br>	<span class="hljs-type">ext4_group_t</span> block_group;<br>	<span class="hljs-type">ext4_grpblk_t</span> colour;<br>	<span class="hljs-type">int</span> flex_size = ext4_flex_bg_size(EXT4_SB(inode-&gt;i_sb));<br>	<span class="hljs-type">ext4_fsblk_t</span> bg_start;<br>	<span class="hljs-type">ext4_fsblk_t</span> last_block;<br>	<span class="hljs-comment">// 找到inode所在的block group</span><br>	block_group = ei-&gt;i_block_group;<br>    <span class="hljs-comment">// EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME的值为4</span><br>    <span class="hljs-comment">// 如果ext4启用了flexible group特性，并且每个flexible group的block group数量大于等于4</span><br>    <span class="hljs-comment">// 则将第一个block group用于目录和特殊文件，以加速目录的访问和fsck的时间</span><br>	<span class="hljs-keyword">if</span> (flex_size &gt;= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * If there are at least EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME</span><br><span class="hljs-comment">		 * block groups per flexgroup, reserve the first block</span><br><span class="hljs-comment">		 * group for directories and special files.  Regular</span><br><span class="hljs-comment">		 * files will start at the second block group.  This</span><br><span class="hljs-comment">		 * tends to speed up directory access and improves</span><br><span class="hljs-comment">		 * fsck times.</span><br><span class="hljs-comment">		 */</span><br>        <span class="hljs-comment">// 此时的block_group为flexible group的第一个block group的编号</span><br>		block_group &amp;= ~(flex_size<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">// 如果文件是普通文件，则将block group号加一</span><br>		<span class="hljs-keyword">if</span> (S_ISREG(inode-&gt;i_mode))<br>			block_group++;<br>	&#125;<br>    <span class="hljs-comment">// bg_start为block group的第一个块的块号(物理块号)</span><br>	bg_start = ext4_group_first_block_no(inode-&gt;i_sb, block_group);<br>	last_block = ext4_blocks_count(EXT4_SB(inode-&gt;i_sb)-&gt;s_es) - <span class="hljs-number">1</span>;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * If we are doing delayed allocation, we don&#x27;t need take</span><br><span class="hljs-comment">	 * colour into account.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (test_opt(inode-&gt;i_sb, DELALLOC))<br>		<span class="hljs-keyword">return</span> bg_start;<br>	<span class="hljs-comment">// 计算一个随机值color，最终goal会在flexible group的随机的一个block group上</span><br>    <span class="hljs-comment">// 当flex_group的block数量大于4时goal才确定不会在其第一个block group上</span><br>	<span class="hljs-keyword">if</span> (bg_start + EXT4_BLOCKS_PER_GROUP(inode-&gt;i_sb) &lt;= last_block)<br>		colour = (current-&gt;pid % <span class="hljs-number">16</span>) *<br>			(EXT4_BLOCKS_PER_GROUP(inode-&gt;i_sb) / <span class="hljs-number">16</span>);<br>	<span class="hljs-keyword">else</span><br>		colour = (current-&gt;pid % <span class="hljs-number">16</span>) * ((last_block - bg_start) / <span class="hljs-number">16</span>);<br>	<span class="hljs-keyword">return</span> bg_start + colour;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>正式第分配物理块，首先会调用ext4_mb_use_preallocated()函数从预分配空间里分配物理块，如果分配失败则调用ext4_mb_regular_allocator()函数进行常规的分配。</p>
<p>首先来看分配过程种的两个结构体：</p>
<p>struct ext4_free_extent结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 表示分配的请求和结果</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> &#123;</span><br>	<span class="hljs-type">ext4_lblk_t</span> fe_logical; <span class="hljs-comment">// 要分配的起始逻辑块号</span><br>	<span class="hljs-type">ext4_grpblk_t</span> fe_start;	<span class="hljs-comment">// 分配的起始</span><br>	<span class="hljs-type">ext4_group_t</span> fe_group; <span class="hljs-comment">// 从哪个block group分配的</span><br>	<span class="hljs-type">ext4_grpblk_t</span> fe_len;	<span class="hljs-comment">// 分配的长度，单位为cluster</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>struct ext4_allocation_context结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 对分配行为本身的描述，记录分配的中间过程数据以及分配的结果</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_allocation_context</span> &#123;</span> <br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ac_inode</span>;</span> <span class="hljs-comment">// 要分配的inode</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">ac_sb</span>;</span> <span class="hljs-comment">// inode的super_block</span><br><br>	<span class="hljs-comment">/* original request */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ac_o_ex</span>;</span> <span class="hljs-comment">// 最开始的分配请求</span><br><br>	<span class="hljs-comment">/* goal request (normalized ac_o_ex) */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ac_g_ex</span>;</span> <span class="hljs-comment">// 如果goal能分配成功</span><br><br>	<span class="hljs-comment">/* the best found extent */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ac_b_ex</span>;</span> <span class="hljs-comment">// 最终的分配结果</span><br><br>	<span class="hljs-comment">/* copy of the best found extent taken before preallocation efforts */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ac_f_ex</span>;</span> <span class="hljs-comment">// ac_b_ex的一份拷贝</span><br>	 <span class="hljs-comment">// 分配过程种的相关信息</span><br>	__u16 ac_groups_scanned;<br>	__u16 ac_found;<br>	__u16 ac_tail;<br>	__u16 ac_buddy;<br>	__u16 ac_flags;		<span class="hljs-comment">/* allocation hints */</span><br>	__u8 ac_status;<br>	__u8 ac_criteria;<br>	__u8 ac_2order;		<span class="hljs-comment">/* if request is to allocate 2^N blocks and</span><br><span class="hljs-comment">				 * N &gt; 0, the field stores N, otherwise 0 */</span><br>	__u8 ac_op;		<span class="hljs-comment">/* operation, for history only */</span><br>    <span class="hljs-comment">// 跟mballoc相关的bit位信息</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">ac_bitmap_page</span>;</span> <br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">ac_buddy_page</span>;</span><br>    <span class="hljs-comment">// 预分配相关信息</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">ac_pa</span>;</span> <br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_locality_group</span> *<span class="hljs-title">ac_lg</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_new_blocks()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">ext4_fsblk_t</span> <span class="hljs-title function_">ext4_mb_new_blocks</span><span class="hljs-params">(<span class="hljs-type">handle_t</span> *handle,</span><br><span class="hljs-params">				<span class="hljs-keyword">struct</span> ext4_allocation_request *ar, <span class="hljs-type">int</span> *errp)</span><br>&#123;<br>	<span class="hljs-type">int</span> freed;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_allocation_context</span> *<span class="hljs-title">ac</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span>;</span><br>	<span class="hljs-type">ext4_fsblk_t</span> block = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inquota = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> reserv_clstrs = <span class="hljs-number">0</span>;<br><br>	might_sleep();<br>	sb = ar-&gt;inode-&gt;i_sb;<br>	sbi = EXT4_SB(sb);<br><br>	trace_ext4_request_blocks(ar);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		......</span><br><span class="hljs-comment">		前面一段是检查是否有足够的空间分配这么多，并且检查quota是否有足够的余额</span><br><span class="hljs-comment">		......</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-comment">// 从事先预留好的内存里分配一个ext4_allocation_context</span><br>	ac = kmem_cache_zalloc(ext4_ac_cachep, GFP_NOFS);<br>	<span class="hljs-keyword">if</span> (!ac) &#123;<br>		ar-&gt;len = <span class="hljs-number">0</span>;<br>		*errp = -ENOMEM;<br>		<span class="hljs-keyword">goto</span> out;<br>	&#125;<br><br>	*errp = ext4_mb_initialize_context(ac, ar); <span class="hljs-comment">// 初始化allocation_context</span><br>	<span class="hljs-keyword">if</span> (*errp) &#123;<br>		ar-&gt;len = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">goto</span> out;<br>	&#125;<br><br>	ac-&gt;ac_op = EXT4_MB_HISTORY_PREALLOC;<br>	<span class="hljs-comment">// 非文件不用预分配</span><br>	<span class="hljs-keyword">if</span> (!ext4_mb_use_preallocated(ac)) &#123; <span class="hljs-comment">// 预分配失败</span><br>		ac-&gt;ac_op = EXT4_MB_HISTORY_ALLOC;<br>		ext4_mb_normalize_request(ac, ar); <span class="hljs-comment">// 对文件大小进行预估，预估后的大小比原来大一些</span><br>repeat:<br>		<span class="hljs-comment">// 常规分配</span><br>		*errp = ext4_mb_regular_allocator(ac);<br>		<span class="hljs-keyword">if</span> (*errp)<br>			<span class="hljs-keyword">goto</span> discard_and_exit;<br><br>		<span class="hljs-comment">/* as we&#x27;ve just preallocated more space than</span><br><span class="hljs-comment">		 * user requested originally, we store allocated</span><br><span class="hljs-comment">		 * space in a special descriptor */</span><br>		<span class="hljs-keyword">if</span> (ac-&gt;ac_status == AC_STATUS_FOUND &amp;&amp;<br>		    ac-&gt;ac_o_ex.fe_len &lt; ac-&gt;ac_b_ex.fe_len)<br>			*errp = ext4_mb_new_preallocation(ac); <span class="hljs-comment">// 将分配的多余的空间放到预分配空间里</span><br>		<span class="hljs-keyword">if</span> (*errp) &#123;<br>		discard_and_exit:<br>			ext4_discard_allocated_blocks(ac);<br>			<span class="hljs-keyword">goto</span> errout;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (likely(ac-&gt;ac_status == AC_STATUS_FOUND)) &#123;<br>		*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);<br>		<span class="hljs-keyword">if</span> (*errp) &#123;<br>			ext4_discard_allocated_blocks(ac);<br>			<span class="hljs-keyword">goto</span> errout;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			block = ext4_grp_offs_to_block(sb, &amp;ac-&gt;ac_b_ex);<br>			ar-&gt;len = ac-&gt;ac_b_ex.fe_len;<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		freed  = ext4_mb_discard_preallocations(sb, ac-&gt;ac_o_ex.fe_len);<br>		<span class="hljs-keyword">if</span> (freed)<br>			<span class="hljs-keyword">goto</span> repeat;<br>		*errp = -ENOSPC;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		......</span><br><span class="hljs-comment">		分配失败的处理</span><br><span class="hljs-comment">	*/</span><br><br>	<span class="hljs-keyword">return</span> block;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>ext4_mb_initialize_context()函数初始化ext4_allocation_context。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_initialize_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params">				<span class="hljs-keyword">struct</span> ext4_allocation_request *ar)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ar-&gt;inode-&gt;i_sb;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_super_block</span> *<span class="hljs-title">es</span> =</span> sbi-&gt;s_es;<br>	<span class="hljs-type">ext4_group_t</span> group;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;<br>	<span class="hljs-type">ext4_fsblk_t</span> goal;<br>	<span class="hljs-type">ext4_grpblk_t</span> block;<br><br>	<span class="hljs-comment">/* we can&#x27;t allocate &gt; group size */</span><br>	len = ar-&gt;len; <span class="hljs-comment">// len就是要申请的cluster的数量</span><br><br>	<span class="hljs-comment">/* just a dirty hack to filter too big requests  */</span><br>    <span class="hljs-comment">// 分配的cluster数量超过了一个block group的cluster数量，减小之</span><br>	<span class="hljs-keyword">if</span> (len &gt;= EXT4_CLUSTERS_PER_GROUP(sb)) <br>		len = EXT4_CLUSTERS_PER_GROUP(sb);<br><br>	<span class="hljs-comment">/* start searching from the goal */</span><br>	goal = ar-&gt;goal;<br>	<span class="hljs-keyword">if</span> (goal &lt; le32_to_cpu(es-&gt;s_first_data_block) ||<br>			goal &gt;= ext4_blocks_count(es))<br>		goal = le32_to_cpu(es-&gt;s_first_data_block);<br>    <span class="hljs-comment">// group为goal的block group的编号</span><br>    <span class="hljs-comment">// block为在group中的cluster的偏移（块组中的第几个cluster）</span><br>	ext4_get_group_no_and_offset(sb, goal, &amp;group, &amp;block);<br><br>	<span class="hljs-comment">/* set up allocation goals */</span><br>	ac-&gt;ac_b_ex.fe_logical = EXT4_LBLK_CMASK(sbi, ar-&gt;logical); <span class="hljs-comment">// 逻辑块号</span><br>	ac-&gt;ac_status = AC_STATUS_CONTINUE; <span class="hljs-comment">// 分配的结果状态</span><br>	ac-&gt;ac_sb = sb;<br>	ac-&gt;ac_inode = ar-&gt;inode;<br>    <span class="hljs-comment">// 初始化ac_o_ex，表示原始的分配请求，初始化为goal的值，表示最开始想从goal分配</span><br>	ac-&gt;ac_o_ex.fe_logical = ac-&gt;ac_b_ex.fe_logical;<br>	ac-&gt;ac_o_ex.fe_group = group;<br>	ac-&gt;ac_o_ex.fe_start = block;<br>	ac-&gt;ac_o_ex.fe_len = len; <span class="hljs-comment">// len就是要分配的cluster的数量</span><br>	ac-&gt;ac_g_ex = ac-&gt;ac_o_ex; <span class="hljs-comment">// ac_g_ex被赋值成ac_o_ex</span><br>	ac-&gt;ac_flags = ar-&gt;flags;<br><br>	<span class="hljs-comment">// 这个函数在预分配一节里分析</span><br>	ext4_mb_group_or_file(ac);<br><br>	mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;init ac: %u blocks @ %u, goal %u, flags %x, 2^%d, &quot;</span><br>			<span class="hljs-string">&quot;left: %u/%u, right %u/%u to %swritable\n&quot;</span>,<br>			(<span class="hljs-type">unsigned</span>) ar-&gt;len, (<span class="hljs-type">unsigned</span>) ar-&gt;logical,<br>			(<span class="hljs-type">unsigned</span>) ar-&gt;goal, ac-&gt;ac_flags, ac-&gt;ac_2order,<br>			(<span class="hljs-type">unsigned</span>) ar-&gt;lleft, (<span class="hljs-type">unsigned</span>) ar-&gt;pleft,<br>			(<span class="hljs-type">unsigned</span>) ar-&gt;lright, (<span class="hljs-type">unsigned</span>) ar-&gt;pright,<br>			<span class="hljs-type">atomic_read</span>(&amp;ar-&gt;inode-&gt;i_writecount) ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;non-&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="预分配-1"><a href="#预分配-1" class="headerlink" title="预分配"></a>预分配</h3><p> ext4对于大文件采用的是per inode预留分配空间的方式分配，对于小文件采用的是per_cpu locality group的方式，那么怎么定义文件是大文件还是小文件呢？在sys文件系统的“&#x2F;sys&#x2F;fs&#x2F;ext4&#x2F;<partition>&#x2F;mb_stream_req”的值，如果文件大小超过了这个值就是“大文件”，小于等于则是“小文件”，mb_stream_req默认为16个文件块，按照每个文件块4k计算为64k。</p>
<p>ext4在ext4_mb_group_or_file()函数决定是使用per inode预分配还是per_cpu locality group预分配，此时函数被ext4_mb_initialize_context()函数调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_group_or_file</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(ac-&gt;ac_sb);<br>	<span class="hljs-type">int</span> bsbits = ac-&gt;ac_sb-&gt;s_blocksize_bits;<br>	<span class="hljs-type">loff_t</span> size, isize;<br><br>	<span class="hljs-keyword">if</span> (!(ac-&gt;ac_flags &amp; EXT4_MB_HINT_DATA))<br>		<span class="hljs-keyword">return</span>;<br><br>	<span class="hljs-keyword">if</span> (unlikely(ac-&gt;ac_flags &amp; EXT4_MB_HINT_GOAL_ONLY))<br>		<span class="hljs-keyword">return</span>;<br><br>	<span class="hljs-comment">// 此次分配后文件的大小，单位为文件块</span><br>	size = ac-&gt;ac_o_ex.fe_logical + EXT4_C2B(sbi, ac-&gt;ac_o_ex.fe_len);<br>	<span class="hljs-comment">// 文件当前总长度，单位为文件块</span><br>	isize = (i_size_read(ac-&gt;ac_inode) + ac-&gt;ac_sb-&gt;s_blocksize - <span class="hljs-number">1</span>)<br>		&gt;&gt; bsbits;<br><br>	<span class="hljs-keyword">if</span> ((size == isize) &amp;&amp;<br>	    !ext4_fs_is_busy(sbi) &amp;&amp;<br>	    (<span class="hljs-type">atomic_read</span>(&amp;ac-&gt;ac_inode-&gt;i_writecount) == <span class="hljs-number">0</span>)) &#123;<br>		ac-&gt;ac_flags |= EXT4_MB_HINT_NOPREALLOC;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>    <span class="hljs-comment">// s_mb_group_prealloc未设置</span><br>	<span class="hljs-keyword">if</span> (sbi-&gt;s_mb_group_prealloc &lt;= <span class="hljs-number">0</span>) &#123;<br>		ac-&gt;ac_flags |= EXT4_MB_STREAM_ALLOC;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">/* don&#x27;t use group allocation for large files */</span><br>	size = max(size, isize);<br>	<span class="hljs-keyword">if</span> (size &gt; sbi-&gt;s_mb_stream_request) &#123; <span class="hljs-comment">// s_mb_stream_request默认是16个文件块</span><br>		ac-&gt;ac_flags |= EXT4_MB_STREAM_ALLOC;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<br>    <span class="hljs-comment">// 小文件采用per_cpu locality group方式分配</span><br>	BUG_ON(ac-&gt;ac_lg != <span class="hljs-literal">NULL</span>);<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * locality group prealloc space are per cpu. The reason for having</span><br><span class="hljs-comment">	 * per cpu locality group is to reduce the contention between block</span><br><span class="hljs-comment">	 * request from multiple CPUs.</span><br><span class="hljs-comment">	 */</span><br>    <span class="hljs-comment">// 从ext4_sb_info里获取当前CPU的ext4_locality_group</span><br>	ac-&gt;ac_lg = raw_cpu_ptr(sbi-&gt;s_locality_groups);<br><br>	<span class="hljs-comment">/* we&#x27;re going to use group allocation */</span><br>	ac-&gt;ac_flags |= EXT4_MB_HINT_GROUP_ALLOC;<br><br>	<span class="hljs-comment">/* serialize all allocations in the group */</span><br>	mutex_lock(&amp;ac-&gt;ac_lg-&gt;lg_mutex);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>预分配空间struct ext4_prealloc_space结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> &#123;</span> <span class="hljs-comment">// 预分配空间</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">pa_inode_list</span>;</span> <span class="hljs-comment">// 如果是per inode的预分配空间则挂在ext4_inode_info的i_prealloc_list链表; 如果是per_cpu locality group的预分配空间则挂在ext4_locality_group的lg_prealloc_list链表上</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">pa_group_list</span>;</span> <span class="hljs-comment">// 预分配空间同时也会挂在ext4_group_info的bb_prealloc_list链表上，用于初始化buddy bitmap的之前给block bitmap置上对应的已使用标记</span><br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">pa_tmp_list</span>;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span>	<span class="hljs-title">pa_rcu</span>;</span><br>	&#125; u;<br>	<span class="hljs-type">spinlock_t</span>		pa_lock;<br>	<span class="hljs-type">atomic_t</span>		pa_count;<br>	<span class="hljs-type">unsigned</span>		pa_deleted; <span class="hljs-comment">// 预分配空间是否处于删除状态</span><br>	<span class="hljs-type">ext4_fsblk_t</span>		pa_pstart;	<span class="hljs-comment">/* phys. block 起始物理地址 */</span><br>	<span class="hljs-type">ext4_lblk_t</span>		pa_lstart;	<span class="hljs-comment">/* log. block 起始逻辑地址，相对于文件而言 */</span><br>	<span class="hljs-type">ext4_grpblk_t</span>		pa_len;		<span class="hljs-comment">/* len of preallocated chunk， 空间长度 */</span><br>	<span class="hljs-type">ext4_grpblk_t</span>		pa_free;	<span class="hljs-comment">/* how many blocks are free，空间的可用长度 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>		pa_type;	<span class="hljs-comment">/* pa type. inode or group */</span><br>	<span class="hljs-type">spinlock_t</span>		*pa_obj_lock;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>		*<span class="hljs-title">pa_inode</span>;</span>	<span class="hljs-comment">/* hack, for history only */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>ext4_locality_group结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREALLOC_TB_SIZE 10</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_locality_group</span> &#123;</span><br>	<span class="hljs-comment">/* for allocator */</span><br>	<span class="hljs-comment">/* to serialize allocates */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span>		<span class="hljs-title">lg_mutex</span>;</span><br>	<span class="hljs-comment">/* list of preallocations */</span><br>    <span class="hljs-comment">// 挂ext4_prealloc_space的链表，按照预分配空间的可用长度进行分组</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">lg_prealloc_list</span>[<span class="hljs-title">PREALLOC_TB_SIZE</span>];</span><br>	<span class="hljs-type">spinlock_t</span>		lg_prealloc_lock;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_use_preallocated()函数，检查预分配空间里是否能够分配goal：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_use_preallocated</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(ac-&gt;ac_sb);<br>	<span class="hljs-type">int</span> order, i;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_inode_info</span> *<span class="hljs-title">ei</span> =</span> EXT4_I(ac-&gt;ac_inode);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_locality_group</span> *<span class="hljs-title">lg</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span>, *<span class="hljs-title">cpa</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-type">ext4_fsblk_t</span> goal_block;<br><br>	<span class="hljs-comment">/* only data can be preallocated */</span><br>	<span class="hljs-keyword">if</span> (!(ac-&gt;ac_flags &amp; EXT4_MB_HINT_DATA))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">// 先尝试per inode的预分配，遍历预分配空间链表</span><br>	rcu_read_lock();<br>	list_for_each_entry_rcu(pa, &amp;ei-&gt;i_prealloc_list, pa_inode_list) &#123;<br><br>		<span class="hljs-comment">/* all fields in this condition don&#x27;t change,</span><br><span class="hljs-comment">		 * so we can skip locking for them */</span><br>		 <span class="hljs-comment">// 不在这个预分配空间范围内，跳到下一个预分配空间</span><br>		<span class="hljs-keyword">if</span> (ac-&gt;ac_o_ex.fe_logical &lt; pa-&gt;pa_lstart ||<br>		    ac-&gt;ac_o_ex.fe_logical &gt;= (pa-&gt;pa_lstart +<br>					       EXT4_C2B(sbi, pa-&gt;pa_len)))<br>			<span class="hljs-keyword">continue</span>;<br><br>		<span class="hljs-comment">/* non-extent files can&#x27;t have physical blocks past 2^32 */</span><br>	    <span class="hljs-comment">// 非extent的ext4文件的最大可访问的物理块为2^32，如果</span><br>		<span class="hljs-keyword">if</span> (!(ext4_test_inode_flag(ac-&gt;ac_inode, EXT4_INODE_EXTENTS)) &amp;&amp;<br>		    (pa-&gt;pa_pstart + EXT4_C2B(sbi, pa-&gt;pa_len) &gt;<br>		     EXT4_MAX_BLOCK_FILE_PHYS))<br>			<span class="hljs-keyword">continue</span>;<br><br>		<span class="hljs-comment">// 找到了合适的预分配空间，则分配之</span><br>		spin_lock(&amp;pa-&gt;pa_lock);<br>		<span class="hljs-keyword">if</span> (pa-&gt;pa_deleted == <span class="hljs-number">0</span> &amp;&amp; pa-&gt;pa_free) &#123;<br>			<span class="hljs-type">atomic_inc</span>(&amp;pa-&gt;pa_count);<br>            <span class="hljs-comment">// 往ext4_allocation_context记录分配的最终结果</span><br>			ext4_mb_use_inode_pa(ac, pa);<br>			spin_unlock(&amp;pa-&gt;pa_lock);<br>			ac-&gt;ac_criteria = <span class="hljs-number">10</span>;<br>			rcu_read_unlock();<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		&#125;<br>		spin_unlock(&amp;pa-&gt;pa_lock);<br>	&#125;<br>	rcu_read_unlock();<br>	<span class="hljs-comment">// 进行per_cpu locality group的预分配</span><br>	<span class="hljs-comment">/* can we use group allocation? */</span><br>	<span class="hljs-keyword">if</span> (!(ac-&gt;ac_flags &amp; EXT4_MB_HINT_GROUP_ALLOC))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">/* inode may have no locality group for some reason */</span><br>	lg = ac-&gt;ac_lg;<br>	<span class="hljs-keyword">if</span> (lg == <span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// fls的意思是找到fe_len从右往左的最后一个1的位置，即为len的阶</span><br>	order  = fls(ac-&gt;ac_o_ex.fe_len) - <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (order &gt; PREALLOC_TB_SIZE - <span class="hljs-number">1</span>)<br>		<span class="hljs-comment">/* The max size of hash table is PREALLOC_TB_SIZE */</span><br>		order = PREALLOC_TB_SIZE - <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">// goal_block为goal在block group中的偏移</span><br>	goal_block = ext4_grp_offs_to_block(ac-&gt;ac_sb, &amp;ac-&gt;ac_g_ex);<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * search for the prealloc space that is having</span><br><span class="hljs-comment">	 * minimal distance from the goal block.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">for</span> (i = order; i &lt; PREALLOC_TB_SIZE; i++) &#123;<br>		rcu_read_lock();<br>        <span class="hljs-comment">// 遍历当前CPU的预分配空间链表</span><br>		list_for_each_entry_rcu(pa, &amp;lg-&gt;lg_prealloc_list[i],<br>					pa_inode_list) &#123;<br>			spin_lock(&amp;pa-&gt;pa_lock);<br>            <span class="hljs-comment">// 预分配空间没有被删除，且有足够的可用空间进行分配</span><br>			<span class="hljs-keyword">if</span> (pa-&gt;pa_deleted == <span class="hljs-number">0</span> &amp;&amp;<br>					pa-&gt;pa_free &gt;= ac-&gt;ac_o_ex.fe_len) &#123;<br>				<span class="hljs-comment">// 进一步检查，以找到最合适的</span><br>				cpa = ext4_mb_check_group_pa(goal_block, pa, cpa);<br>			&#125;<br>			spin_unlock(&amp;pa-&gt;pa_lock);<br>		&#125;<br>		rcu_read_unlock();<br>	&#125;<br>	<span class="hljs-keyword">if</span> (cpa) &#123;<br>		ext4_mb_use_group_pa(ac, cpa);<br>		ac-&gt;ac_criteria = <span class="hljs-number">20</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_use_inode_pa()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	per inode的预分配成功分配</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_use_inode_pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params">				<span class="hljs-keyword">struct</span> ext4_prealloc_space *pa)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(ac-&gt;ac_sb);<br>	<span class="hljs-type">ext4_fsblk_t</span> start;<br>	<span class="hljs-type">ext4_fsblk_t</span> end;<br>	<span class="hljs-type">int</span> len;<br><br>	<span class="hljs-comment">/* found preallocated blocks, use them */</span><br>	start = pa-&gt;pa_pstart + (ac-&gt;ac_o_ex.fe_logical - pa-&gt;pa_lstart);<br>	end = min(pa-&gt;pa_pstart + EXT4_C2B(sbi, pa-&gt;pa_len),<br>		  start + EXT4_C2B(sbi, ac-&gt;ac_o_ex.fe_len));<br>	len = EXT4_NUM_B2C(sbi, end - start);<br>	ext4_get_group_no_and_offset(ac-&gt;ac_sb, start, &amp;ac-&gt;ac_b_ex.fe_group,<br>					&amp;ac-&gt;ac_b_ex.fe_start);<br>	ac-&gt;ac_b_ex.fe_len = len; <span class="hljs-comment">// 将分配结果置在ac_b_ex</span><br>	ac-&gt;ac_status = AC_STATUS_FOUND; <span class="hljs-comment">// 分配结果为找到了</span><br>	ac-&gt;ac_pa = pa; <span class="hljs-comment">// 保存是从哪个预分配空间分配的</span><br><br>	BUG_ON(start &lt; pa-&gt;pa_pstart);<br>	BUG_ON(end &gt; pa-&gt;pa_pstart + EXT4_C2B(sbi, pa-&gt;pa_len));<br>	BUG_ON(pa-&gt;pa_free &lt; len);<br>	pa-&gt;pa_free -= len; <span class="hljs-comment">// 减少预分配空间的可用长度</span><br><br>	mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;use %llu/%u from inode pa %p\n&quot;</span>, start, len, pa);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_check_group_pa()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	找到一个最合适的预分配空间，什么是“最合适的”呢？</span><br><span class="hljs-comment">	要分配的目标物理块地址跟预分配空间的起始地址最近的预分配空间。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> ext4_prealloc_space *<br><span class="hljs-title function_">ext4_mb_check_group_pa</span><span class="hljs-params">(<span class="hljs-type">ext4_fsblk_t</span> goal_block,</span><br><span class="hljs-params">			<span class="hljs-keyword">struct</span> ext4_prealloc_space *pa,</span><br><span class="hljs-params">			<span class="hljs-keyword">struct</span> ext4_prealloc_space *cpa)</span><br>&#123;<br>	<span class="hljs-type">ext4_fsblk_t</span> cur_distance, new_distance;<br><br>	<span class="hljs-keyword">if</span> (cpa == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-type">atomic_inc</span>(&amp;pa-&gt;pa_count);<br>		<span class="hljs-keyword">return</span> pa;<br>	&#125;<br>	cur_distance = <span class="hljs-built_in">abs</span>(goal_block - cpa-&gt;pa_pstart);<br>	new_distance = <span class="hljs-built_in">abs</span>(goal_block - pa-&gt;pa_pstart);<br>	<span class="hljs-comment">// 找到一个goal离预分配空间起始地址最近的预分配空间</span><br>	<span class="hljs-keyword">if</span> (cur_distance &lt;= new_distance)<br>		<span class="hljs-keyword">return</span> cpa;<br><br>	<span class="hljs-comment">/* drop the previous reference */</span><br>	<span class="hljs-type">atomic_dec</span>(&amp;cpa-&gt;pa_count);<br>	<span class="hljs-type">atomic_inc</span>(&amp;pa-&gt;pa_count);<br>	<span class="hljs-keyword">return</span> pa;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_use_group_pa()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 当从per_cpu locality group分配成功时</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_use_group_pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params">				<span class="hljs-keyword">struct</span> ext4_prealloc_space *pa)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = ac-&gt;ac_o_ex.fe_len;<br><br>	ext4_get_group_no_and_offset(ac-&gt;ac_sb, pa-&gt;pa_pstart,<br>					&amp;ac-&gt;ac_b_ex.fe_group,<br>					&amp;ac-&gt;ac_b_ex.fe_start);<br>	ac-&gt;ac_b_ex.fe_len = len;<br>	ac-&gt;ac_status = AC_STATUS_FOUND;<br>	ac-&gt;ac_pa = pa;<br><br>	<span class="hljs-comment">/* </span><br><span class="hljs-comment">		对比ext4_mb_use_inode_pa()我们可以发现这里并没有着急地减少预分配空间的可用空间，一方面是因为此时是加了lg_mutex锁的，另一方面是为了防止其他流程也加载了block group而带来的竞争，最后在更新了block bitmap的时候才减少预分配空间的可用空间。</span><br><span class="hljs-comment">	 */</span><br>	mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;use %u/%u from group pa %p\n&quot;</span>, pa-&gt;pa_lstart-len, len, pa);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="预分配空间的来源"><a href="#预分配空间的来源" class="headerlink" title="预分配空间的来源"></a>预分配空间的来源</h3><p>在ext4_mb_new_blocks()函数，当采用常规的分配方式分配成功后，如果所分得的长度大于最初要求分配的长度，那么多余出来的这部分空间就可以用来预分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">ext4_fsblk_t</span> <span class="hljs-title function_">ext4_mb_new_blocks</span><span class="hljs-params">(<span class="hljs-type">handle_t</span> *handle,</span><br><span class="hljs-params">				<span class="hljs-keyword">struct</span> ext4_allocation_request *ar, <span class="hljs-type">int</span> *errp)</span><br>&#123;<br>    <span class="hljs-comment">/* ...... */</span><br>	<span class="hljs-keyword">if</span> (!ext4_mb_use_preallocated(ac)) &#123; <span class="hljs-comment">// 预分配失败</span><br>		ac-&gt;ac_op = EXT4_MB_HISTORY_ALLOC;<br>		ext4_mb_normalize_request(ac, ar); <span class="hljs-comment">// 对文件大小进行预估，预估后的大小比原来大一些</span><br>repeat:<br>		<span class="hljs-comment">/* 常规多块分配 */</span><br>		*errp = ext4_mb_regular_allocator(ac);<br>		<span class="hljs-keyword">if</span> (*errp)<br>			<span class="hljs-keyword">goto</span> discard_and_exit;<br><br>		<span class="hljs-comment">/* as we&#x27;ve just preallocated more space than</span><br><span class="hljs-comment">		 * user requested originally, we store allocated</span><br><span class="hljs-comment">		 * space in a special descriptor */</span><br>		<span class="hljs-keyword">if</span> (ac-&gt;ac_status == AC_STATUS_FOUND &amp;&amp;<br>		    ac-&gt;ac_o_ex.fe_len &lt; ac-&gt;ac_b_ex.fe_len)<br>			*errp = ext4_mb_new_preallocation(ac); <span class="hljs-comment">// 有多余的分配的空间作为预分配空间</span><br>		<span class="hljs-keyword">if</span> (*errp) &#123;<br>		discard_and_exit:<br>			ext4_discard_allocated_blocks(ac);<br>			<span class="hljs-keyword">goto</span> errout;<br>		&#125;<br>	&#125;<br>    <span class="hljs-comment">/* ...... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_new_preallocation()函数，将分配的多余的空间加入到预分配链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_new_preallocation</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br>	<span class="hljs-type">int</span> err;<br><br>    <span class="hljs-comment">// 如果该文件是小文件则将多余空间加入到per_cpu locality group预分配空间，如果是大文件则将多余空间加入到per inode预分配空间</span><br>    <span class="hljs-comment">// 这个标记是在ext4_mb_group_or_file()函数根据配置的判别文件是大文件还是小文件的配置项来置上的</span><br>	<span class="hljs-keyword">if</span> (ac-&gt;ac_flags &amp; EXT4_MB_HINT_GROUP_ALLOC)<br>		err = ext4_mb_new_group_pa(ac);<br>	<span class="hljs-keyword">else</span><br>		err = ext4_mb_new_inode_pa(ac);<br>	<span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_new_group_pa()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_new_group_pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_locality_group</span> *<span class="hljs-title">lg</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span>;</span><br><br>	<span class="hljs-comment">/* preallocate only when found space is larger then requested */</span><br>	BUG_ON(ac-&gt;ac_o_ex.fe_len &gt;= ac-&gt;ac_b_ex.fe_len);<br>	BUG_ON(ac-&gt;ac_status != AC_STATUS_FOUND);<br>	BUG_ON(!S_ISREG(ac-&gt;ac_inode-&gt;i_mode));<br><br>	BUG_ON(ext4_pspace_cachep == <span class="hljs-literal">NULL</span>);<br>	pa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);<br>	<span class="hljs-keyword">if</span> (pa == <span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br><br>	<span class="hljs-comment">/* preallocation can change ac_b_ex, thus we store actually</span><br><span class="hljs-comment">	 * allocated blocks for history */</span><br>	ac-&gt;ac_f_ex = ac-&gt;ac_b_ex;<br><br>	pa-&gt;pa_pstart = ext4_grp_offs_to_block(sb, &amp;ac-&gt;ac_b_ex);<br>	pa-&gt;pa_lstart = pa-&gt;pa_pstart;<br>	pa-&gt;pa_len = ac-&gt;ac_b_ex.fe_len; <span class="hljs-comment">// 注意到pa的len是常规分配后分配到的长度！</span><br>	pa-&gt;pa_free = pa-&gt;pa_len;<br>	<span class="hljs-type">atomic_set</span>(&amp;pa-&gt;pa_count, <span class="hljs-number">1</span>);<br>	spin_lock_init(&amp;pa-&gt;pa_lock);<br>	INIT_LIST_HEAD(&amp;pa-&gt;pa_inode_list);<br>	INIT_LIST_HEAD(&amp;pa-&gt;pa_group_list);<br>	pa-&gt;pa_deleted = <span class="hljs-number">0</span>;<br>	pa-&gt;pa_type = MB_GROUP_PA;<br><br>	mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;new group pa %p: %llu/%u for %u\n&quot;</span>, pa,<br>			pa-&gt;pa_pstart, pa-&gt;pa_len, pa-&gt;pa_lstart);<br>	trace_ext4_mb_new_group_pa(ac, pa);<br><br>	ext4_mb_use_group_pa(ac, pa); <span class="hljs-comment">// 注意这一行</span><br>	<span class="hljs-type">atomic_add</span>(pa-&gt;pa_free, &amp;EXT4_SB(sb)-&gt;s_mb_preallocated);<br><br>	grp = ext4_get_group_info(sb, ac-&gt;ac_b_ex.fe_group);<br>	lg = ac-&gt;ac_lg;<br>	BUG_ON(lg == <span class="hljs-literal">NULL</span>);<br><br>	pa-&gt;pa_obj_lock = &amp;lg-&gt;lg_prealloc_lock;<br>	pa-&gt;pa_inode = <span class="hljs-literal">NULL</span>;<br><br>	ext4_lock_group(sb, ac-&gt;ac_b_ex.fe_group);<br>	list_add(&amp;pa-&gt;pa_group_list, &amp;grp-&gt;bb_prealloc_list);<br>	ext4_unlock_group(sb, ac-&gt;ac_b_ex.fe_group);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * We will later add the new pa to the right bucket</span><br><span class="hljs-comment">	 * after updating the pa_free in ext4_mb_release_context</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>观察整个函数以及第38行可知，ext4_mb_new_group_pa()函数生成了一个ext4_prealloc_space但是没有急于将其挂入到per_cpu locality group中，而且ext4_prealloc_space的长度也是常规分配后分配到的长度而不是多余的长度，而是先调用ext4_mb_use_group_pa()函数将其保存到ac中(这里会改变分配到的长度len，因此在21行先将ac_b_ex拷贝到ac_f_ex)，然后在最后的ext4_mb_release_context()流程中将其加入到per_cpu locality group，这样做是为了跟如果从per_cpu locality group分配到了预分配空间一起统一处理。</p>
<p>ext4_mb_release_context()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_release_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(ac-&gt;ac_sb);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span> =</span> ac-&gt;ac_pa;<br>	<span class="hljs-keyword">if</span> (pa) &#123;<br>        <span class="hljs-comment">// 这里才减少ext4_prealloc_space的可用长度</span><br>		<span class="hljs-keyword">if</span> (pa-&gt;pa_type == MB_GROUP_PA) &#123;<br>			<span class="hljs-comment">/* see comment in ext4_mb_use_group_pa() */</span><br>			spin_lock(&amp;pa-&gt;pa_lock);<br>			pa-&gt;pa_pstart += EXT4_C2B(sbi, ac-&gt;ac_b_ex.fe_len);<br>			pa-&gt;pa_lstart += EXT4_C2B(sbi, ac-&gt;ac_b_ex.fe_len);<br>			pa-&gt;pa_free -= ac-&gt;ac_b_ex.fe_len;<br>			pa-&gt;pa_len -= ac-&gt;ac_b_ex.fe_len;<br>			spin_unlock(&amp;pa-&gt;pa_lock);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (pa) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * We want to add the pa to the right bucket.</span><br><span class="hljs-comment">		 * Remove it from the list and while adding</span><br><span class="hljs-comment">		 * make sure the list to which we are adding</span><br><span class="hljs-comment">		 * doesn&#x27;t grow big.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> ((pa-&gt;pa_type == MB_GROUP_PA) &amp;&amp; likely(pa-&gt;pa_free)) &#123;<br>			spin_lock(pa-&gt;pa_obj_lock);<br>			list_del_rcu(&amp;pa-&gt;pa_inode_list);<br>			spin_unlock(pa-&gt;pa_obj_lock);<br>			ext4_mb_add_n_trim(ac); <span class="hljs-comment">// 将其加入到per_cpu locality group中</span><br>		&#125;<br>		ext4_mb_put_pa(ac, ac-&gt;ac_sb, pa);<br>	&#125;<br>	<span class="hljs-keyword">if</span> (ac-&gt;ac_bitmap_page)<br>		put_page(ac-&gt;ac_bitmap_page);<br>	<span class="hljs-keyword">if</span> (ac-&gt;ac_buddy_page)<br>		put_page(ac-&gt;ac_buddy_page);<br>	<span class="hljs-keyword">if</span> (ac-&gt;ac_flags &amp; EXT4_MB_HINT_GROUP_ALLOC)<br>		mutex_unlock(&amp;ac-&gt;ac_lg-&gt;lg_mutex);<br>	ext4_mb_collect_stats(ac);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_add_n_trim()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_add_n_trim</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br>	<span class="hljs-type">int</span> order, added = <span class="hljs-number">0</span>, lg_prealloc_count = <span class="hljs-number">1</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_locality_group</span> *<span class="hljs-title">lg</span> =</span> ac-&gt;ac_lg;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">tmp_pa</span>, *<span class="hljs-title">pa</span> =</span> ac-&gt;ac_pa;<br><br>    <span class="hljs-comment">// 根据预留空间的长度找到其应该所在的桶</span><br>	order = fls(pa-&gt;pa_free) - <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (order &gt; PREALLOC_TB_SIZE - <span class="hljs-number">1</span>)<br>		<span class="hljs-comment">/* The max size of hash table is PREALLOC_TB_SIZE */</span><br>		order = PREALLOC_TB_SIZE - <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">/* Add the prealloc space to lg */</span><br>	spin_lock(&amp;lg-&gt;lg_prealloc_lock);<br>    <span class="hljs-comment">// 遍历桶的链表，然后将ext4_prealloc_space插入其中</span><br>	list_for_each_entry_rcu(tmp_pa, &amp;lg-&gt;lg_prealloc_list[order],<br>						pa_inode_list) &#123;<br>		spin_lock(&amp;tmp_pa-&gt;pa_lock);<br>		<span class="hljs-keyword">if</span> (tmp_pa-&gt;pa_deleted) &#123;<br>			spin_unlock(&amp;tmp_pa-&gt;pa_lock);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>        <span class="hljs-comment">// 在链表里面ext4_prealloc_space是按照可用空间由前到后的顺序排列的</span><br>		<span class="hljs-keyword">if</span> (!added &amp;&amp; pa-&gt;pa_free &lt; tmp_pa-&gt;pa_free) &#123;<br>			<span class="hljs-comment">/* Add to the tail of the previous entry */</span><br>			list_add_tail_rcu(&amp;pa-&gt;pa_inode_list,<br>						&amp;tmp_pa-&gt;pa_inode_list);<br>			added = <span class="hljs-number">1</span>;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * we want to count the total</span><br><span class="hljs-comment">			 * number of entries in the list</span><br><span class="hljs-comment">			 */</span><br>		&#125;<br>		spin_unlock(&amp;tmp_pa-&gt;pa_lock);<br>		lg_prealloc_count++;<br>	&#125;<br>    <span class="hljs-comment">// 如果新的这个ext4_prealloc_space的可用空间是最大的，那么插入到链表尾端</span><br>	<span class="hljs-keyword">if</span> (!added)<br>		list_add_tail_rcu(&amp;pa-&gt;pa_inode_list,<br>					&amp;lg-&gt;lg_prealloc_list[order]);<br>	spin_unlock(&amp;lg-&gt;lg_prealloc_lock);<br><br>	<span class="hljs-comment">// 如果当前桶的预分配空间个数超过了8个，则相应的减少它们</span><br>	<span class="hljs-keyword">if</span> (lg_prealloc_count &gt; <span class="hljs-number">8</span>) &#123;<br>		ext4_mb_discard_lg_preallocations(sb, lg,<br>						  order, lg_prealloc_count);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_discard_lg_preallocations()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">void</span><br><span class="hljs-title function_">ext4_mb_discard_lg_preallocations</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params">					<span class="hljs-keyword">struct</span> ext4_locality_group *lg,</span><br><span class="hljs-params">					<span class="hljs-type">int</span> order, <span class="hljs-type">int</span> total_entries)</span><br>&#123;<br>	<span class="hljs-type">ext4_group_t</span> group = <span class="hljs-number">0</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_buddy</span> <span class="hljs-title">e4b</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">discard_list</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span>, *<span class="hljs-title">tmp</span>;</span><br><br>	mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;discard locality group preallocation\n&quot;</span>);<br><br>	INIT_LIST_HEAD(&amp;discard_list);<br><br>	spin_lock(&amp;lg-&gt;lg_prealloc_lock);<br>	list_for_each_entry_rcu(pa, &amp;lg-&gt;lg_prealloc_list[order],<br>						pa_inode_list) &#123;<br>		spin_lock(&amp;pa-&gt;pa_lock);<br>        <span class="hljs-comment">// 如果预分配空间正在使用(刚刚分配流程在使用)，则不能删除</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;pa-&gt;pa_count)) &#123;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * This is the pa that we just used</span><br><span class="hljs-comment">			 * for block allocation. So don&#x27;t</span><br><span class="hljs-comment">			 * free that</span><br><span class="hljs-comment">			 */</span><br>			spin_unlock(&amp;pa-&gt;pa_lock);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (pa-&gt;pa_deleted) &#123;<br>			spin_unlock(&amp;pa-&gt;pa_lock);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-comment">/* only lg prealloc space */</span><br>		BUG_ON(pa-&gt;pa_type != MB_GROUP_PA);<br><br>		<span class="hljs-comment">/* seems this one can be freed ... */</span><br>		pa-&gt;pa_deleted = <span class="hljs-number">1</span>;<br>		spin_unlock(&amp;pa-&gt;pa_lock);<br>		<span class="hljs-comment">// 将预分配空间摘链</span><br>		list_del_rcu(&amp;pa-&gt;pa_inode_list);<br>        <span class="hljs-comment">// 加入到临时的discard_list链表中</span><br>		list_add(&amp;pa-&gt;u.pa_tmp_list, &amp;discard_list);<br><br>		total_entries--;<br>		<span class="hljs-keyword">if</span> (total_entries &lt;= <span class="hljs-number">5</span>) &#123; <span class="hljs-comment">// 预分配空间个数减少到5个的时候才停止，以防止很快又调用本函数</span><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * we want to keep only 5 entries</span><br><span class="hljs-comment">			 * allowing it to grow to 8. This</span><br><span class="hljs-comment">			 * mak sure we don&#x27;t call discard</span><br><span class="hljs-comment">			 * soon for this list.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>	spin_unlock(&amp;lg-&gt;lg_prealloc_lock);<br><br>	list_for_each_entry_safe(pa, tmp, &amp;discard_list, u.pa_tmp_list) &#123;<br>		<span class="hljs-type">int</span> err;<br><br>		group = ext4_get_group_number(sb, pa-&gt;pa_pstart);<br>		err = ext4_mb_load_buddy_gfp(sb, group, &amp;e4b,<br>					     GFP_NOFS|__GFP_NOFAIL);<br>		<span class="hljs-keyword">if</span> (err) &#123;<br>			ext4_error(sb, <span class="hljs-string">&quot;Error %d loading buddy information for %u&quot;</span>,<br>				   err, group);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		ext4_lock_group(sb, group);<br>		list_del(&amp;pa-&gt;pa_group_list); <span class="hljs-comment">// 从ext4_group_info里面摘链</span><br>		ext4_mb_release_group_pa(&amp;e4b, pa); <span class="hljs-comment">// 释放预分配空间，将其返还给文件系统</span><br>		ext4_unlock_group(sb, group);<br><br>		ext4_mb_unload_buddy(&amp;e4b);<br>		list_del(&amp;pa-&gt;u.pa_tmp_list);<br>		call_rcu(&amp;(pa)-&gt;u.pa_rcu, ext4_mb_pa_callback); <span class="hljs-comment">// 在callback里面会释放掉ext4_prealloc_space</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_new_inode_pa()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_new_inode_pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_inode_info</span> *<span class="hljs-title">ei</span>;</span><br><br>	<span class="hljs-comment">/* preallocate only when found space is larger then requested */</span><br>	BUG_ON(ac-&gt;ac_o_ex.fe_len &gt;= ac-&gt;ac_b_ex.fe_len);<br>	BUG_ON(ac-&gt;ac_status != AC_STATUS_FOUND);<br>	BUG_ON(!S_ISREG(ac-&gt;ac_inode-&gt;i_mode));<br><br>	pa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);<br>	<span class="hljs-keyword">if</span> (pa == <span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br><br>	<span class="hljs-keyword">if</span> (ac-&gt;ac_b_ex.fe_len &lt; ac-&gt;ac_g_ex.fe_len) &#123;<br>		<span class="hljs-type">int</span> winl;<br>		<span class="hljs-type">int</span> wins;<br>		<span class="hljs-type">int</span> win;<br>		<span class="hljs-type">int</span> offs;<br><br>		<span class="hljs-comment">/* we can&#x27;t allocate as much as normalizer wants.</span><br><span class="hljs-comment">		 * so, found space must get proper lstart</span><br><span class="hljs-comment">		 * to cover original request */</span><br>		BUG_ON(ac-&gt;ac_g_ex.fe_logical &gt; ac-&gt;ac_o_ex.fe_logical);<br>		BUG_ON(ac-&gt;ac_g_ex.fe_len &lt; ac-&gt;ac_o_ex.fe_len);<br><br>		<span class="hljs-comment">/* we&#x27;re limited by original request in that</span><br><span class="hljs-comment">		 * logical block must be covered any way</span><br><span class="hljs-comment">		 * winl is window we can move our chunk within */</span><br>		winl = ac-&gt;ac_o_ex.fe_logical - ac-&gt;ac_g_ex.fe_logical;<br><br>		<span class="hljs-comment">/* also, we should cover whole original request */</span><br>		wins = EXT4_C2B(sbi, ac-&gt;ac_b_ex.fe_len - ac-&gt;ac_o_ex.fe_len);<br><br>		<span class="hljs-comment">/* the smallest one defines real window */</span><br>		win = min(winl, wins);<br><br>		offs = ac-&gt;ac_o_ex.fe_logical %<br>			EXT4_C2B(sbi, ac-&gt;ac_b_ex.fe_len);<br>		<span class="hljs-keyword">if</span> (offs &amp;&amp; offs &lt; win)<br>			win = offs;<br><br>		ac-&gt;ac_b_ex.fe_logical = ac-&gt;ac_o_ex.fe_logical -<br>			EXT4_NUM_B2C(sbi, win);<br>		BUG_ON(ac-&gt;ac_o_ex.fe_logical &lt; ac-&gt;ac_b_ex.fe_logical);<br>		BUG_ON(ac-&gt;ac_o_ex.fe_len &gt; ac-&gt;ac_b_ex.fe_len);<br>	&#125;<br><br>	<span class="hljs-comment">/* preallocation can change ac_b_ex, thus we store actually</span><br><span class="hljs-comment">	 * allocated blocks for history */</span><br>	ac-&gt;ac_f_ex = ac-&gt;ac_b_ex; <span class="hljs-comment">// 还是先将ac_b_ex拷贝到ac_f_ex</span><br><br>	pa-&gt;pa_lstart = ac-&gt;ac_b_ex.fe_logical;<br>	pa-&gt;pa_pstart = ext4_grp_offs_to_block(sb, &amp;ac-&gt;ac_b_ex);<br>	pa-&gt;pa_len = ac-&gt;ac_b_ex.fe_len;<br>	pa-&gt;pa_free = pa-&gt;pa_len;<br>	<span class="hljs-type">atomic_set</span>(&amp;pa-&gt;pa_count, <span class="hljs-number">1</span>);<br>	spin_lock_init(&amp;pa-&gt;pa_lock);<br>	INIT_LIST_HEAD(&amp;pa-&gt;pa_inode_list);<br>	INIT_LIST_HEAD(&amp;pa-&gt;pa_group_list);<br>	pa-&gt;pa_deleted = <span class="hljs-number">0</span>;<br>	pa-&gt;pa_type = MB_INODE_PA;<br><br>	mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;new inode pa %p: %llu/%u for %u\n&quot;</span>, pa,<br>			pa-&gt;pa_pstart, pa-&gt;pa_len, pa-&gt;pa_lstart);<br>	trace_ext4_mb_new_inode_pa(ac, pa);<br>	<span class="hljs-comment">// 同样的也会走ext4_mb_release_context()流程</span><br>	ext4_mb_use_inode_pa(ac, pa);<br>	<span class="hljs-type">atomic_add</span>(pa-&gt;pa_free, &amp;sbi-&gt;s_mb_preallocated);<br><br>	ei = EXT4_I(ac-&gt;ac_inode);<br>	grp = ext4_get_group_info(sb, ac-&gt;ac_b_ex.fe_group);<br><br>	pa-&gt;pa_obj_lock = &amp;ei-&gt;i_prealloc_lock;<br>	pa-&gt;pa_inode = ac-&gt;ac_inode;<br>	<span class="hljs-comment">// 加入到block group的链表下</span><br>	ext4_lock_group(sb, ac-&gt;ac_b_ex.fe_group);<br>	list_add(&amp;pa-&gt;pa_group_list, &amp;grp-&gt;bb_prealloc_list);<br>	ext4_unlock_group(sb, ac-&gt;ac_b_ex.fe_group);<br>	<span class="hljs-comment">// 加入到ext4_inode_info的i_prealloc_list链表下，供后续大文件的预分配</span><br>	spin_lock(pa-&gt;pa_obj_lock);<br>	list_add_rcu(&amp;pa-&gt;pa_inode_list, &amp;ei-&gt;i_prealloc_list);<br>	spin_unlock(pa-&gt;pa_obj_lock);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上述流程分析可以看出per_cpu locality group的预分配方式的预分配空间是文件系统全局的，这样可以使得小文件都聚集在一起，而per inode的预分配方式是针对单个文件的，使得文件所占的物理空间尽量挨在一起。</p>
<h3 id="mballoc多块分配-1"><a href="#mballoc多块分配-1" class="headerlink" title="mballoc多块分配"></a>mballoc多块分配</h3><p>在开始分析ext4_mb_regular_allocator()的多块分配流程之前，我们先来分析多块分配所采用的buddy系统的数据结构和初始化流程。</p>
<p>buddy系统将block group内的空闲空间按照其长度的阶进行分组，分组的长度为2^0到2^13次方，一个block group通常有32768个block，因此最多可以划分成4个2^13和32768个2^0，其他的阶以此类推。</p>
<p>查看&#x2F;proc&#x2F;fs&#x2F;ext4&#x2F;<partition>&#x2F;mb_groups可以看到当前所有block group的空闲空间分组情况：			</p>
<p><img src="/assets/image-20210926201914119.png" srcset="/img/loading.gif" lazyload alt="image-20210926201914119"></p>
<p>struct ext4_buddy结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_buddy</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">bd_buddy_page</span>;</span> <span class="hljs-comment">// buddy系统有一个4k大小的bitmap来表示block group内的空间使用情况，而这个bitmap是由页缓存来管理的，这里就是bitmap所在的页</span><br>	<span class="hljs-type">void</span> *bd_buddy; <span class="hljs-comment">// 指向页里面具体的buddy的bitmap</span><br>    <span class="hljs-comment">// buddy的bitmap是根据block group内的block bitmap构建而成的，这里是对应的block bitmap</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">bd_bitmap_page</span>;</span> <br>	<span class="hljs-type">void</span> *bd_bitmap;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">bd_info</span>;</span> <span class="hljs-comment">// block group的信息</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">bd_sb</span>;</span><br>	__u16 bd_blkbits; <span class="hljs-comment">// 在load buddy的时候初始化为super_block的s_blocksize_bits，通常为12</span><br>	<span class="hljs-type">ext4_group_t</span> bd_group;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>buddy系统的bitmap是由页缓存来管理的，而这个页缓存必须是整个文件系统范围内的，因此ext4在ext4_sb_info结构里面用一个inode结构体来管理buddy的页缓存，字段名为s_buddy_cache。我们通过分析buddy系统的初始化流程来深入理解其构造：</p>
<p>ext4调用ext4_mb_init_group()函数对buddy系统进行初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_init_group</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">ext4_group_t</span> group, <span class="hljs-type">gfp_t</span> gfp)</span><br>&#123;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">this_grp</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_buddy</span> <span class="hljs-title">e4b</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br>	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>	might_sleep();<br>	mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;init group %u\n&quot;</span>, group);<br>	this_grp = ext4_get_group_info(sb, group);<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * This ensures that we don&#x27;t reinit the buddy cache</span><br><span class="hljs-comment">	 * page which map to the group from which we are already</span><br><span class="hljs-comment">	 * allocating. If we are looking at the buddy cache we would</span><br><span class="hljs-comment">	 * have taken a reference using ext4_mb_load_buddy and that</span><br><span class="hljs-comment">	 * would have pinned buddy page to page cache.</span><br><span class="hljs-comment">	 * The call to ext4_mb_get_buddy_page_lock will mark the</span><br><span class="hljs-comment">	 * page accessed.</span><br><span class="hljs-comment">	 */</span><br>	 <span class="hljs-comment">// 申请buddy系统的页</span><br>	ret = ext4_mb_get_buddy_page_lock(sb, group, &amp;e4b, gfp);<br>	<span class="hljs-keyword">if</span> (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * somebody initialized the group</span><br><span class="hljs-comment">		 * return without doing anything</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">goto</span> err;<br>	&#125;<br><br>	page = e4b.bd_bitmap_page;<br>    <span class="hljs-comment">// 负责读取磁盘，并且初始化block bitmap</span><br>	ret = ext4_mb_init_cache(page, <span class="hljs-literal">NULL</span>, gfp); <br>	<span class="hljs-keyword">if</span> (ret)<br>		<span class="hljs-keyword">goto</span> err;<br>	<span class="hljs-keyword">if</span> (!PageUptodate(page)) &#123;<br>		ret = -EIO;<br>		<span class="hljs-keyword">goto</span> err;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (e4b.bd_buddy_page == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * If both the bitmap and buddy are in</span><br><span class="hljs-comment">		 * the same page we don&#x27;t need to force</span><br><span class="hljs-comment">		 * init the buddy</span><br><span class="hljs-comment">		 */</span><br>		ret = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">goto</span> err;<br>	&#125;<br>	<span class="hljs-comment">// 初始化buddy bit map</span><br>	page = e4b.bd_buddy_page;<br>	ret = ext4_mb_init_cache(page, e4b.bd_bitmap, gfp);<br>	<span class="hljs-keyword">if</span> (ret)<br>		<span class="hljs-keyword">goto</span> err;<br>	<span class="hljs-keyword">if</span> (!PageUptodate(page)) &#123;<br>		ret = -EIO;<br>		<span class="hljs-keyword">goto</span> err;<br>	&#125;<br>err:<br>	ext4_mb_put_buddy_page_lock(&amp;e4b);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_get_buddy_page_lock()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_get_buddy_page_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params">		<span class="hljs-type">ext4_group_t</span> group, <span class="hljs-keyword">struct</span> ext4_buddy *e4b, <span class="hljs-type">gfp_t</span> gfp)</span><br>&#123;<br>	<span class="hljs-comment">// 所有buddy的内存内容都是由s_buddy_cache管理</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> EXT4_SB(sb)-&gt;s_buddy_cache;<br>	<span class="hljs-type">int</span> block, pnum, poff;<br>	<span class="hljs-type">int</span> blocks_per_page;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br>	e4b-&gt;bd_buddy_page = <span class="hljs-literal">NULL</span>;<br>	e4b-&gt;bd_bitmap_page = <span class="hljs-literal">NULL</span>;<br><br>	blocks_per_page = PAGE_SIZE / sb-&gt;s_blocksize; <span class="hljs-comment">// 假定块大小为4k，则blocks_per_page为1</span><br>	<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	在s_buddy_cache的页缓存里，page的index为偶数的时候代表这个page里面装的是block group的block bitmap，为奇数的时候page里面装的是buddy bitmap，也叫buddy cache，也就是说0、2、4、6、8...为block bit map的page，每个block bitmap page紧挨着的1、3、5、7、9..为buddy bitmap page，依次对应的block group的编号为0、1、2、3、4...</span><br><span class="hljs-comment">    */</span><br>	block = group * <span class="hljs-number">2</span>;<br>	pnum = block / blocks_per_page; <span class="hljs-comment">// 就是block</span><br>	poff = block % blocks_per_page; <span class="hljs-comment">// 0</span><br>    <span class="hljs-comment">// 找到或者创建page来存储block bitmap</span><br>	page = find_or_create_page(inode-&gt;i_mapping, pnum, gfp);<br>	<span class="hljs-keyword">if</span> (!page)<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br>	BUG_ON(page-&gt;mapping != inode-&gt;i_mapping);<br>	e4b-&gt;bd_bitmap_page = page;<br>    <span class="hljs-comment">// 通常这里就是page的首地址</span><br>	e4b-&gt;bd_bitmap = page_address(page) + (poff * sb-&gt;s_blocksize);<br><br>	<span class="hljs-keyword">if</span> (blocks_per_page &gt;= <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-comment">/* buddy and bitmap are on the same page */</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br><br>	block++; <span class="hljs-comment">// 获取到buddy_page，buddy bitmap的page排在block bitmap page的后面</span><br>	pnum = block / blocks_per_page;<br>	page = find_or_create_page(inode-&gt;i_mapping, pnum, gfp);<br>	<span class="hljs-keyword">if</span> (!page)<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br>	BUG_ON(page-&gt;mapping != inode-&gt;i_mapping);<br>	e4b-&gt;bd_buddy_page = page;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_init_cache()函数，ext4_mb_init_group()函数会调用两次这个函数，区别是第一次调时incore为空，为的是初始化block bitmap；第二次调用时，incore传入的是bd_bitmap，用block bitmap来初始化buddy bitmap。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_init_cache</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">char</span> *incore, <span class="hljs-type">gfp_t</span> gfp)</span><br>&#123;<br>	<span class="hljs-type">ext4_group_t</span> ngroups;<br>	<span class="hljs-type">int</span> blocksize;<br>	<span class="hljs-type">int</span> blocks_per_page;<br>	<span class="hljs-type">int</span> groups_per_page;<br>	<span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-type">ext4_group_t</span> first_group, group;<br>	<span class="hljs-type">int</span> first_block;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> *<span class="hljs-title">bhs</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> **<span class="hljs-title">bh</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span>;</span><br>	<span class="hljs-type">char</span> *data;<br>	<span class="hljs-type">char</span> *bitmap;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grinfo</span>;</span><br><br>	mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;init page %lu\n&quot;</span>, page-&gt;index);<br><br>	inode = page-&gt;mapping-&gt;host;<br>	sb = inode-&gt;i_sb;<br>	ngroups = ext4_get_groups_count(sb);<br>	blocksize = i_blocksize(inode);<br>	blocks_per_page = PAGE_SIZE / blocksize;<br><br>    <span class="hljs-comment">// 通常情况下blocks_per_page为1，这里groups_per_page的最终结果为1</span><br>	groups_per_page = blocks_per_page &gt;&gt; <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (groups_per_page == <span class="hljs-number">0</span>)<br>		groups_per_page = <span class="hljs-number">1</span>;<br><br>	<span class="hljs-comment">/* allocate buffer_heads to read bitmaps */</span><br>	<span class="hljs-keyword">if</span> (groups_per_page &gt; <span class="hljs-number">1</span>) &#123;<br>		i = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> buffer_head *) * groups_per_page;<br>		bh = kzalloc(i, gfp);<br>		<span class="hljs-keyword">if</span> (bh == <span class="hljs-literal">NULL</span>) &#123;<br>			err = -ENOMEM;<br>			<span class="hljs-keyword">goto</span> out;<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span><br>		bh = &amp;bhs;<br><br>	first_group = page-&gt;index * blocks_per_page / <span class="hljs-number">2</span>;<br><br>	<span class="hljs-comment">/* read all groups the page covers into the cache */</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, group = first_group; i &lt; groups_per_page; i++, group++) &#123;<br>		<span class="hljs-keyword">if</span> (group &gt;= ngroups)<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-comment">// block group信息以二维数组的形式存在ext4_sb_info里面的，</span><br>        <span class="hljs-comment">// 二维数组一行64个，通过对64取商能找到其在第几行，通过对64取余能找到在第几列</span><br>		grinfo = ext4_get_group_info(sb, group);<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * If page is uptodate then we came here after online resize</span><br><span class="hljs-comment">		 * which added some new uninitialized group info structs, so</span><br><span class="hljs-comment">		 * we must skip all initialized uptodate buddies on the page,</span><br><span class="hljs-comment">		 * which may be currently in use by an allocating task.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (PageUptodate(page) &amp;&amp; !EXT4_MB_GRP_NEED_INIT(grinfo)) &#123;<br>			bh[i] = <span class="hljs-literal">NULL</span>;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>        <span class="hljs-comment">// 发送读IO去读取block bitmap</span><br>        <span class="hljs-comment">// 通过block group的编号能够拿到block group在磁盘上的描述ext4_group_desc，通过ext4_group_desc能够拿到block group的block bitmap在哪个block，然后通过在super_block里面的页缓存获取到block bitmap的具体内容</span><br>        <span class="hljs-comment">// 在super_block里面的页缓存是针对文件系统的元素据的缓存，而在inode里面的缓存是文件的数据的页缓存</span><br>		bh[i] = ext4_read_block_bitmap_nowait(sb, group);<br>		<span class="hljs-keyword">if</span> (IS_ERR(bh[i])) &#123;<br>			err = PTR_ERR(bh[i]);<br>			bh[i] = <span class="hljs-literal">NULL</span>;<br>			<span class="hljs-keyword">goto</span> out;<br>		&#125;<br>		mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;read bitmap for group %u\n&quot;</span>, group);<br>	&#125;<br><br>	<span class="hljs-comment">// 等待读block bitmap的IO完成</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, group = first_group; i &lt; groups_per_page; i++, group++) &#123;<br>		<span class="hljs-type">int</span> err2;<br><br>		<span class="hljs-keyword">if</span> (!bh[i])<br>			<span class="hljs-keyword">continue</span>;<br>		err2 = ext4_wait_block_bitmap(sb, group, bh[i]);<br>		<span class="hljs-keyword">if</span> (!err)<br>			err = err2;<br>	&#125;<br><br>	first_block = page-&gt;index * blocks_per_page; <span class="hljs-comment">// 这个页里面的第一个block</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; blocks_per_page; i++) &#123;<br>		group = (first_block + i) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 除以2，得到block group号</span><br>		<span class="hljs-keyword">if</span> (group &gt;= ngroups)<br>			<span class="hljs-keyword">break</span>;<br><br>		<span class="hljs-keyword">if</span> (!bh[group - first_group])<br>			<span class="hljs-comment">/* skip initialized uptodate buddy */</span><br>			<span class="hljs-keyword">continue</span>;<br><br>		<span class="hljs-keyword">if</span> (!buffer_verified(bh[group - first_group]))<br>			<span class="hljs-comment">/* Skip faulty bitmaps */</span><br>			<span class="hljs-keyword">continue</span>;<br>		err = <span class="hljs-number">0</span>;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * data carry information regarding this</span><br><span class="hljs-comment">		 * particular group in the format specified</span><br><span class="hljs-comment">		 * above</span><br><span class="hljs-comment">		 *</span><br><span class="hljs-comment">		 */</span><br>		data = page_address(page) + (i * blocksize);<br>		bitmap = bh[group - first_group]-&gt;b_data;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * We place the buddy block and bitmap block</span><br><span class="hljs-comment">		 * close together</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> ((first_block + i) &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 奇数则为buddy bitmap</span><br>			<span class="hljs-comment">/* this is block of buddy */</span><br>			BUG_ON(incore == <span class="hljs-literal">NULL</span>);<br>			mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;put buddy for group %u in page %lu/%x\n&quot;</span>,<br>				group, page-&gt;index, i * blocksize);<br>			trace_ext4_mb_buddy_bitmap_load(sb, group);<br>			grinfo = ext4_get_group_info(sb, group);<br>			grinfo-&gt;bb_fragments = <span class="hljs-number">0</span>;<br>			<span class="hljs-built_in">memset</span>(grinfo-&gt;bb_counters, <span class="hljs-number">0</span>,<br>			       <span class="hljs-keyword">sizeof</span>(*grinfo-&gt;bb_counters) *<br>				(sb-&gt;s_blocksize_bits+<span class="hljs-number">2</span>)); <span class="hljs-comment">// 0 到 13 一共14个</span><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * incore got set to the group block bitmap below</span><br><span class="hljs-comment">			 */</span><br>			ext4_lock_group(sb, group);<br>			<span class="hljs-comment">/* init the buddy */</span><br>			<span class="hljs-built_in">memset</span>(data, <span class="hljs-number">0xff</span>, blocksize); <span class="hljs-comment">// 先把buddy page全部置成1，有空闲的则清为0</span><br>			<span class="hljs-comment">// 初始化buddy重点这个函数</span><br>			ext4_mb_generate_buddy(sb, data, incore, group);<br>			ext4_unlock_group(sb, group);<br>			incore = <span class="hljs-literal">NULL</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 偶数为block bitmap</span><br>			<span class="hljs-comment">/* this is block of bitmap */</span><br>			BUG_ON(incore != <span class="hljs-literal">NULL</span>);<br>			mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;put bitmap for group %u in page %lu/%x\n&quot;</span>,<br>				group, page-&gt;index, i * blocksize);<br>			trace_ext4_mb_bitmap_load(sb, group);<br><br>			<span class="hljs-comment">/* see comments in ext4_mb_put_pa() */</span><br>			ext4_lock_group(sb, group);<br>            <span class="hljs-comment">// 将读上来的block bitmap拷贝到buddy系统的页缓存里面</span><br>			<span class="hljs-built_in">memcpy</span>(data, bitmap, blocksize); <br><br>			<span class="hljs-comment">/* mark all preallocated blks used in in-core bitmap */</span><br>			ext4_mb_generate_from_pa(sb, data, group);<br>			ext4_mb_generate_from_freelist(sb, data, group);<br>			ext4_unlock_group(sb, group);<br><br>			<span class="hljs-comment">/* set incore so that the buddy information can be</span><br><span class="hljs-comment">			 * generated using this</span><br><span class="hljs-comment">			 */</span><br>			incore = data;<br>		&#125;<br>	&#125;<br>	SetPageUptodate(page);<br><br>out:<br>	<span class="hljs-keyword">if</span> (bh) &#123;<br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; groups_per_page; i++)<br>			brelse(bh[i]);<br>		<span class="hljs-keyword">if</span> (bh != &amp;bhs)<br>			kfree(bh);<br>	&#125;<br>	<span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在读取了block bitmap后将其拷贝到buddy系统的页缓存里面，此后还要调用两个函数来做一些标记：</p>
<p>1）ext4_mb_generate_from_pa()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_generate_from_pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *bitmap,</span><br><span class="hljs-params">					<span class="hljs-type">ext4_group_t</span> group)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span> =</span> ext4_get_group_info(sb, group);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">cur</span>;</span><br>	<span class="hljs-type">ext4_group_t</span> groupnr;<br>	<span class="hljs-type">ext4_grpblk_t</span> start;<br>	<span class="hljs-type">int</span> preallocated = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> len;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		遍历所有该block group下的预分配空间，将预分配空间的范围标记到block bitmap里面</span><br><span class="hljs-comment">	*/</span><br>	list_for_each(cur, &amp;grp-&gt;bb_prealloc_list) &#123;<br>		pa = list_entry(cur, <span class="hljs-keyword">struct</span> ext4_prealloc_space, pa_group_list);<br>		spin_lock(&amp;pa-&gt;pa_lock);<br>		ext4_get_group_no_and_offset(sb, pa-&gt;pa_pstart,<br>					     &amp;groupnr, &amp;start);<br>		len = pa-&gt;pa_len;<br>		spin_unlock(&amp;pa-&gt;pa_lock);<br>		<span class="hljs-keyword">if</span> (unlikely(len == <span class="hljs-number">0</span>))<br>			<span class="hljs-keyword">continue</span>;<br>		BUG_ON(groupnr != group);<br>		ext4_set_bits(bitmap, start, len);<br>		preallocated += len;<br>	&#125;<br>    <br>	mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;preallocated %u for group %u\n&quot;</span>, preallocated, group);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>2）ext4_mb_generate_from_freelist()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_generate_from_freelist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *bitmap,</span><br><span class="hljs-params">						<span class="hljs-type">ext4_group_t</span> group)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">n</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_data</span> *<span class="hljs-title">entry</span>;</span><br><br>	grp = ext4_get_group_info(sb, group);<br>	n = rb_first(&amp;(grp-&gt;bb_free_root));<br>	<span class="hljs-comment">// 遍历block group的bb_free_root红黑树，将空间范围标记到block bitmap里面</span><br>	<span class="hljs-keyword">while</span> (n) &#123;<br>		entry = rb_entry(n, <span class="hljs-keyword">struct</span> ext4_free_data, efd_node);<br>		ext4_set_bits(bitmap, entry-&gt;efd_start_cluster, entry-&gt;efd_count);<br>		n = rb_next(n);<br>	&#125;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>初始化buddy bitmap：</p>
<p>struct ext4_group_info结构体，用于描述block group在内存中的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   bb_state;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span>  <span class="hljs-title">bb_free_root</span>;</span> <span class="hljs-comment">// 挂ext4_free_data的红黑树</span><br>	<span class="hljs-type">ext4_grpblk_t</span>	bb_first_free;	<span class="hljs-comment">// 第一个是空闲的块</span><br>	<span class="hljs-type">ext4_grpblk_t</span>	bb_free;	<span class="hljs-comment">// 总的空间块个数</span><br>	<span class="hljs-type">ext4_grpblk_t</span>	bb_fragments;	<span class="hljs-comment">// 连续的空闲空间段数目</span><br>	<span class="hljs-type">ext4_grpblk_t</span>	bb_largest_free_order; <span class="hljs-comment">// block group中最大的空闲空间的阶</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span>          <span class="hljs-title">list_head</span> <span class="hljs-title">bb_prealloc_list</span>;</span> <span class="hljs-comment">// 挂ext4_prealloc_space</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DOUBLE_CHECK</span><br>	<span class="hljs-type">void</span>            *bb_bitmap;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span> <span class="hljs-title">alloc_sem</span>;</span><br>	<span class="hljs-type">ext4_grpblk_t</span>	bb_counters[];	<span class="hljs-comment">// 用一个0长数组记录每个阶的空闲空间有多少个</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>初始化buddy bitmap需要知道这到底是个什么，它跟block bitmap的关系是什么：</p>
<p>通常情况下block bitmap和buddy bitmap的大小都是4k，对于block bitmap来说，4k的空间有32768个bit位，而每一个bit位代表一个block块(4k）的使用情况(1为占用，0为空闲)，因此能表示128M的空间。</p>
<p>buddy bitmap首先拿出这32768个bit位的前一半，也就是0-16383，这些bit位每一个bit位表示连续的两个(2^1)block的空闲情况；然后再从剩下的一半bit中拿出一半的bit来表示连续4个(2^2)block的使用情况；接着再从剩下的一半bit位里面拿出一半来表示连续8个(2^3)block的使用情况……依次类推，最终可以表示4个2^13个block的使用情况。							</p>
<p>![buddy bitmap](assets&#x2F;buddy bitmap.jpg)</p>
<p>举个例子，在初始化的时候，buddy系统通过block bitmap发现有连续的14个空间是连续的，并假设其地址为0-13(相对于block group的第一个block而言的)，此时流程会将这个14个block按照阶划分为8+4+2，即分到3阶、2阶和1阶，对应在buddy bitmap的bit位里面（借用一张其他人画的图）：</p>
<p><img src="/assets/image-20210919211523460.png" srcset="/img/loading.gif" lazyload alt="image-20210919211523460"></p>
<p>由图可见，buddy bitmap里面不仅仅包含了block的使用情况信息，而且还包含了block的位置信息(划分到1阶的那两个block的偏移为12-13，bitmap里面的第7个bit位为0)。此外，我们还可以看出当高阶为0时所有的低阶都为1，这是初始化的结果。</p>
<p>那么有的同学会问了，当只有一个block是连续的空闲空间时怎么表示呢？</p>
<p>当空闲空间只有一个block时，buddy系统将其记录在ext4_group_info的bb_counters[0]里面。</p>
<p>ext4_mb_init_cache()函数的第114到133行：</p>
<p>首先获取ext4_group_info准备初始化，将bb_fragments和bb_counters都置为0，后续会增加这两个值，接着第129行将buddy bitmap全部置1，当后续遍历block bitmap时划分了阶再置相应的bit为0，最后调用ext4_mb_generate_buddy()函数根据block bitmap初始化buddy bitmap：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_generate_buddy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params">				<span class="hljs-type">void</span> *buddy, <span class="hljs-type">void</span> *bitmap, <span class="hljs-type">ext4_group_t</span> group)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span> =</span> ext4_get_group_info(sb, group);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br>	<span class="hljs-type">ext4_grpblk_t</span> max = EXT4_CLUSTERS_PER_GROUP(sb); <span class="hljs-comment">// max为每个group的cluster数量</span><br>	<span class="hljs-type">ext4_grpblk_t</span> i = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">ext4_grpblk_t</span> first;<br>	<span class="hljs-type">ext4_grpblk_t</span> len;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-built_in">free</span> = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> fragments = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> period = get_cycles();<br><br>	<span class="hljs-comment">/* initialize buddy from bitmap which is aggregation</span><br><span class="hljs-comment">	 * of on-disk bitmap and preallocations */</span><br>	i = mb_find_next_zero_bit(bitmap, max, <span class="hljs-number">0</span>); <span class="hljs-comment">// 找到bitmap里面第一个0，也就是第一个空闲block的位置</span><br>	grp-&gt;bb_first_free = i;<br>	<span class="hljs-keyword">while</span> (i &lt; max) &#123;<br>		fragments++;<br>		first = i;<br>        <span class="hljs-comment">// 找到从i开始的下一个1的位置，从i到这个位置就是这一段空闲空间的长度（i - first）</span><br>		i = mb_find_next_bit(bitmap, max, i);<br>		len = i - first;<br>		<span class="hljs-built_in">free</span> += len; <span class="hljs-comment">// 记录总的空闲空间的长度</span><br>		<span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 如果长度大于1则去划分阶，然后记录到buddy bitmap和bb_counters</span><br>			ext4_mb_mark_free_simple(sb, buddy, first, len, grp);<br>		<span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 如果长度为1则记录到bb_counters中即可</span><br>			grp-&gt;bb_counters[<span class="hljs-number">0</span>]++;<br>        <span class="hljs-comment">// 继续寻找下一段空闲空间</span><br>		<span class="hljs-keyword">if</span> (i &lt; max)<br>			i = mb_find_next_zero_bit(bitmap, max, i);<br>	&#125;<br>	grp-&gt;bb_fragments = fragments; <span class="hljs-comment">// 碎片数</span><br><br>	.......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_mark_free_simple()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_mark_free_simple</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params">				<span class="hljs-type">void</span> *buddy, <span class="hljs-type">ext4_grpblk_t</span> first, <span class="hljs-type">ext4_grpblk_t</span> len,</span><br><span class="hljs-params">					<span class="hljs-keyword">struct</span> ext4_group_info *grp)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br>	<span class="hljs-type">ext4_grpblk_t</span> min;<br>	<span class="hljs-type">ext4_grpblk_t</span> max;<br>	<span class="hljs-type">ext4_grpblk_t</span> chunk;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> border;<br><br>	BUG_ON(len &gt; EXT4_CLUSTERS_PER_GROUP(sb));<br><br>	border = <span class="hljs-number">2</span> &lt;&lt; sb-&gt;s_blocksize_bits; <span class="hljs-comment">// 8192即2^13次方, 32M的空间</span><br><br>	<span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 将长度进行拆分，比如长度为14会拆分成8+4+2</span><br>		<span class="hljs-comment">/* find how many blocks can be covered since this position */</span><br>		<span class="hljs-comment">// ffs为find first set，转换成二进制之后从右往左的第一个1的位置</span><br>		max = ffs(first | border) - <span class="hljs-number">1</span>;<br><br>	 	<span class="hljs-comment">// find last set，转换成二进制之后从右往左的最后一个1的位置</span><br>		min = fls(len) - <span class="hljs-number">1</span>;<br><br>		<span class="hljs-keyword">if</span> (max &lt; min)<br>			min = max;<br>		chunk = <span class="hljs-number">1</span> &lt;&lt; min;<br><br>		<span class="hljs-comment">// 往bb_counters记录计数</span><br>		grp-&gt;bb_counters[min]++;<br>		<span class="hljs-keyword">if</span> (min &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 将buddy bitmap里面的相应的bit位置0</span><br>            <span class="hljs-comment">// buddy + sbi-&gt;s_mb_offsets[min]的意思是找到对应阶的bit位的起始位置</span><br>            <span class="hljs-comment">// 例如1阶的起始位置是0，二阶的起始位置是16384......</span><br>			mb_clear_bit(first &gt;&gt; min,<br>				     buddy + sbi-&gt;s_mb_offsets[min]);<br><br>		len -= chunk;<br>		first += chunk;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到此位置buddy bitmap和相关的计数就已经完成了，可以进行多块分配动作，让我们回到ext4_mb_regular_allocator()函数，这个函数太长，我们还是分成两个部分来分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_regular_allocator</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br>	<span class="hljs-type">ext4_group_t</span> ngroups, group, i;<br>	<span class="hljs-type">int</span> cr;<br>	<span class="hljs-type">int</span> err = <span class="hljs-number">0</span>, first_err = <span class="hljs-number">0</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_buddy</span> <span class="hljs-title">e4b</span>;</span><br><br>	sb = ac-&gt;ac_sb;<br>	sbi = EXT4_SB(sb);<br>	ngroups = ext4_get_groups_count(sb); <span class="hljs-comment">// 文件系统的block group个数</span><br>	<span class="hljs-comment">/* non-extent files are limited to low blocks/groups */</span><br>	<span class="hljs-keyword">if</span> (!(ext4_test_inode_flag(ac-&gt;ac_inode, EXT4_INODE_EXTENTS)))<br>		ngroups = sbi-&gt;s_blockfile_groups;<br><br>	BUG_ON(ac-&gt;ac_status == AC_STATUS_FOUND);<br><br>	<span class="hljs-comment">// 先尝试在goal的地方能不能分配</span><br>	err = ext4_mb_find_by_goal(ac, &amp;e4b);<br>	<span class="hljs-keyword">if</span> (err || ac-&gt;ac_status == AC_STATUS_FOUND)<br>		<span class="hljs-keyword">goto</span> out;<br><br>	<span class="hljs-keyword">if</span> (unlikely(ac-&gt;ac_flags &amp; EXT4_MB_HINT_GOAL_ONLY))<br>		<span class="hljs-keyword">goto</span> out;<br><br>	......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_find_by_goal()函数，从goal的位置尝试进行分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_find_by_goal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params">				<span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br>	<span class="hljs-type">ext4_group_t</span> group = ac-&gt;ac_g_ex.fe_group;<br>	<span class="hljs-type">int</span> max;<br>	<span class="hljs-type">int</span> err;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(ac-&gt;ac_sb);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span> =</span> ext4_get_group_info(ac-&gt;ac_sb, group);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ex</span>;</span><br><br>	<span class="hljs-keyword">if</span> (!(ac-&gt;ac_flags &amp; EXT4_MB_HINT_TRY_GOAL))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (grp-&gt;bb_free == <span class="hljs-number">0</span>) <span class="hljs-comment">// block group已经没有空闲空间了，直接返回</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// 初始化buddy bitmap，详细见上面</span><br>	err = ext4_mb_load_buddy(ac-&gt;ac_sb, group, e4b);<br>	<span class="hljs-keyword">if</span> (err)<br>		<span class="hljs-keyword">return</span> err;<br><br>	<span class="hljs-keyword">if</span> (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b-&gt;bd_info))) &#123;<br>		ext4_mb_unload_buddy(e4b);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br><br>	ext4_lock_group(ac-&gt;ac_sb, group);<br>	<br>    <span class="hljs-comment">// 根据buddy bitmap寻找合适的空闲空间</span><br>	max = mb_find_extent(e4b, ac-&gt;ac_g_ex.fe_start, <span class="hljs-comment">// start为在group内的偏移</span><br>			     ac-&gt;ac_g_ex.fe_len, &amp;ex);<br>	ex.fe_logical = <span class="hljs-number">0xDEADFA11</span>; <span class="hljs-comment">/* debug value */</span><br><br>    <span class="hljs-comment">// 这个分支是ext4文件系统对raid的优化，当分配的起始地址和长度都对齐到stripe时才分配</span><br>	<span class="hljs-keyword">if</span> (max &gt;= ac-&gt;ac_g_ex.fe_len &amp;&amp; ac-&gt;ac_g_ex.fe_len == sbi-&gt;s_stripe) &#123;<br>		<span class="hljs-type">ext4_fsblk_t</span> start;<br><br>		start = ext4_group_first_block_no(ac-&gt;ac_sb, e4b-&gt;bd_group) +<br>			ex.fe_start;<br>		<span class="hljs-comment">/* use do_div to get remainder (would be 64-bit modulo) */</span><br>		<span class="hljs-keyword">if</span> (do_div(start, sbi-&gt;s_stripe) == <span class="hljs-number">0</span>) &#123;<br>			ac-&gt;ac_found++;<br>			ac-&gt;ac_b_ex = ex;<br>			ext4_mb_use_best_found(ac, e4b);<br>		&#125;<br>    <span class="hljs-comment">// 分配成功</span><br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max &gt;= ac-&gt;ac_g_ex.fe_len) &#123;<br>		BUG_ON(ex.fe_len &lt;= <span class="hljs-number">0</span>);<br>		BUG_ON(ex.fe_group != ac-&gt;ac_g_ex.fe_group);<br>		BUG_ON(ex.fe_start != ac-&gt;ac_g_ex.fe_start);<br>		ac-&gt;ac_found++;<br>		ac-&gt;ac_b_ex = ex;<br>		ext4_mb_use_best_found(ac, e4b);<br>    <span class="hljs-comment">// 调用者只是想合并某些小的空闲空间，这就是其他流程了</span><br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max &gt; <span class="hljs-number">0</span> &amp;&amp; (ac-&gt;ac_flags &amp; EXT4_MB_HINT_MERGE)) &#123;<br>		<span class="hljs-comment">/* Sometimes, caller may want to merge even small</span><br><span class="hljs-comment">		 * number of blocks to an existing extent */</span><br>		BUG_ON(ex.fe_len &lt;= <span class="hljs-number">0</span>);<br>		BUG_ON(ex.fe_group != ac-&gt;ac_g_ex.fe_group);<br>		BUG_ON(ex.fe_start != ac-&gt;ac_g_ex.fe_start);<br>		ac-&gt;ac_found++;<br>		ac-&gt;ac_b_ex = ex;<br>		ext4_mb_use_best_found(ac, e4b);<br>	&#125;<br>	ext4_unlock_group(ac-&gt;ac_sb, group);<br>	ext4_mb_unload_buddy(e4b);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>mb_find_extent()函数，分配的核心函数，根据buddy bitmap进行分配动作，传入的block和needed都是以cluster为单位的，分别表示起始和长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mb_find_extent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_buddy *e4b, <span class="hljs-type">int</span> block, </span><br><span class="hljs-params">				<span class="hljs-type">int</span> needed, <span class="hljs-keyword">struct</span> ext4_free_extent *ex)</span><br>&#123;<br>	<span class="hljs-type">int</span> next = block;<br>	<span class="hljs-type">int</span> max, order;<br>	<span class="hljs-type">void</span> *buddy;<br><br>	assert_spin_locked(ext4_group_lock_ptr(e4b-&gt;bd_sb, e4b-&gt;bd_group));<br>	BUG_ON(ex == <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// max表示传入的阶能够遍历多少个bit位</span><br>    <span class="hljs-comment">// 例如0阶可以遍历整个block bitmap，此时max为32768</span><br>    <span class="hljs-comment">// 1阶就必须遍历buddy bitmap的前半段，max为16384</span><br>    <span class="hljs-comment">// 2阶max为8192</span><br>    <span class="hljs-comment">// 3阶......</span><br>	buddy = mb_find_buddy(e4b, <span class="hljs-number">0</span>, &amp;max); <br>	BUG_ON(buddy == <span class="hljs-literal">NULL</span>);<br>	BUG_ON(block &gt;= max);<br>	<span class="hljs-keyword">if</span> (mb_test_bit(block, buddy)) &#123; <span class="hljs-comment">// 起始位置已经被分配了</span><br>		ex-&gt;fe_len = <span class="hljs-number">0</span>;<br>		ex-&gt;fe_start = <span class="hljs-number">0</span>;<br>		ex-&gt;fe_group = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 注意这里的block是起始位置，不是长度</span><br>    <span class="hljs-comment">// order表示的是从block位置开始的最长空闲空闲长度的阶</span><br>	order = mb_find_order_for_block(e4b, block);<br>	block = block &gt;&gt; order; <span class="hljs-comment">// 将起始位置对齐到order</span><br><br>    <span class="hljs-comment">// fe_len表示已经分配到的长度，当前是假设分配了这么多</span><br>	ex-&gt;fe_len = <span class="hljs-number">1</span> &lt;&lt; order;<br>    <span class="hljs-comment">// 暂时将fe_start与当前的阶对齐</span><br>	ex-&gt;fe_start = block &lt;&lt; order;<br>	ex-&gt;fe_group = e4b-&gt;bd_group; <br><br>	<span class="hljs-comment">/* calc difference from given start */</span><br>	next = next - ex-&gt;fe_start; <span class="hljs-comment">//原始为起始位置减去当前阶的起始位置表示&quot;多分配了&quot;多少个block</span><br>    <span class="hljs-comment">// 与阶对齐的分配长度减去多分配的block就是实际分配到的长度</span><br>	ex-&gt;fe_len -= next; <br>	ex-&gt;fe_start += next; <span class="hljs-comment">// 起始位置最终又被还原到最初的起始位置了 </span><br><br>	<span class="hljs-keyword">while</span> (needed &gt; ex-&gt;fe_len &amp;&amp;<br>	       mb_find_buddy(e4b, order, &amp;max)) &#123; <br><br>		<span class="hljs-keyword">if</span> (block + <span class="hljs-number">1</span> &gt;= max)<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-comment">// 此时的next被赋值为上一次的阶能找到的最长的分配长度后紧接着要从哪里开始分配</span><br>        <span class="hljs-comment">// next与上一次分配的起始位置相差上一次分配的长度</span><br>		next = (block + <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; order); <br>        <span class="hljs-comment">// 如果这一次探测的起始位置已经被占用了则结束后续的探测，因为空闲的block已经不连续了</span><br>		<span class="hljs-keyword">if</span> (mb_test_bit(next, e4b-&gt;bd_bitmap))<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-comment">// 从next开始的连续的空闲空间的长度的阶</span><br>		order = mb_find_order_for_block(e4b, next); <br>		<span class="hljs-comment">// 如果申请分配的长度还没有分配完毕则继续往后探测</span><br>		block = next &gt;&gt; order; <br>		ex-&gt;fe_len += <span class="hljs-number">1</span> &lt;&lt; order; <br>	&#125;<br>	<span class="hljs-comment">// 检查一下</span><br>	<span class="hljs-keyword">if</span> (ex-&gt;fe_start + ex-&gt;fe_len &gt; (<span class="hljs-number">1</span> &lt;&lt; (e4b-&gt;bd_blkbits + <span class="hljs-number">3</span>))) &#123;<br>		<span class="hljs-comment">/* Should never happen! (but apparently sometimes does?!?) */</span><br>		WARN_ON(<span class="hljs-number">1</span>);<br>		ext4_error(e4b-&gt;bd_sb, <span class="hljs-string">&quot;corruption or bug in mb_find_extent &quot;</span><br>			   <span class="hljs-string">&quot;block=%d, order=%d needed=%d ex=%u/%d/%d@%u&quot;</span>,<br>			   block, order, needed, ex-&gt;fe_group, ex-&gt;fe_start,<br>			   ex-&gt;fe_len, ex-&gt;fe_logical);<br>		ex-&gt;fe_len = <span class="hljs-number">0</span>;<br>		ex-&gt;fe_start = <span class="hljs-number">0</span>;<br>		ex-&gt;fe_group = <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ex-&gt;fe_len;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>mb_find_order_for_block()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	block为起始地址，根据buddy bitmap探测从起始位置开始能够分配的最长空闲空间的阶</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mb_find_order_for_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_buddy *e4b, <span class="hljs-type">int</span> block)</span><br>&#123;<br>	<span class="hljs-type">int</span> order = <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> bb_incr = <span class="hljs-number">1</span> &lt;&lt; (e4b-&gt;bd_blkbits - <span class="hljs-number">1</span>); <span class="hljs-comment">// 2048个字节</span><br>	<span class="hljs-type">void</span> *bb;<br><br>	BUG_ON(e4b-&gt;bd_bitmap == e4b-&gt;bd_buddy);<br>	BUG_ON(block &gt;= (<span class="hljs-number">1</span> &lt;&lt; (e4b-&gt;bd_blkbits + <span class="hljs-number">3</span>)));<br><br>	bb = e4b-&gt;bd_buddy;<br><br>	<span class="hljs-keyword">while</span> (order &lt;= e4b-&gt;bd_blkbits + <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// order &lt;= 13</span><br>        <span class="hljs-comment">// order等于1时，buddy bitmap的一个bit位表示两个block，因此起始位置要除以2得到的便是这个起始位置对应这buddy bitmap里面的第几个bit位，然后看这个bit位有无被占用</span><br>		block = block &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 如果这个bit位没有被占用表示可以分配1 &lt;&lt; order个block</span><br>		<span class="hljs-keyword">if</span> (!mb_test_bit(block, bb)) &#123;<br>			<span class="hljs-comment">/* this block is part of buddy of order &#x27;order&#x27; */</span><br>			<span class="hljs-keyword">return</span> order;<br>		&#125;<br>        <span class="hljs-comment">// 如果当前bit位为1，那么有两种情况：</span><br>        <span class="hljs-comment">// 1) 其上阶对应的bit位都为1表示占用，最终会返回order=0</span><br>        <span class="hljs-comment">// 2) 其上阶的某一阶对应的bit位为0表示可用，因此这里向高阶搜索</span><br>		bb += bb_incr; <span class="hljs-comment">// order = 1时，这里加的量是2048字节也就是16384个bit位，就找到了第2阶的buddy bitmap的起始位置</span><br>		bb_incr &gt;&gt;= <span class="hljs-number">1</span>;<br>		order++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>mb_find_extent()函数的第26到59行需要举个例子：</p>
<p>假设申请从7开始分配，分配9个block：</p>
<p>1）假设6-7的block是空闲的，0-5的block是占用的，8-15的block是空闲的，那么它构建出来的buddy bitmap如下：</p>
<p>![buddy bitmap1](assets&#x2F;buddy bitmap1.jpg)</p>
<ul>
<li><input disabled="" type="checkbox"> 28行：order的值为1</li>
<li><input disabled="" type="checkbox"> 29行：block &#x3D; 7 &gt;&gt; 1 &#x3D; 3</li>
<li><input disabled="" type="checkbox"> 32行：fe_len &#x3D; 1 &lt;&lt; 1 &#x3D; 2</li>
<li><input disabled="" type="checkbox"> 34行：fe_start &#x3D; 3 &lt;&lt; 1 &#x3D; 6</li>
<li><input disabled="" type="checkbox"> 38行：next &#x3D; 7 - 6 &#x3D; 1 此时实际应该只分配到了1个block，但却分配到了2个block，多分配了1个block</li>
<li><input disabled="" type="checkbox"> 40行：fe_len &#x3D; 2 - 1 &#x3D; 1表示当前已经分配到了的block，还剩下8个block需要分配，而且是紧接着的连续的8个。</li>
<li><input disabled="" type="checkbox"> 41行：fe_start  &#x3D; 6 + 1 &#x3D; 7 start被恢复到原始的起始位置。</li>
<li><input disabled="" type="checkbox"> 43行-59行：进入while循环，next &#x3D; ( 3 + 1)  * (1 &lt;&lt; 1) &#x3D; 8表示从8开始搜索，此时计算所得的order &#x3D; 3，表示能分配8个block，循环结束。</li>
</ul>
<p>2）假设0-7和8-9的空间都是空闲的，那么它构建出来的buddy bitmap如下：</p>
<p>![buddy bitmap2](assets&#x2F;buddy bitmap2.jpg)</p>
<ul>
<li><input disabled="" type="checkbox"> 28行：order的值为3</li>
<li><input disabled="" type="checkbox"> 29行：block &#x3D; 7 &gt;&gt; 3 &#x3D; 0</li>
<li><input disabled="" type="checkbox"> 32行：fe_len &#x3D; 1 &lt;&lt; 3 &#x3D; 8</li>
<li><input disabled="" type="checkbox"> 34行：fe_start &#x3D; 0 &lt;&lt; 3 &#x3D; 0</li>
<li><input disabled="" type="checkbox"> 38行：next &#x3D; 7 - 0 &#x3D; 7 此时实际应该只分配到了1个block，但却分配到了8个block，多分配了7个block</li>
<li><input disabled="" type="checkbox"> 40行：fe_len &#x3D; 8 - 7 &#x3D; 1表示当前实际已经分配到了的block，还剩下8个block需要分配，而且是紧接着的连续的8个。</li>
<li><input disabled="" type="checkbox"> 41行：fe_start  &#x3D; 0 + 7 &#x3D; 7 start被恢复到原始的起始位置。</li>
<li><input disabled="" type="checkbox"> 43行-59行：进入while循环，next &#x3D; ( 3 + 1)  * (1 &lt;&lt; 1) &#x3D; 8表示从8开始搜索，此时计算所得的order &#x3D; 3，表示能分配8个block，循环结束。</li>
</ul>
<p>可以把buddy bitmap当成一棵树来看待，28到41行的代码就是要找到起始位置所在的子树能够申请到多少个block，进入while循环后就是在”紧挨着的子树”上从最底层往上寻找能否分配了。</p>
<p>如果从goal分配成功会调用函数ext4_mb_use_best_found()置上最终的结果。</p>
<p>我们回到ext4_mb_regular_allocator()函数，分析一下如果在goal分配失败了会作何策略：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_regular_allocator</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		......</span><br><span class="hljs-comment">		尝试从goal开始分配</span><br><span class="hljs-comment">	*/</span><br><br>	<span class="hljs-comment">// 找到目标长度的二进制的从右往左数最后一个1的位置，len的order</span><br>	i = fls(ac-&gt;ac_g_ex.fe_len);<br>	ac-&gt;ac_2order = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		当请求分配的长度的order大于等于s_mb_order2_reqs时，</span><br><span class="hljs-comment">		s_mb_order2_reqs可以通过/sys/fs/ext4/&lt;partition&gt;/mb_order2_req配置</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (i &gt;= sbi-&gt;s_mb_order2_reqs &amp;&amp; i &lt;= sb-&gt;s_blocksize_bits + <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 申请分配的数量刚好是2的N次方</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> ((ac-&gt;ac_g_ex.fe_len &amp; (~(<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>)))) == <span class="hljs-number">0</span>)<br>			ac-&gt;ac_2order = array_index_nospec(i - <span class="hljs-number">1</span>,<br>							   sb-&gt;s_blocksize_bits + <span class="hljs-number">2</span>);<br>	&#125;<br><br>	<span class="hljs-comment">/* if stream allocation is enabled, use global goal */</span><br>	<span class="hljs-keyword">if</span> (ac-&gt;ac_flags &amp; EXT4_MB_STREAM_ALLOC) &#123;<br>		<span class="hljs-comment">/* TBD: may be hot point */</span><br>		spin_lock(&amp;sbi-&gt;s_md_lock);<br>		<span class="hljs-comment">// 从文件系统上一次分配的地方开始分配</span><br>		ac-&gt;ac_g_ex.fe_group = sbi-&gt;s_mb_last_group;<br>		ac-&gt;ac_g_ex.fe_start = sbi-&gt;s_mb_last_start;<br>		spin_unlock(&amp;sbi-&gt;s_md_lock);<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		cr表示搜索block group的严苛程度，严苛程度从高到低</span><br><span class="hljs-comment">		0是最严苛的程度，详见ext4_mb_good_group()函数</span><br><span class="hljs-comment">	*/</span><br>	cr = ac-&gt;ac_2order ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br><br>repeat:<br>    <span class="hljs-comment">// 每一轮的严苛程度不一样</span><br>	<span class="hljs-keyword">for</span> (; cr &lt; <span class="hljs-number">4</span> &amp;&amp; ac-&gt;ac_status == AC_STATUS_CONTINUE; cr++) &#123;<br>		ac-&gt;ac_criteria = cr;<br>		<span class="hljs-comment">// 从goal的那个block group开始搜索，如果遍历到了最后一个block group则转去第一个block group</span><br>		group = ac-&gt;ac_g_ex.fe_group;<br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ngroups; group++, i++) &#123;<br>			<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>			cond_resched();<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * Artificially restricted ngroups for non-extent</span><br><span class="hljs-comment">			 * files makes group &gt; ngroups possible on first loop.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">if</span> (group &gt;= ngroups) <span class="hljs-comment">// 回到起始的第一个group看能否分配</span><br>				group = <span class="hljs-number">0</span>;<br><br>			<span class="hljs-comment">// 在不加锁的情况下先检查一下能否分配，如果能则加锁去检查</span><br>			ret = ext4_mb_good_group(ac, group, cr);<br>			<span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-keyword">if</span> (!first_err)<br>					first_err = ret;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<span class="hljs-comment">// 加载buddy</span><br>			err = ext4_mb_load_buddy(sb, group, &amp;e4b);<br>			<span class="hljs-keyword">if</span> (err)<br>				<span class="hljs-keyword">goto</span> out;<br><br>			ext4_lock_group(sb, group);<br><br>			<span class="hljs-comment">// 加载了buddy，加了锁之后再check能否分配</span><br>			ret = ext4_mb_good_group(ac, group, cr);<br>			<span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br>				ext4_unlock_group(sb, group);<br>				ext4_mb_unload_buddy(&amp;e4b);<br>				<span class="hljs-keyword">if</span> (!first_err)<br>					first_err = ret;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br><br>			ac-&gt;ac_groups_scanned++;<br>			<span class="hljs-keyword">if</span> (cr == <span class="hljs-number">0</span>)<br>				<span class="hljs-comment">// 申请分配的长度刚好是2的N次方的时候才会走这里</span><br>				ext4_mb_simple_scan_group(ac, &amp;e4b);<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cr == <span class="hljs-number">1</span> &amp;&amp; sbi-&gt;s_stripe &amp;&amp;<br>					!(ac-&gt;ac_g_ex.fe_len % sbi-&gt;s_stripe)) <span class="hljs-comment">// 要分配的长度是stripe的整数倍，这是对raid的优化</span><br>				ext4_mb_scan_aligned(ac, &amp;e4b);<br>			<span class="hljs-keyword">else</span><br>				ext4_mb_complex_scan_group(ac, &amp;e4b);<br><br>			ext4_unlock_group(sb, group);<br>			ext4_mb_unload_buddy(&amp;e4b);<br><br>			<span class="hljs-keyword">if</span> (ac-&gt;ac_status != AC_STATUS_CONTINUE)<br>				<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 最终也还是没有分配成功</span><br>	<span class="hljs-keyword">if</span> (ac-&gt;ac_b_ex.fe_len &gt; <span class="hljs-number">0</span> &amp;&amp; ac-&gt;ac_status != AC_STATUS_FOUND &amp;&amp;<br>	    !(ac-&gt;ac_flags &amp; EXT4_MB_HINT_FIRST)) &#123;<br>		<br>        <span class="hljs-comment">// 有空闲空间就行</span><br>		ext4_mb_try_best_found(ac, &amp;e4b);<br>		<span class="hljs-keyword">if</span> (ac-&gt;ac_status != AC_STATUS_FOUND) &#123;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">				再尝试遍历一次所有的block group有空闲空间就行</span><br><span class="hljs-comment">			 */</span><br>			ac-&gt;ac_b_ex.fe_group = <span class="hljs-number">0</span>;<br>			ac-&gt;ac_b_ex.fe_start = <span class="hljs-number">0</span>;<br>			ac-&gt;ac_b_ex.fe_len = <span class="hljs-number">0</span>;<br>			ac-&gt;ac_status = AC_STATUS_CONTINUE;<br>			ac-&gt;ac_flags |= EXT4_MB_HINT_FIRST;<br>			cr = <span class="hljs-number">3</span>;<br>			<span class="hljs-type">atomic_inc</span>(&amp;sbi-&gt;s_mb_lost_chunks);<br>			<span class="hljs-keyword">goto</span> repeat;<br>		&#125;<br>	&#125;<br>out:<br>	<span class="hljs-keyword">if</span> (!err &amp;&amp; ac-&gt;ac_status != AC_STATUS_FOUND &amp;&amp; first_err)<br>		err = first_err;<br>	<span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_good_group()函数，检查在当前的严苛程度下可否进行分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_good_group</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params">				<span class="hljs-type">ext4_group_t</span> group, <span class="hljs-type">int</span> cr)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-built_in">free</span>, fragments;<br>	<span class="hljs-type">int</span> flex_size = ext4_flex_bg_size(EXT4_SB(ac-&gt;ac_sb));<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span> =</span> ext4_get_group_info(ac-&gt;ac_sb, group);<br><br>	BUG_ON(cr &lt; <span class="hljs-number">0</span> || cr &gt;= <span class="hljs-number">4</span>);<br><br>	<span class="hljs-built_in">free</span> = grp-&gt;bb_free;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">// 没有空闲空间了直接返回</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 如果空闲空间小于要分配的长度时，只在严苛程度为3，即最低时才往下走去检查</span><br>	<span class="hljs-keyword">if</span> (cr &lt;= <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">free</span> &lt; ac-&gt;ac_g_ex.fe_len)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">if</span> (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(grp)))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">// 有必要则初始化block group</span><br>	<span class="hljs-keyword">if</span> (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) &#123;<br>		<span class="hljs-type">int</span> ret = ext4_mb_init_group(ac-&gt;ac_sb, group, GFP_NOFS);<br>		<span class="hljs-keyword">if</span> (ret) <br>			<span class="hljs-keyword">return</span> ret;<br>	&#125;<br><br>	fragments = grp-&gt;bb_fragments;<br>	<span class="hljs-keyword">if</span> (fragments == <span class="hljs-number">0</span>) <span class="hljs-comment">// 没有空闲空间段了，直接返回 </span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">switch</span> (cr) &#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>		BUG_ON(ac-&gt;ac_2order == <span class="hljs-number">0</span>);<br><br>		<span class="hljs-comment">/* Avoid using the first bg of a flexgroup for data files */</span><br>		<span class="hljs-comment">// flex块组的第一个块组一般是给目录和特殊文件用的，当“最严苛的时候”跳过</span><br>		<span class="hljs-keyword">if</span> ((ac-&gt;ac_flags &amp; EXT4_MB_HINT_DATA) &amp;&amp;<br>		    (flex_size &gt;= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) &amp;&amp;<br>		    ((group % flex_size) == <span class="hljs-number">0</span>))<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>		<span class="hljs-keyword">if</span> ((ac-&gt;ac_2order &gt; ac-&gt;ac_sb-&gt;s_blocksize_bits+<span class="hljs-number">1</span>) || <span class="hljs-comment">// 大于13</span><br>		    (<span class="hljs-built_in">free</span> / fragments) &gt;= ac-&gt;ac_g_ex.fe_len) <span class="hljs-comment">// 或者空闲空间的平均长度大于等于申请的长度，可以进行分配</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 如果block group内最大的空闲空间的阶小于要分配的阶则不能分配</span><br>		<span class="hljs-keyword">if</span> (grp-&gt;bb_largest_free_order &lt; ac-&gt;ac_2order)<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>		<span class="hljs-keyword">if</span> ((<span class="hljs-built_in">free</span> / fragments) &gt;= ac-&gt;ac_g_ex.fe_len) <span class="hljs-comment">// 空闲空间的平均长度大于等于申请的长度，可以进行分配</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> &gt;= ac-&gt;ac_g_ex.fe_len) <span class="hljs-comment">// 空闲空间的总长度大于申请的长度时可进行分配</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">// 只要有空闲空间就可以进行分配</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">default</span>:<br>		BUG();<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_simple_scan_group()函数，当申请的长度刚好是2的N次方时才会调用这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_simple_scan_group</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params">					<span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span> =</span> e4b-&gt;bd_info;<br>	<span class="hljs-type">void</span> *buddy;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-type">int</span> k;<br>	<span class="hljs-type">int</span> max;<br><br>	BUG_ON(ac-&gt;ac_2order &lt;= <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">for</span> (i = ac-&gt;ac_2order; i &lt;= sb-&gt;s_blocksize_bits + <span class="hljs-number">1</span>; i++) &#123;<br>		<span class="hljs-keyword">if</span> (grp-&gt;bb_counters[i] == <span class="hljs-number">0</span>)<br>			<span class="hljs-keyword">continue</span>;<br><br>		buddy = mb_find_buddy(e4b, i, &amp;max);<br>		BUG_ON(buddy == <span class="hljs-literal">NULL</span>);<br><br>		k = mb_find_next_zero_bit(buddy, max, <span class="hljs-number">0</span>);<br>		BUG_ON(k &gt;= max);<br><br>		ac-&gt;ac_found++;<br>		<br>		ac-&gt;ac_b_ex.fe_len = <span class="hljs-number">1</span> &lt;&lt; i;<br>		ac-&gt;ac_b_ex.fe_start = k &lt;&lt; i;<br>		ac-&gt;ac_b_ex.fe_group = e4b-&gt;bd_group;<br>		<span class="hljs-comment">// 这里更新的是best，也就是最终的分配地方</span><br>		ext4_mb_use_best_found(ac, e4b);<br><br>		BUG_ON(ac-&gt;ac_b_ex.fe_len != ac-&gt;ac_g_ex.fe_len);<br><br>		<span class="hljs-keyword">if</span> (EXT4_SB(sb)-&gt;s_mb_stats)<br>			<span class="hljs-type">atomic_inc</span>(&amp;EXT4_SB(sb)-&gt;s_bal_2orders);<br><br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_scan_aligned()函数，这是ext4文件系统对raid的优化，针对分配的长度是stripe的整数倍的场景：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_scan_aligned</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params">				 <span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br>	<span class="hljs-type">void</span> *bitmap = e4b-&gt;bd_bitmap;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ex</span>;</span><br>	<span class="hljs-type">ext4_fsblk_t</span> first_group_block;<br>	<span class="hljs-type">ext4_fsblk_t</span> a;<br>	<span class="hljs-type">ext4_grpblk_t</span> i;<br>	<span class="hljs-type">int</span> max;<br><br>	BUG_ON(sbi-&gt;s_stripe == <span class="hljs-number">0</span>);<br><br>	<span class="hljs-comment">/* find first stripe-aligned block in group */</span><br>	first_group_block = ext4_group_first_block_no(sb, e4b-&gt;bd_group);<br><br>	a = first_group_block + sbi-&gt;s_stripe - <span class="hljs-number">1</span>;<br>	do_div(a, sbi-&gt;s_stripe); <span class="hljs-comment">// 计算后a表示起始块在第几个stripe</span><br>	i = (a * sbi-&gt;s_stripe) - first_group_block; <span class="hljs-comment">// 计算后的i为在block group内第一个与stripe对齐的块在block group内的编号</span><br>	<br>    <span class="hljs-comment">// 在一个cluster的范围内开始寻找</span><br>	<span class="hljs-keyword">while</span> (i &lt; EXT4_CLUSTERS_PER_GROUP(sb)) &#123;<br>        <span class="hljs-comment">// block group的block bitmap是从0开始编号的，结合上面对i的注释理解</span><br>		<span class="hljs-keyword">if</span> (!mb_test_bit(i, bitmap)) &#123;<br>            <span class="hljs-comment">// 查看从这里起始能否找到一个stripe长度的空闲空间</span><br>			max = mb_find_extent(e4b, i, sbi-&gt;s_stripe, &amp;ex);<br>			<span class="hljs-keyword">if</span> (max &gt;= sbi-&gt;s_stripe) &#123; <span class="hljs-comment">// 找到则置上best</span><br>				ac-&gt;ac_found++;<br>				ex.fe_logical = <span class="hljs-number">0xDEADF00D</span>; <span class="hljs-comment">/* debug value */</span><br>				ac-&gt;ac_b_ex = ex;<br>				ext4_mb_use_best_found(ac, e4b);<br>				<span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 虽然调用者要求的是申请stripe的整数倍长度的空间，但是这里一次也只分配一个stripe长度的空间</span><br>			&#125;<br>		&#125;<br>		i += sbi-&gt;s_stripe; <span class="hljs-comment">// i指向下一个与stripe对齐的块</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_complex_scan_group()函数， 遍历block group内的所有空闲空间段，然后找出最合适的空闲空间段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_complex_scan_group</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params">					<span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br>	<span class="hljs-type">void</span> *bitmap = e4b-&gt;bd_bitmap;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ex</span>;</span><br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br><br>	<span class="hljs-built_in">free</span> = e4b-&gt;bd_info-&gt;bb_free;<br>	BUG_ON(<span class="hljs-built_in">free</span> &lt;= <span class="hljs-number">0</span>);<br>	<span class="hljs-comment">// 从第一个空闲的block开始搜索</span><br>	i = e4b-&gt;bd_info-&gt;bb_first_free;<br>	<span class="hljs-comment">// 遍历搜索最佳的空闲空间，在ext4_mb_measure_extent()函数确定是否为最佳</span><br>	<span class="hljs-keyword">while</span> (<span class="hljs-built_in">free</span> &amp;&amp; ac-&gt;ac_status == AC_STATUS_CONTINUE) &#123;<br>        <span class="hljs-comment">// 每一轮循环开始就找到下一段空闲空间的起始位置，第一轮的时候就是其本身，即第一个空闲空间的起始位置</span><br>		i = mb_find_next_zero_bit(bitmap,<br>						EXT4_CLUSTERS_PER_GROUP(sb), i);<br>		<span class="hljs-keyword">if</span> (i &gt;= EXT4_CLUSTERS_PER_GROUP(sb)) &#123;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * IF we have corrupt bitmap, we won&#x27;t find any</span><br><span class="hljs-comment">			 * free blocks even though group info says we</span><br><span class="hljs-comment">			 * we have free blocks</span><br><span class="hljs-comment">			 */</span><br>			ext4_grp_locked_error(sb, e4b-&gt;bd_group, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>					<span class="hljs-string">&quot;%d free clusters as per &quot;</span><br>					<span class="hljs-string">&quot;group info. But bitmap says 0&quot;</span>,<br>					<span class="hljs-built_in">free</span>);<br>			ext4_mark_group_bitmap_corrupted(sb, e4b-&gt;bd_group,<br>					EXT4_GROUP_INFO_BBITMAP_CORRUPT);<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		<span class="hljs-comment">// 返回的ex的fe_len表示的是此次寻找能分配的最大的长度</span><br>		mb_find_extent(e4b, i, ac-&gt;ac_g_ex.fe_len, &amp;ex);<br>		BUG_ON(ex.fe_len &lt;= <span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> &lt; ex.fe_len) &#123;<br>			ext4_grp_locked_error(sb, e4b-&gt;bd_group, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>					<span class="hljs-string">&quot;%d free clusters as per &quot;</span><br>					<span class="hljs-string">&quot;group info. But got %d blocks&quot;</span>,<br>					<span class="hljs-built_in">free</span>, ex.fe_len);<br>			ext4_mark_group_bitmap_corrupted(sb, e4b-&gt;bd_group,<br>					EXT4_GROUP_INFO_BBITMAP_CORRUPT);<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * The number of free blocks differs. This mostly</span><br><span class="hljs-comment">			 * indicate that the bitmap is corrupt. So exit</span><br><span class="hljs-comment">			 * without claiming the space.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		ex.fe_logical = <span class="hljs-number">0xDEADC0DE</span>; <span class="hljs-comment">/* debug value */</span><br>        <span class="hljs-comment">// 检查是否合适</span><br>		ext4_mb_measure_extent(ac, &amp;ex, e4b);<br>		<span class="hljs-comment">// 进入到下一轮寻找</span><br>		i += ex.fe_len;<br>		<span class="hljs-built_in">free</span> -= ex.fe_len;<br>	&#125;<br><br>	ext4_mb_check_limits(ac, e4b, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_measure_extent()函数，负责判断当前的空闲空间段是否就是分配的最佳的段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_measure_extent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params">					<span class="hljs-keyword">struct</span> ext4_free_extent *ex,</span><br><span class="hljs-params">					<span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> *<span class="hljs-title">bex</span> =</span> &amp;ac-&gt;ac_b_ex;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> *<span class="hljs-title">gex</span> =</span> &amp;ac-&gt;ac_g_ex;<br><br>	BUG_ON(ex-&gt;fe_len &lt;= <span class="hljs-number">0</span>);<br>	BUG_ON(ex-&gt;fe_len &gt; EXT4_CLUSTERS_PER_GROUP(ac-&gt;ac_sb));<br>	BUG_ON(ex-&gt;fe_start &gt;= EXT4_CLUSTERS_PER_GROUP(ac-&gt;ac_sb));<br>	BUG_ON(ac-&gt;ac_status != AC_STATUS_CONTINUE);<br><br>	ac-&gt;ac_found++;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 如果调用者要求直接就是找到的第一个段那么就直接分配</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (unlikely(ac-&gt;ac_flags &amp; EXT4_MB_HINT_FIRST)) &#123;<br>		*bex = *ex;<br>		ext4_mb_use_best_found(ac, e4b); <span class="hljs-comment">// 这里面会把ext4_allocation_context的状态置为FOUND，外面调用的循环自然就停止了。</span><br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 检查是否最佳：</span><br><span class="hljs-comment">	 */</span><br>    <span class="hljs-comment">// 如果空闲空间长度刚好跟要求分配的长度一致那么这个就是最佳的</span><br>	<span class="hljs-keyword">if</span> (ex-&gt;fe_len == gex-&gt;fe_len) &#123;<br>		*bex = *ex;<br>		ext4_mb_use_best_found(ac, e4b);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 第一个段进来还没有可比较的，就先保存着</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (bex-&gt;fe_len == <span class="hljs-number">0</span>) &#123;<br>		*bex = *ex;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * If new found extent is better, store it in the context</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (bex-&gt;fe_len &lt; gex-&gt;fe_len) &#123;<br>		<span class="hljs-comment">// 如果前面找到的段的长度小于要求分配的长度，而且当前找到的段的可分配长度比前面找到的要长，那么自然就是比前面的段要更合适一些</span><br>		<span class="hljs-keyword">if</span> (ex-&gt;fe_len &gt; bex-&gt;fe_len)<br>			*bex = *ex;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex-&gt;fe_len &gt; gex-&gt;fe_len) &#123;<br>		<span class="hljs-comment">// 如果当前找到的段的可分配长度已经大于了要求分配的长度，那么就找到分配后剩余的长度最短的段</span><br>		<span class="hljs-keyword">if</span> (ex-&gt;fe_len &lt; bex-&gt;fe_len)<br>			*bex = *ex;<br>	&#125;<br><br>	ext4_mb_check_limits(ac, e4b, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ext4_mb_try_best_found()函数，遍历了很久但还是没有找到最佳的分配地点，需要做最后的尝试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_try_best_found</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params">					<span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ex</span> =</span> ac-&gt;ac_b_ex;<br>	<span class="hljs-type">ext4_group_t</span> group = ex.fe_group;<br>	<span class="hljs-type">int</span> max;<br>	<span class="hljs-type">int</span> err;<br><br>    <span class="hljs-comment">// ac_b_ex可能是在ext4_mb_complex_scan_group()的时候置上的，但没有成为最终的分配地点</span><br>	BUG_ON(ex.fe_len &lt;= <span class="hljs-number">0</span>);<br>	err = ext4_mb_load_buddy(ac-&gt;ac_sb, group, e4b);<br>	<span class="hljs-keyword">if</span> (err)<br>		<span class="hljs-keyword">return</span> err;<br>	<span class="hljs-comment">// 尝试从这个前面可能找到的ext4_free_extent进行分配</span><br>	ext4_lock_group(ac-&gt;ac_sb, group);<br>	max = mb_find_extent(e4b, ex.fe_start, ex.fe_len, &amp;ex);<br><br>	<span class="hljs-keyword">if</span> (max &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 都此时此刻了，有空闲空间就行，能分配多少分配多少了</span><br>		ac-&gt;ac_b_ex = ex;<br>		ext4_mb_use_best_found(ac, e4b);<br>	&#125;<br><br>	ext4_unlock_group(ac-&gt;ac_sb, group);<br>	ext4_mb_unload_buddy(e4b);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在ext4_mb_regular_allocator()函数的最后，当所有的手段都不能分配到空闲空间，那么会做最后的一搏，将严苛程度置为3，然后回到repeat再一次遍历所有的block group看能否分配。</p>
<h2 id="持久预分配-1"><a href="#持久预分配-1" class="headerlink" title="持久预分配"></a>持久预分配</h2><p>linux提供了一个非posix标准的接口fallocate()以实现持久预分配，同时还提供了一个posix标准的接口posix_fallocate()，此接口不需要下层文件系统支持持久预分配，而前面的fallocate()需要。</p>
<p>fallocate()从vfs最终会调到ext4文件系统注册的ext4_fallocate()接口，fallocate()提供持久预分配的同时还会提供打洞、清零等操作，这个可以单独开一期分析，但对于持久预分配来说就是调用ext4_map_blocks()函数去分配传入的逻辑空间。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://oenhan.com/ext4-mballoc">https://oenhan.com/ext4-mballoc</a></p>
<p><a target="_blank" rel="noopener" href="https://younger.blog.csdn.net/article/details/22759619">https://younger.blog.csdn.net/article/details/22759619</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tobbeone/article/details/80852816">https://blog.csdn.net/tobbeone/article/details/80852816</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2023/04/29/ext4/ext4  块分配机制及源码分析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Cahir</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/29/nvme/NVMe%E9%A9%B1%E5%8A%A8%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/04/29/block/kyber/" title="">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
