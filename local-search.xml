<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/04/29/nvme/NVMe%E9%A9%B1%E5%8A%A8%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/29/nvme/NVMe%E9%A9%B1%E5%8A%A8%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="NVMe驱动队列的原理与源码分析"><a href="#NVMe驱动队列的原理与源码分析" class="headerlink" title="NVMe驱动队列的原理与源码分析"></a>NVMe驱动队列的原理与源码分析</h1><p>我们将基于linux 4.20的NVMe over PCIe驱动代码来分析NVMe驱动如何操作队列，块驱动在处理上层块层发送下来的IO时涉及到命令的申请与转换、存储命令的队列、怎样将命令交给盘、怎样接收盘处理的命令结果等一系列问题。</p><h2 id="NVMe创建队列"><a href="#NVMe创建队列" class="headerlink" title="NVMe创建队列"></a>NVMe创建队列</h2><p>NVMe创建队列时需要考虑两个重要的参数，一是创建多少个，二是每个队列的深度。NVMe的一个队列是由一个或者多个Submission Queue(SQ)和一个Completion Queue(CQ)组成的，因此也可以叫做队列对(queue pair)，为了方便后续还是叫其队列。</p><p>NVMe驱动首先会创建一个Admin Queue用于下发管理类的命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_pci_configure_admin_queue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev)</span><br>&#123;<br><span class="hljs-type">int</span> result;<br>u32 aqa;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_queue</span> *<span class="hljs-title">nvmeq</span>;</span><br><span class="hljs-comment">/* ...... */</span><br><span class="hljs-comment">// Admin queue的队列深度固定为32，queue id固定为0</span><br>result = nvme_alloc_queue(dev, <span class="hljs-number">0</span>, NVME_AQ_DEPTH);<br><span class="hljs-keyword">if</span> (result)<br><span class="hljs-keyword">return</span> result;<br><br>nvmeq = &amp;dev-&gt;queues[<span class="hljs-number">0</span>];<br><span class="hljs-comment">/* ...... */</span><br><br>nvmeq-&gt;cq_vector = <span class="hljs-number">0</span>;<br>nvme_init_queue(nvmeq, <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化Admin queue</span><br>result = queue_request_irq(nvmeq); <span class="hljs-comment">// 注册中断处理函数</span><br><span class="hljs-keyword">if</span> (result) &#123;<br>nvmeq-&gt;cq_vector = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后创建用于下发IO命令的IO queue：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">nvme_reset_work</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> work_struct *work)</span><br>&#123;<br>    <span class="hljs-comment">/* ...... */</span><br>result = nvme_setup_io_queues(dev); <span class="hljs-comment">//创建nvme的IO队列（本地和盘都要创建）</span><br><span class="hljs-keyword">if</span> (result)<br><span class="hljs-keyword">goto</span> out;<br>    <span class="hljs-comment">/* ...... */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>nvme_setup_io_queues()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_setup_io_queues</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_queue</span> *<span class="hljs-title">adminq</span> =</span> &amp;dev-&gt;queues[<span class="hljs-number">0</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dev</span> *<span class="hljs-title">pdev</span> =</span> to_pci_dev(dev-&gt;dev);<br><span class="hljs-type">int</span> result, nr_io_queues;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_affinity</span> <span class="hljs-title">affd</span> =</span> &#123;<br>.pre_vectors = <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-comment">// 首先获取当前系统的CPU个数</span><br>nr_io_queues = num_possible_cpus();<br>result = nvme_set_queue_count(&amp;dev-&gt;ctrl, &amp;nr_io_queues);<br><span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> result;<br>    <span class="hljs-comment">/* ...... */</span><br>    dev-&gt;max_qid = max(result - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// </span><br>    <span class="hljs-comment">/* ...... */</span><br>    <span class="hljs-keyword">return</span> nvme_create_io_queues(dev); <span class="hljs-comment">// 循环遍历一个一个地创建队列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>nvme_set_queue_count()函数决定要创建的IO queue的队列个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">nvme_set_queue_count</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl, <span class="hljs-type">int</span> *count)</span><br>&#123;<br>    <span class="hljs-comment">// 根据协议q_count的高16位是CQ的个数，低16位是SQ的个数</span><br>u32 q_count = (*count - <span class="hljs-number">1</span>) | ((*count - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">16</span>);<br>u32 result;<br><span class="hljs-type">int</span> status, nr_io_queues;<br><span class="hljs-comment">// 发送set feature命令设置queue的数量并且返回controller(这里可以直接理解为盘)支持的最大的队列数result。</span><br>status = nvme_set_features(ctrl, NVME_FEAT_NUM_QUEUES, q_count, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>,<br>&amp;result);<br><span class="hljs-keyword">if</span> (status &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> status;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Degraded controllers might return an error when setting the queue</span><br><span class="hljs-comment"> * count.  We still want to be able to bring them online and offer</span><br><span class="hljs-comment"> * access to the admin queue, as that might be only way to fix them up.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (status &gt; <span class="hljs-number">0</span>) &#123;<br>dev_err(ctrl-&gt;device, <span class="hljs-string">&quot;Could not set queue count (%d)\n&quot;</span>, status);<br>*count = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 大概率返回的SQ和CQ个数是一样的，但也有可能不一样，因此这里取一下最小值</span><br>nr_io_queues = min(result &amp; <span class="hljs-number">0xffff</span>, result &gt;&gt; <span class="hljs-number">16</span>) + <span class="hljs-number">1</span>;<br>*count = min(*count, nr_io_queues); <span class="hljs-comment">// 找到cpu个数与盘能够支持的队列数量的最小值</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>nvme_set_queue_count()函数的第23行为什么要将结果加1？</p><p>查看协议可知result的高16位和低16位都是一个“0&#96;s based value”，也就是说如果要表达支持n个队列，那么返回的值位n-1（NVMe协议里经常这样定义），因此最后nr_io_queues要加1才是最终的结果。</p><p><img src="/assets/image-20211002144735841.png" alt="image-20211002144735841"></p><p>队列深度的确定：</p><p>在nvme_pci_enable()函数初始化队列深度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_pci_enable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev)</span><br>&#123;<br>    <span class="hljs-comment">/* ...... */</span><br>    <span class="hljs-comment">// cap寄存器里面存的是controller最基本的能力信息</span><br>    dev-&gt;ctrl.cap = lo_hi_readq(dev-&gt;bar + NVME_REG_CAP);<br>    <span class="hljs-comment">// 查看协议可知cap的低16位表示的是支持的最大的队列的entry数，这也是个“0`s based value”，因此这里需要加1</span><br>    <span class="hljs-comment">// 这里取了和1024比较的最小值</span><br>dev-&gt;q_depth = <span class="hljs-type">min_t</span>(<span class="hljs-type">int</span>, NVME_CAP_MQES(dev-&gt;ctrl.cap) + <span class="hljs-number">1</span>,<br>io_queue_depth);    <br>    <span class="hljs-comment">/* ...... */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/assets/image-20211002150509788.png" alt="image-20211002150509788"></p><p>在调用nvme_alloc_queue()函数创建队列时会用到两个宏表明了SQ和CQ的总大小，可以看出SQ存放的是nvme的命令，而CQ存放的是controller的处理结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQ_SIZE(depth)(depth * sizeof(struct nvme_command))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CQ_SIZE(depth)(depth * sizeof(struct nvme_completion))</span><br></code></pre></td></tr></table></figure><p>nvme_alloc_queue()函数同时还会下发创建队列命令到controller上，让controller也创建好接收用的队列，本文主要是讲NVMe驱动测，target测就不展开了。</p><h2 id="往SQ队列里添加命令"><a href="#往SQ队列里添加命令" class="headerlink" title="往SQ队列里添加命令"></a>往SQ队列里添加命令</h2><p>NVMe驱动在初始化的时候会注册给块层一个hook集，里面包含了与块层交互的接口，其中的nvme_queue_rq()就是块层将命令下发到驱动层的接口(其他BUS注册的接口不一样)。</p><p>在将块层传入的request转换成nvme_command后，需要调用nvme_submit_cmd()函数将nvme_command加入队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">nvme_submit_cmd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_queue *nvmeq, <span class="hljs-keyword">struct</span> nvme_command *cmd)</span><br>&#123;<br>spin_lock(&amp;nvmeq-&gt;sq_lock);<br><br><span class="hljs-built_in">memcpy</span>(&amp;nvmeq-&gt;sq_cmds[nvmeq-&gt;sq_tail], cmd, <span class="hljs-keyword">sizeof</span>(*cmd));<br><br><span class="hljs-keyword">if</span> (++nvmeq-&gt;sq_tail == nvmeq-&gt;q_depth)<br>nvmeq-&gt;sq_tail = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (nvme_dbbuf_update_and_check_event(nvmeq-&gt;sq_tail,<br>nvmeq-&gt;dbbuf_sq_db, nvmeq-&gt;dbbuf_sq_ei))<br>writel(nvmeq-&gt;sq_tail, nvmeq-&gt;q_db);<br>spin_unlock(&amp;nvmeq-&gt;sq_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>第5行：将nvme_command复制到sq_tail指向的队列的尾巴，注意此时是直接拷贝的，并没有判断当前的SQ是否已经满了，为什么？</p><p>因为在块层的硬件队列的队列深度是由NVMe的SQ的队列深度决定的，其最终结果小于SQ的队列深度，具体见blk_mq_alloc_rq_maps()函数，当__blk_mq_alloc_rq_maps()函数分配失败时会将队列深度减半，而队列深度的初始值是NVMe队列的深度减去1。块层在初始化的时候就申请好硬件队列深度个request，然后用一个bitmap来管理，在块层没法合并接收到的bio的时候会通过bitmap申请一个request，如果申请不到则将当前流程挂起等待，直到申请到为止，详见blk_mq_get_tag()函数。</p><p>综上，SQ队列是永远无法注满的，因此也就不需要判断队列是否满了。</p><p>第9，10，11行：在条件满足的时候将tail值写入到队列对应的doorbell寄存器里面通知controller有新的命令到来了请处理。至于这个条件需要一定的PCIe知识，这里先跳过。</p><p>NVMe在将tail写入到nvme_queue对应的doorbell后，controller自己维护着head的值，这样controller就知道要取哪些command了，取完之后将head++。</p><h2 id="处理CQ完成的命令"><a href="#处理CQ完成的命令" class="headerlink" title="处理CQ完成的命令"></a>处理CQ完成的命令</h2><p>controller处理完命令后，生成nvme_completion结构并填入处理结果，然后将nvme_completion存入CQ中。</p><p>之后controller有两种方式能够让host感知到有命令完成：</p><p>一、通过中断</p><p>在初始化阶段，NVMe驱动在创建队列时</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/04/29/ext4/ext4%20%20%E5%9D%97%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/29/ext4/ext4%20%20%E5%9D%97%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="ext4块分配机制及源码分析"><a href="#ext4块分配机制及源码分析" class="headerlink" title="ext4块分配机制及源码分析"></a>ext4块分配机制及源码分析</h1><p>对于文件系统来说，碎片问题是永恒的话题，碎片少的文件系统不仅能够存储更多的数据而且能够带来显著的性能提升，为此ext4文件系统从inode分配到块分配都做了相当多的努力。本文主要是结合源码分析ext4文件系统的块分配机制，所采用的源码版本是4.20。</p><p>ext4文件系统采用多种分配方式相结合的方式解决碎片问题，此外还需要考虑到分配效率、大文件小文件、超大文件、分配后的读写效率等问题，其机制不可谓不复杂，限于当前的水平难免有叙述错误和未叙述到的地方，欢迎一起交流。</p><h2 id="块分配机制"><a href="#块分配机制" class="headerlink" title="块分配机制"></a>块分配机制</h2><h3 id="预分配"><a href="#预分配" class="headerlink" title="预分配"></a>预分配</h3><p>给文件预留空间，当需要分配的时候从预留的空间里面分配能够降低碎片数量。ext4文件系统考虑到大文件和小文件的不同需求，对于大文件，ext4采用per inode的方式给每个文件预留分配空间；对于小文件，ext4的策略是尽量让这些文件都集中存储在一起，采用的方式per_cpu locality group的方式。至于什么是per_inode，什么是per_cpu locality group就留到具体的章节详说吧。</p><h3 id="mballoc多块分配"><a href="#mballoc多块分配" class="headerlink" title="mballoc多块分配"></a>mballoc多块分配</h3><p>相比于ext2文件系统的块分配器一次性只能分配一个数据块，效率低下；ext4采用了多块分配机制，一次性能够分配多块的空间，效率非常高的同时碎片也会相当的少。ext4的开发人员参考了linux内核内存管理的buddy算法来实现多块分配，如果读者熟悉内存管理的buddy算法的话，理解起来会快很多。</p><h3 id="延迟分配"><a href="#延迟分配" class="headerlink" title="延迟分配"></a>延迟分配</h3><p>缓存IO的写命令会先将数据写入页缓存中，然后立即返回，待到某个特定的时候再将缓存中的数据回写到磁盘上。ext4利用此机制，在数据写到页缓存中的时候不做磁盘空间的分配，当写IO持续累积在统一回写到磁盘上的时候再统一地进行分配磁盘空间，一次性大的磁盘空间分配所产生的碎片肯定比多次小IO产生的碎片少，再结合mballoc多块分配一次性分配多块物理磁盘空间能够继续减少碎片。</p><p>但是延迟分配有一个缺点，那就是在回写时会进行磁盘空间的分配，这会一定程度上影响刷盘的效率，而且会导致部分IO的延时会突然拔高一段时间，对于追求延时稳定的上层应用来说会有影响，例如数据库系统的某一次SQL执行时间突然变长等。</p><h3 id="bigAlloc"><a href="#bigAlloc" class="headerlink" title="bigAlloc"></a>bigAlloc</h3><p>在ext4的块组中有一个块叫做block bitmap数据块位图，用于记录块组中的块使用情况，一个ext4块一般情况下是4k，也就是32768个bit位，一个bit位代表一个4k块的使用情况，32768个bit位就能表示128M的空间的使用情况，这也是一般情况下ext4的一个块组是128M的原因。</p><p>但是随着单个磁盘空间的越来越大(TB级)，如果ext4文件系统任然采用4k为一个文件块的方式来管理数据，那么相对应的位图等元数据也会增多，这方面的管理开销也会越来越大。</p><p>暴力地增大单个块的大小是个看起来简单的方法，但是由于块大小跟内核的内存管理、页缓存块缓存管理极为紧密，简单地增加文件块大小对于代码开发的工作量将是巨大的。聪明的内核开发者引入了bigalloc的策略，随之而来的是一个叫<strong>“block cluster”</strong>的概念，它是一系列4k的块的集合，当需要分配空间时以block cluster为单位进行分配而不是以4k 块为单位进行分配，与此同时，块组里面数据块位图的一个bit位也不在表示一个4k块，而是一个block cluster，当然我们的块组的大小也随之增大了(block cluster的大小在文件系统格式化的时候就决定了，因此块组的大小也就决定了)。</p><p><strong>关于bigalloc特性，内核有一个“历史包袱”，那就是当初开发者在修改代码时并没有将内核代码的所有“blocks”都换成“cluster”，估计是为了尽快上线功能吧，因此后续我们在分析代码的时候一会儿代码是block，一会儿代码是cluster，这会让人很迷惑，需要记住的一点是看到block，其实它是cluster。</strong></p><p>block cluster的大小一般设置为64k，如果文件系统只存储大文件，那么可以将block cluster设置为1M。假如一次性给文件分配了1M的空间，而文件并没有用完这片空间，那么下次在文件要分配的时候会将这部分未用完的空间也利用上就不分配了。值得注意的是，如果设置了过大的block cluster，而文件系统又存储了很多的小文件，那么会浪费很多的空间。</p><h3 id="持久预分配"><a href="#持久预分配" class="headerlink" title="持久预分配"></a>持久预分配</h3><p>有的上层应用需要在文件开始写入数据之前就准备好足够的空间，例如下载软件会先创建同等大小的文件然后将下载的数据写入到文件等，ext4文件系统提供了持久预分配接口，能够一次性就给文件分配好所有的空间，效率更高，碎片更少。</p><h3 id="其他策略"><a href="#其他策略" class="headerlink" title="其他策略"></a>其他策略</h3><p>除了上述的几大分配策略以外，ext4还有很多的小策略以及分配inode的策略也会影响文件系统的性能：</p><p>1）在文件刚刚创建的时候ext4文件系统会为其分配8k的空间，然后在文件close的时候回收未用完的空间，以应对创建文件立马写入的场景以及临时小文件场景。</p><p>2）尽量将文件数据和文件的inode放在同一个块组中，以减少磁盘寻址耗时(机械硬盘)。</p><p>3） 如果启用了flexible块组特性，当4个以上的块组组成一个flexible块组的时候，将flexible块组内的第一个块组的inode分配给目录而不是普通文件。</p><p>4）ext4尽量将文件inode与它的目录inode放在同一个块组中，普遍认为目录下的文件是“相关的”，读取某一个文件也会同时读取其他文件。</p><p>5）ext4文件系统在分配inode的时候会将顶层的目录尽量分散开，而底层的目录尽量聚集在一起。</p><p>6）针对下层块设备是Raid的场景ext4采用与stripe对齐的方式分配，可以加速读写。你可以在创建文件系统时通过设置参数”-E stride&#x3D;?, stripe&#x3D;?”指定按照stripe对齐得方式分配，stride就是raid的chunk size 除以文件系统的block大小的倍数，stripe就是stride * raid的数据盘个数。对于raid5或者raid6这种来说满条带的写能够提升非常大的性能，因为raid引擎不用多次读取计算和写入校验值。至于你的raid的chunk size应该配置多大就得根据上层业务经常下发的IO大小决定，如果IO太大可以指定较小的chunk size使得数据能够分到各个磁盘上，如果经常下发的IO太小可以指定较大一点的chunk size，最好有benchmark可以测试这些参数带来的影响，选择最合适的参数。</p><p>7）ext4最终还可以用e4defrag工具整理碎片文件。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>代码流程主要是梳理预分配和多块分配的公共流程和数据结构，而bigalloc、延迟分配以及各种小策略会穿插在其中，持久预分配单独分析。</p><p>我们的流程从ext4_ext_map_blocks()函数开始，这个函数的作用是将一段连续的逻辑块号映射到连续的物理块号，在开始梳理流程之前我们需要了解一个结构体：ext4_map_blocks。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">文件系统将磁盘空间划分为4k的块(通常是4k)，每一个4k的块有一个物理块号，物理块号从0开始，由于当前存放文件系统的磁盘空间可能是个分区，因此在通用块层根据下发的物理块号计算真正在磁盘上的sector(通常是512B)时要加上分区的sector偏移。</span><br><span class="hljs-comment">逻辑块号是相对于文件而言的，对于上层应用来说文件的内容是连续的，而实际的存储物理块号可能不连续，这个4k的块相对于文件起始位置的块号就是逻辑块号。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">ext4_map_blocks用来描述逻辑块号和物理块号的映射关系</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_map_blocks</span> &#123;</span><br><span class="hljs-type">ext4_fsblk_t</span> m_pblk; <span class="hljs-comment">// 物理块号，相对于文件系统而言的</span><br><span class="hljs-type">ext4_lblk_t</span> m_lblk; <span class="hljs-comment">// 逻辑块号，相对于文件的</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m_len; <span class="hljs-comment">// 长度，单位为文件块</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m_flags; <span class="hljs-comment">// 映射关系的各种标记，参考EXT4_MAP_NEW附近的宏定义</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>ext4_ext_map_blocks()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 我们首先来看参数：</span><br><span class="hljs-comment">handle_t *handle: 是ext4文件系统的日志系统，此处用于保护分配时的元数据的修改</span><br><span class="hljs-comment">struct inode *inode: 要分配的文件的inode</span><br><span class="hljs-comment">struct ext4_map_blocks *map: 映射关系，找到了逻辑块号的物理块号就填入其中</span><br><span class="hljs-comment">int flags: 调用方对于此次分配行动的“要求”，参考EXT4_GET_BLOCKS_CREATE附件的宏定义</span><br><span class="hljs-comment">其次是返回值：</span><br><span class="hljs-comment">返回此次映射的长度，这个值可能会小于调用方要求的长度(ext4_map_blocks里的m_len)，调用方需要处理这种情况</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ext4_ext_map_blocks</span><span class="hljs-params">(<span class="hljs-type">handle_t</span> *handle, <span class="hljs-keyword">struct</span> inode *inode,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_map_blocks *<span class="hljs-built_in">map</span>, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_ext_path</span> *<span class="hljs-title">path</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_extent</span> <span class="hljs-title">newex</span>, *<span class="hljs-title">ex</span>, *<span class="hljs-title">ex2</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(inode-&gt;i_sb);<br><span class="hljs-type">ext4_fsblk_t</span> newblock = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> free_on_err = <span class="hljs-number">0</span>, err = <span class="hljs-number">0</span>, depth, ret;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> allocated = <span class="hljs-number">0</span>, offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> allocated_clusters = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_allocation_request</span> <span class="hljs-title">ar</span>;</span><br><span class="hljs-type">ext4_lblk_t</span> cluster_offset;<br><span class="hljs-type">bool</span> map_from_cluster = <span class="hljs-literal">false</span>;<br><br>ext_debug(<span class="hljs-string">&quot;blocks %u/%u requested for inode %lu\n&quot;</span>,<br>  <span class="hljs-built_in">map</span>-&gt;m_lblk, <span class="hljs-built_in">map</span>-&gt;m_len, inode-&gt;i_ino);<br>trace_ext4_ext_map_blocks_enter(inode, <span class="hljs-built_in">map</span>-&gt;m_lblk, <span class="hljs-built_in">map</span>-&gt;m_len, flags);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ext4_ext_map_blocks()函数实在太长了，我们将其分为两个部分分析，此处为第一部分，主要是从ext4的extent树中采用二分法的方式寻找有无已经映射了的extent，查找期间如果某个extent树节点没有加载到页缓存中，则会发起读IO从磁盘读取并加载到页缓存中，并且加载的extent(包括空洞)会记录到ext4_inode_info的struct ext4_es_tree i_es_tree红黑树中方便查询。</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    此处涉及到很多的ext4文件系统extent树的知识，这里的分析从简。</span><br><span class="hljs-comment">    */</span><br>    <br><span class="hljs-comment">/* find extent for this block */</span><br>    <span class="hljs-comment">// path表示的是从extent树的根节点到extent所经过的所有extent_idx路径</span><br>path = ext4_find_extent(inode, <span class="hljs-built_in">map</span>-&gt;m_lblk, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (IS_ERR(path)) &#123;<br>err = PTR_ERR(path);<br>path = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">goto</span> out2;<br>&#125;<br><br>depth = ext_depth(inode);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * consistent leaf must not be empty;</span><br><span class="hljs-comment"> * this situation is possible, though, _during_ tree modification;</span><br><span class="hljs-comment"> * this is why assert can&#x27;t be put in ext4_find_extent()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(path[depth].p_ext == <span class="hljs-literal">NULL</span> &amp;&amp; depth != <span class="hljs-number">0</span>)) &#123;<br>EXT4_ERROR_INODE(inode, <span class="hljs-string">&quot;bad extent address &quot;</span><br> <span class="hljs-string">&quot;lblock: %lu, depth: %d pblock %lld&quot;</span>,<br> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) <span class="hljs-built_in">map</span>-&gt;m_lblk, depth,<br> path[depth].p_block);<br>err = -EFSCORRUPTED;<br><span class="hljs-keyword">goto</span> out2;<br>&#125;<br><br>ex = path[depth].p_ext;<br><span class="hljs-keyword">if</span> (ex) &#123; <span class="hljs-comment">// 如果找到了extent，证明已经映射了</span><br><span class="hljs-type">ext4_lblk_t</span> ee_block = le32_to_cpu(ex-&gt;ee_block); <span class="hljs-comment">// 起始逻辑块</span><br><span class="hljs-type">ext4_fsblk_t</span> ee_start = ext4_ext_pblock(ex); <span class="hljs-comment">// 起始物理块</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ee_len;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * unwritten extents are treated as holes, except that</span><br><span class="hljs-comment"> * we split out initialized portions during a write.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 如果一个extent是初始化了的则ee_len &lt;= 32768，</span><br><span class="hljs-comment">// 如果一个extent是没有初始化的则ee_len &gt; 32768，且真实长度为ee_len - 32768</span><br><span class="hljs-comment">// 因此初始化了的最大长度为32768，未初始化的最大长度为INVALID_U16（65535）- 32768 = 32767</span><br>ee_len = ext4_ext_get_actual_len(ex);<br><br>trace_ext4_ext_show_extent(inode, ee_block, ee_start, ee_len);<br><br><span class="hljs-comment">/* if found extent covers block, simply return it */</span><br><span class="hljs-keyword">if</span> (in_range(<span class="hljs-built_in">map</span>-&gt;m_lblk, ee_block, ee_len)) &#123;<br>newblock = <span class="hljs-built_in">map</span>-&gt;m_lblk - ee_block + ee_start;<br><span class="hljs-comment">/* number of remaining blocks in the extent */</span><br>allocated = ee_len - (<span class="hljs-built_in">map</span>-&gt;m_lblk - ee_block); <span class="hljs-comment">// 分配的长度可能小于要求分配的长度</span><br>ext_debug(<span class="hljs-string">&quot;%u fit into %u:%d -&gt; %llu\n&quot;</span>, <span class="hljs-built_in">map</span>-&gt;m_lblk,<br>  ee_block, ee_len, newblock);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If the extent is initialized check whether the</span><br><span class="hljs-comment"> * caller wants to convert it to unwritten.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 调用者想要清零</span><br><span class="hljs-keyword">if</span> ((!ext4_ext_is_unwritten(ex)) &amp;&amp;<br>    (flags &amp; EXT4_GET_BLOCKS_CONVERT_UNWRITTEN)) &#123;<br>allocated = convert_initialized_extent(<br>handle, inode, <span class="hljs-built_in">map</span>, &amp;path,<br>allocated);<br><span class="hljs-keyword">goto</span> out2;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!ext4_ext_is_unwritten(ex))<br><span class="hljs-keyword">goto</span> out;<br><br>ret = ext4_ext_handle_unwritten_extents(<br>handle, inode, <span class="hljs-built_in">map</span>, &amp;path, flags,<br>allocated, newblock);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>err = ret;<br><span class="hljs-keyword">else</span><br>allocated = ret;<br><span class="hljs-keyword">goto</span> out2;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">到这里就说明传入的逻辑块范围没有映射物理块，</span><br><span class="hljs-comment">如果调用者不需要我们分配实际的空间此处就返回了，可能的情况有两种：</span><br><span class="hljs-comment">1、ext4的延迟分配就是这样的，写IO流程里面不需要分配空间，回刷的时候才分配空间。</span><br><span class="hljs-comment">2、可能这段空间是文件空洞，不需要分配物理块，只需要内存中有记录即可</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((flags &amp; EXT4_GET_BLOCKS_CREATE) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">ext4_lblk_t</span> hole_start, hole_len;<br><br>hole_start = <span class="hljs-built_in">map</span>-&gt;m_lblk;<br>hole_len = ext4_ext_determine_hole(inode, path, &amp;hole_start);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">记录这个空洞到ext4_inode_info的struct ext4_es_tree i_es_tree红黑树中</span><br><span class="hljs-comment"> */</span><br>ext4_ext_put_gap_in_cache(inode, hole_start, hole_len);<br><br><span class="hljs-comment">/* Update hole_len to reflect hole size after map-&gt;m_lblk */</span><br><span class="hljs-keyword">if</span> (hole_start != <span class="hljs-built_in">map</span>-&gt;m_lblk)<br>hole_len -= <span class="hljs-built_in">map</span>-&gt;m_lblk - hole_start;<br><span class="hljs-built_in">map</span>-&gt;m_pblk = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">map</span>-&gt;m_len = <span class="hljs-type">min_t</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-built_in">map</span>-&gt;m_len, hole_len);<br><br><span class="hljs-keyword">goto</span> out2;<br>&#125;<br>    <br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>下面开始梳理ext4_ext_map_blocks()函数的后半段，也就是分配物理块，不过首先我们需要了解一些结构体以及一些宏：</p><p>1）struct ext4_extent</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">ext4_extent是extent树的叶子节点，用于在物理磁盘上描述逻辑块号和物理块号的映射关系。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_extent</span> &#123;</span><br>__le32ee_block;<span class="hljs-comment">/* extent包含的第一个逻辑块 */</span><br>__le16ee_len;<span class="hljs-comment">/* extent包含的数据块的个数 */</span><br>__le16ee_start_hi;<span class="hljs-comment">/* 物理数据块的高16位 */</span><br>__le32ee_start_lo;<span class="hljs-comment">/* 物理数据块的低32位 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>2）struct ext4_allocation_request</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">ext4_allocation_request表示的是一次分配的具体请求。</span><br><span class="hljs-comment">ext4_lblk_t是logic block的意思，代表逻辑块号</span><br><span class="hljs-comment">ext4_fsblk_t是物理块号</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_allocation_request</span> &#123;</span> <span class="hljs-comment">// 块分配请求</span><br><span class="hljs-comment">/* 要分配物理块的文件inode */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span>;</span><br><span class="hljs-comment">/* 要分配的长度 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;<br><span class="hljs-comment">/* 要分配物理块号的逻辑块号 */</span><br><span class="hljs-type">ext4_lblk_t</span> logical;<br><span class="hljs-comment">/* the closest logical allocated block to the left */</span><br><span class="hljs-type">ext4_lblk_t</span> lleft;<br><span class="hljs-comment">/* the closest logical allocated block to the right */</span><br><span class="hljs-type">ext4_lblk_t</span> lright;<br><span class="hljs-comment">/* phys. target (a hint) */</span><br>    <span class="hljs-comment">// 目标物理块号，分配器会首先看看在某些“相邻”的物理位置能不能分配，这些相邻的物理位置相当程度地保证数据局部性，具体可参考ext4_ext_find_goal()函数</span><br><span class="hljs-type">ext4_fsblk_t</span> goal; <br><span class="hljs-comment">/* phys. block for the closest logical allocated block to the left */</span><br><span class="hljs-type">ext4_fsblk_t</span> pleft;<br><span class="hljs-comment">/* phys. block for the closest logical allocated block to the right */</span><br><span class="hljs-type">ext4_fsblk_t</span> pright;<br><span class="hljs-comment">/* flags. see above EXT4_MB_HINT_* */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br>&#125;;<br></code></pre></td></tr></table></figure><p>3）EXT4_LBLK_COFF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">s是ext4_sb_info，字段s_cluster_ratio表示的是一个block cluster的block数目，它的值是2的幂，因此这个宏表示的是lblk在cluster里面的偏移。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXT4_LBLK_COFF(s, lblk) ((lblk) &amp;\</span><br><span class="hljs-meta"> ((ext4_lblk_t) (s)-&gt;s_cluster_ratio - 1))</span><br></code></pre></td></tr></table></figure><p>开始分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">ext4_ext_map_blocks</span><span class="hljs-params">(<span class="hljs-type">handle_t</span> *handle, <span class="hljs-keyword">struct</span> inode *inode,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_map_blocks *<span class="hljs-built_in">map</span>, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    ......<br><span class="hljs-comment">// 开始分配物理块</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Okay, we need to do block allocation.</span><br><span class="hljs-comment"> */</span><br>newex.ee_block = cpu_to_le32(<span class="hljs-built_in">map</span>-&gt;m_lblk); <span class="hljs-comment">// 起始逻辑块</span><br>cluster_offset = EXT4_LBLK_COFF(sbi, <span class="hljs-built_in">map</span>-&gt;m_lblk); <span class="hljs-comment">// 起始逻辑块在cluster内的偏移</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we are doing bigalloc, check to see if the extent returned</span><br><span class="hljs-comment"> * by ext4_find_extent() implies a cluster we can use.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// bigalloc上一次分配的cluster可能还没有用完，剩余的空间可以用于这一次的分配</span><br>    <span class="hljs-comment">// 值得注意的时候如果本次的起始位置在cluster内的偏移是0，那么证明这一次是新分配一个cluster，因此也就没有必要检查了</span><br>    <span class="hljs-comment">// ext4_extent ex可以理解为离这一次分配逻辑块段左边最近的逻辑块段</span><br>    <span class="hljs-comment">// 此时cluster、extent、request region之间的重叠关系就决定了能否使用前面分配的cluster未使用的区域</span><br><span class="hljs-keyword">if</span> (cluster_offset &amp;&amp; ex &amp;&amp;<br><span class="hljs-comment">// 检查重叠关系</span><br>    get_implied_cluster_alloc(inode-&gt;i_sb, <span class="hljs-built_in">map</span>, ex, path)) &#123;<br>ar.len = allocated = <span class="hljs-built_in">map</span>-&gt;m_len;<br>newblock = <span class="hljs-built_in">map</span>-&gt;m_pblk;<br>map_from_cluster = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">goto</span> got_allocated_blocks;<br>&#125;<br><br><span class="hljs-comment">/* find neighbour allocated blocks */</span><br>    <span class="hljs-comment">// 如果没法利用左边的extent分配的cluster未使用完的区域，则搜索右边有无可用区域</span><br>    <span class="hljs-comment">// 设想当前要分配的这段逻辑块段是在一个空洞内，那么它的前后逻辑块都是被分配了的extent</span><br>    <span class="hljs-comment">// 往ext4_allocation_request里记录要分配的起始逻辑块地址</span><br>ar.lleft = <span class="hljs-built_in">map</span>-&gt;m_lblk;<br>    <span class="hljs-comment">// 首先记录左边的extent的逻辑块和物理块地址，在预估后续的文件大小时使用</span><br>err = ext4_ext_search_left(inode, path, &amp;ar.lleft, &amp;ar.pleft);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> out2;<br>ar.lright = <span class="hljs-built_in">map</span>-&gt;m_lblk;<br>ex2 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 搜索右边的extent，找到离分配段最近的extent，存到ex2中</span><br>err = ext4_ext_search_right(inode, path, &amp;ar.lright, &amp;ar.pright, &amp;ex2);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> out2;<br><br><span class="hljs-comment">/* Check if the extent after searching to the right implies a</span><br><span class="hljs-comment"> * cluster we can use. */</span><br><span class="hljs-comment">// 如果右边有extent则可以看看有没有未使用的cluster的区域，有则将这段区域分配出去</span><br><span class="hljs-keyword">if</span> ((sbi-&gt;s_cluster_ratio &gt; <span class="hljs-number">1</span>) &amp;&amp; ex2 &amp;&amp;<br>    get_implied_cluster_alloc(inode-&gt;i_sb, <span class="hljs-built_in">map</span>, ex2, path)) &#123;<br>ar.len = allocated = <span class="hljs-built_in">map</span>-&gt;m_len;<br>newblock = <span class="hljs-built_in">map</span>-&gt;m_pblk;<br>map_from_cluster = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">goto</span> got_allocated_blocks;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果要分配的长度大于最大值，将分配长度对齐到最大值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;m_len &gt; EXT_INIT_MAX_LEN &amp;&amp;<br>    !(flags &amp; EXT4_GET_BLOCKS_UNWRIT_EXT))<br><span class="hljs-built_in">map</span>-&gt;m_len = EXT_INIT_MAX_LEN;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;m_len &gt; EXT_UNWRITTEN_MAX_LEN &amp;&amp;<br> (flags &amp; EXT4_GET_BLOCKS_UNWRIT_EXT))<br><span class="hljs-built_in">map</span>-&gt;m_len = EXT_UNWRITTEN_MAX_LEN;<br><br><span class="hljs-comment">/* Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */</span><br>newex.ee_len = cpu_to_le16(<span class="hljs-built_in">map</span>-&gt;m_len);<br>    <span class="hljs-comment">// 检查分配的区域跟右边的extent是否有重叠，有则缩短分配的长度</span><br>err = ext4_ext_check_overlap(sbi, inode, &amp;newex, path);<br><span class="hljs-keyword">if</span> (err)<br>        <span class="hljs-comment">// err表示有重叠，那么用新的调整了的分配长度</span><br>allocated = ext4_ext_get_actual_len(&amp;newex);<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 否则使用调用者传入的长度</span><br>allocated = <span class="hljs-built_in">map</span>-&gt;m_len;<br><br><span class="hljs-comment">/* 分配一个新的物理块段 */</span><br>ar.inode = inode;<br>    <span class="hljs-comment">// 先找到目标区域，开始分配的时候先检查能否从目标区域分配物理块</span><br>ar.goal = ext4_ext_find_goal(inode, path, <span class="hljs-built_in">map</span>-&gt;m_lblk);<br>ar.logical = <span class="hljs-built_in">map</span>-&gt;m_lblk;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We calculate the offset from the beginning of the cluster</span><br><span class="hljs-comment"> * for the logical block number, since when we allocate a</span><br><span class="hljs-comment"> * physical cluster, the physical block should start at the</span><br><span class="hljs-comment"> * same offset from the beginning of the cluster.  This is</span><br><span class="hljs-comment"> * needed so that future calls to get_implied_cluster_alloc()</span><br><span class="hljs-comment"> * work correctly.</span><br><span class="hljs-comment"> */</span><br>offset = EXT4_LBLK_COFF(sbi, <span class="hljs-built_in">map</span>-&gt;m_lblk); <span class="hljs-comment">// 起始逻辑块在cluster内的偏移</span><br>ar.len = EXT4_NUM_B2C(sbi, offset+allocated); <span class="hljs-comment">// 把要分配的长度换算成cluster数量</span><br>      <span class="hljs-comment">// 有可能因为偏移的原因占用多个cluster</span><br><span class="hljs-comment">// 将goal和logical都对齐到cluster，方便分配</span><br>    ar.goal -= offset; <br>ar.logical -= offset;<br>    <span class="hljs-comment">// 如果inode是普通文件，则置上EXT4_MB_HINT_DATA标记</span><br><span class="hljs-keyword">if</span> (S_ISREG(inode-&gt;i_mode))<br>ar.flags = EXT4_MB_HINT_DATA;<br><span class="hljs-keyword">else</span><br><span class="hljs-comment">/* disable in-core preallocation for non-regular files */</span><br>ar.flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 将调用者的“要求”一一转换到ext4_allocation_request中</span><br><span class="hljs-keyword">if</span> (flags &amp; EXT4_GET_BLOCKS_NO_NORMALIZE)<br>ar.flags |= EXT4_MB_HINT_NOPREALLOC;<br><span class="hljs-keyword">if</span> (flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE)<br>ar.flags |= EXT4_MB_DELALLOC_RESERVED;<br><span class="hljs-keyword">if</span> (flags &amp; EXT4_GET_BLOCKS_METADATA_NOFAIL)<br>ar.flags |= EXT4_MB_USE_RESERVED;<br><br>newblock = ext4_mb_new_blocks(handle, &amp;ar, &amp;err); <span class="hljs-comment">// 核心分配函数！</span><br><span class="hljs-keyword">if</span> (!newblock)<br><span class="hljs-keyword">goto</span> out2;<br>ext_debug(<span class="hljs-string">&quot;allocate new block: goal %llu, found %llu/%u\n&quot;</span>,<br>  ar.goal, newblock, allocated);<br>free_on_err = <span class="hljs-number">1</span>;<br>allocated_clusters = ar.len;<br>ar.len = EXT4_C2B(sbi, ar.len) - offset; <span class="hljs-comment">// 分配到的cluster还原到要分配的长度</span><br><span class="hljs-keyword">if</span> (ar.len &gt; allocated)<br>ar.len = allocated;<br>    <br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>get_implied_cluster_alloc()函数：</p><p>cluster、extent、request region之间的重叠关系决定了此次分配的具体长度，能够走到这个函数的证明request region的<strong>起始逻辑地址</strong>是不在extent的逻辑地址范围内的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_implied_cluster_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params">     <span class="hljs-keyword">struct</span> ext4_map_blocks *<span class="hljs-built_in">map</span>,</span><br><span class="hljs-params">     <span class="hljs-keyword">struct</span> ext4_extent *ex,</span><br><span class="hljs-params">     <span class="hljs-keyword">struct</span> ext4_ext_path *path)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br><span class="hljs-type">ext4_lblk_t</span> c_offset = EXT4_LBLK_COFF(sbi, <span class="hljs-built_in">map</span>-&gt;m_lblk);<br><span class="hljs-type">ext4_lblk_t</span> ex_cluster_start, ex_cluster_end;<br><span class="hljs-type">ext4_lblk_t</span> rr_cluster_start;<br><span class="hljs-type">ext4_lblk_t</span> ee_block = le32_to_cpu(ex-&gt;ee_block);<br><span class="hljs-type">ext4_fsblk_t</span> ee_start = ext4_ext_pblock(ex);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ee_len = ext4_ext_get_actual_len(ex);<br><br><span class="hljs-comment">/* The extent passed in that we are trying to match */</span><br>ex_cluster_start = EXT4_B2C(sbi, ee_block); <span class="hljs-comment">// extent起始逻辑地址所在的cluster</span><br>ex_cluster_end = EXT4_B2C(sbi, ee_block + ee_len - <span class="hljs-number">1</span>); <span class="hljs-comment">// extent结束逻辑地址所在的cluster</span><br><br><span class="hljs-comment">/* The requested region passed into ext4_map_blocks() */</span><br>    <span class="hljs-comment">// request region的起始逻辑地址所在的cluster</span><br>rr_cluster_start = EXT4_B2C(sbi, <span class="hljs-built_in">map</span>-&gt;m_lblk);<br><span class="hljs-comment">// 当起始cluster或者结束cluster重合时才有可能分配</span><br><span class="hljs-keyword">if</span> ((rr_cluster_start == ex_cluster_end) ||<br>    (rr_cluster_start == ex_cluster_start)) &#123;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">        第一种情况，”|==|“表示分配的长度以及起始物理块: </span><br><span class="hljs-comment">        * |--- cluster # N--|</span><br><span class="hljs-comment">  *    |--- extent ---||---- requested region ---|</span><br><span class="hljs-comment">  *            |==|</span><br><span class="hljs-comment">        */</span><br><span class="hljs-keyword">if</span> (rr_cluster_start == ex_cluster_end)<br>ee_start += ee_len - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// EXT4_PBLK_CMASK表示的是ee_start所在的cluster的起始的物理地址</span><br>        <span class="hljs-comment">// c_offset表示的是requested region的起始逻辑地址在cluster内的偏移量</span><br><span class="hljs-built_in">map</span>-&gt;m_pblk = EXT4_PBLK_CMASK(sbi, ee_start) + c_offset;<br><span class="hljs-built_in">map</span>-&gt;m_len = min(<span class="hljs-built_in">map</span>-&gt;m_len,<br> (<span class="hljs-type">unsigned</span>) sbi-&gt;s_cluster_ratio - c_offset);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 第二种情况:</span><br><span class="hljs-comment"> 细分之下有两种情况，这也是第51行代码取最小值的原因：</span><br><span class="hljs-comment">         *   |--------- cluster # N ----------------|</span><br><span class="hljs-comment">         *   |--- requested region --|   |------- extent ----|</span><br><span class="hljs-comment">         *   |=======================|</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment"> *   |--------- cluster # N-------------|</span><br><span class="hljs-comment"> *       |------- extent ----|</span><br><span class="hljs-comment"> *   |--- requested region ---|</span><br><span class="hljs-comment"> *   |=======|</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;m_lblk &lt; ee_block)<br><span class="hljs-built_in">map</span>-&gt;m_len = min(<span class="hljs-built_in">map</span>-&gt;m_len, ee_block - <span class="hljs-built_in">map</span>-&gt;m_lblk);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 第三种情况，此时要考虑到右边的extent的分配情况，其实这里没有画出来，细分之下也类似第二种情况有两种，因此第63行也有个取最小值的动作：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *          |------------- cluster # N-------------|</span><br><span class="hljs-comment"> * |----- ex -----|                  |---- ex_right ----|</span><br><span class="hljs-comment"> *                  |------ requested region ------|</span><br><span class="hljs-comment"> *                  |================|</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;m_lblk &gt; ee_block) &#123;<br><span class="hljs-type">ext4_lblk_t</span> next = ext4_ext_next_allocated_block(path);<br><span class="hljs-built_in">map</span>-&gt;m_len = min(<span class="hljs-built_in">map</span>-&gt;m_len, next - <span class="hljs-built_in">map</span>-&gt;m_lblk);<br>&#125;<br><br>trace_ext4_get_implied_cluster_alloc_exit(sb, <span class="hljs-built_in">map</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br>trace_ext4_get_implied_cluster_alloc_exit(sb, <span class="hljs-built_in">map</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是bigalloc的情况下从前面已经分配了的cluster未用完的区域分配的情况，接下来分析分配新物理块的流程：</p><p>这个流程主要有两个函数：ext4_ext_find_goal()函数和ext4_mb_new_blocks()函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 返回的是一个物理块号，分配的时候检查从这个物理块号起始分配是否可行</span><br><span class="hljs-type">static</span> <span class="hljs-type">ext4_fsblk_t</span> <span class="hljs-title function_">ext4_ext_find_goal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> ext4_ext_path *path,</span><br><span class="hljs-params">      <span class="hljs-type">ext4_lblk_t</span> block)</span><br>&#123;<br><span class="hljs-keyword">if</span> (path) &#123;<br><span class="hljs-type">int</span> depth = path-&gt;p_depth;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_extent</span> *<span class="hljs-title">ex</span>;</span><br><br>ex = path[depth].p_ext; <span class="hljs-comment">// path的终点是数据extent，即ext4_extent</span><br>                        <span class="hljs-comment">// path是从根节点到叶子节点的路径</span><br><span class="hljs-keyword">if</span> (ex) &#123;<br><span class="hljs-type">ext4_fsblk_t</span> ext_pblk = ext4_ext_pblock(ex);<br><span class="hljs-type">ext4_lblk_t</span> ext_block = le32_to_cpu(ex-&gt;ee_block);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">举两个例子:</span><br><span class="hljs-comment">|---request region---|  |---extent---|</span><br><span class="hljs-comment">|-&gt; goal</span><br><span class="hljs-comment">或者</span><br><span class="hljs-comment">|---extent---|  |---request region---|</span><br><span class="hljs-comment">|-&gt; goal</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (block &gt; ext_block) <span class="hljs-comment">// 寻找与其最近的空闲物理块，左边或者右边</span><br><span class="hljs-keyword">return</span> ext_pblk + (block - ext_block);<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> ext_pblk - (ext_block - block);<br>&#125;<br><br><span class="hljs-comment">/* it looks like index is empty;</span><br><span class="hljs-comment"> * try to find starting block from index itself */</span><br><span class="hljs-keyword">if</span> (path[depth].p_bh) <span class="hljs-comment">// index节点为空</span><br><span class="hljs-keyword">return</span> path[depth].p_bh-&gt;b_blocknr; <span class="hljs-comment">// 最后一个extent block对应的物理块号</span><br>&#125;<br><br><span class="hljs-comment">/* OK. use inode&#x27;s group */</span><br><span class="hljs-keyword">return</span> ext4_inode_to_goal_block(inode); <span class="hljs-comment">// inode刚刚创建时，没有path</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_inode_to_goal_block()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">ext4_fsblk_t</span> <span class="hljs-title function_">ext4_inode_to_goal_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_inode_info</span> *<span class="hljs-title">ei</span> =</span> EXT4_I(inode);<br><span class="hljs-type">ext4_group_t</span> block_group;<br><span class="hljs-type">ext4_grpblk_t</span> colour;<br><span class="hljs-type">int</span> flex_size = ext4_flex_bg_size(EXT4_SB(inode-&gt;i_sb));<br><span class="hljs-type">ext4_fsblk_t</span> bg_start;<br><span class="hljs-type">ext4_fsblk_t</span> last_block;<br><span class="hljs-comment">// 找到inode所在的block group</span><br>block_group = ei-&gt;i_block_group;<br>    <span class="hljs-comment">// EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME的值为4</span><br>    <span class="hljs-comment">// 如果ext4启用了flexible group特性，并且每个flexible group的block group数量大于等于4</span><br>    <span class="hljs-comment">// 则将第一个block group用于目录和特殊文件，以加速目录的访问和fsck的时间</span><br><span class="hljs-keyword">if</span> (flex_size &gt;= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If there are at least EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME</span><br><span class="hljs-comment"> * block groups per flexgroup, reserve the first block</span><br><span class="hljs-comment"> * group for directories and special files.  Regular</span><br><span class="hljs-comment"> * files will start at the second block group.  This</span><br><span class="hljs-comment"> * tends to speed up directory access and improves</span><br><span class="hljs-comment"> * fsck times.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 此时的block_group为flexible group的第一个block group的编号</span><br>block_group &amp;= ~(flex_size<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">// 如果文件是普通文件，则将block group号加一</span><br><span class="hljs-keyword">if</span> (S_ISREG(inode-&gt;i_mode))<br>block_group++;<br>&#125;<br>    <span class="hljs-comment">// bg_start为block group的第一个块的块号(物理块号)</span><br>bg_start = ext4_group_first_block_no(inode-&gt;i_sb, block_group);<br>last_block = ext4_blocks_count(EXT4_SB(inode-&gt;i_sb)-&gt;s_es) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we are doing delayed allocation, we don&#x27;t need take</span><br><span class="hljs-comment"> * colour into account.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (test_opt(inode-&gt;i_sb, DELALLOC))<br><span class="hljs-keyword">return</span> bg_start;<br><span class="hljs-comment">// 计算一个随机值color，最终goal会在flexible group的随机的一个block group上</span><br>    <span class="hljs-comment">// 当flex_group的block数量大于4时goal才确定不会在其第一个block group上</span><br><span class="hljs-keyword">if</span> (bg_start + EXT4_BLOCKS_PER_GROUP(inode-&gt;i_sb) &lt;= last_block)<br>colour = (current-&gt;pid % <span class="hljs-number">16</span>) *<br>(EXT4_BLOCKS_PER_GROUP(inode-&gt;i_sb) / <span class="hljs-number">16</span>);<br><span class="hljs-keyword">else</span><br>colour = (current-&gt;pid % <span class="hljs-number">16</span>) * ((last_block - bg_start) / <span class="hljs-number">16</span>);<br><span class="hljs-keyword">return</span> bg_start + colour;<br>&#125;<br></code></pre></td></tr></table></figure><p>正式第分配物理块，首先会调用ext4_mb_use_preallocated()函数从预分配空间里分配物理块，如果分配失败则调用ext4_mb_regular_allocator()函数进行常规的分配。</p><p>首先来看分配过程种的两个结构体：</p><p>struct ext4_free_extent结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 表示分配的请求和结果</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> &#123;</span><br><span class="hljs-type">ext4_lblk_t</span> fe_logical; <span class="hljs-comment">// 要分配的起始逻辑块号</span><br><span class="hljs-type">ext4_grpblk_t</span> fe_start;<span class="hljs-comment">// 分配的起始</span><br><span class="hljs-type">ext4_group_t</span> fe_group; <span class="hljs-comment">// 从哪个block group分配的</span><br><span class="hljs-type">ext4_grpblk_t</span> fe_len;<span class="hljs-comment">// 分配的长度，单位为cluster</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>struct ext4_allocation_context结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 对分配行为本身的描述，记录分配的中间过程数据以及分配的结果</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_allocation_context</span> &#123;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ac_inode</span>;</span> <span class="hljs-comment">// 要分配的inode</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">ac_sb</span>;</span> <span class="hljs-comment">// inode的super_block</span><br><br><span class="hljs-comment">/* original request */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ac_o_ex</span>;</span> <span class="hljs-comment">// 最开始的分配请求</span><br><br><span class="hljs-comment">/* goal request (normalized ac_o_ex) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ac_g_ex</span>;</span> <span class="hljs-comment">// 如果goal能分配成功</span><br><br><span class="hljs-comment">/* the best found extent */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ac_b_ex</span>;</span> <span class="hljs-comment">// 最终的分配结果</span><br><br><span class="hljs-comment">/* copy of the best found extent taken before preallocation efforts */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ac_f_ex</span>;</span> <span class="hljs-comment">// ac_b_ex的一份拷贝</span><br> <span class="hljs-comment">// 分配过程种的相关信息</span><br>__u16 ac_groups_scanned;<br>__u16 ac_found;<br>__u16 ac_tail;<br>__u16 ac_buddy;<br>__u16 ac_flags;<span class="hljs-comment">/* allocation hints */</span><br>__u8 ac_status;<br>__u8 ac_criteria;<br>__u8 ac_2order;<span class="hljs-comment">/* if request is to allocate 2^N blocks and</span><br><span class="hljs-comment"> * N &gt; 0, the field stores N, otherwise 0 */</span><br>__u8 ac_op;<span class="hljs-comment">/* operation, for history only */</span><br>    <span class="hljs-comment">// 跟mballoc相关的bit位信息</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">ac_bitmap_page</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">ac_buddy_page</span>;</span><br>    <span class="hljs-comment">// 预分配相关信息</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">ac_pa</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_locality_group</span> *<span class="hljs-title">ac_lg</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>ext4_mb_new_blocks()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">ext4_fsblk_t</span> <span class="hljs-title function_">ext4_mb_new_blocks</span><span class="hljs-params">(<span class="hljs-type">handle_t</span> *handle,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_allocation_request *ar, <span class="hljs-type">int</span> *errp)</span><br>&#123;<br><span class="hljs-type">int</span> freed;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_allocation_context</span> *<span class="hljs-title">ac</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span>;</span><br><span class="hljs-type">ext4_fsblk_t</span> block = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inquota = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> reserv_clstrs = <span class="hljs-number">0</span>;<br><br>might_sleep();<br>sb = ar-&gt;inode-&gt;i_sb;<br>sbi = EXT4_SB(sb);<br><br>trace_ext4_request_blocks(ar);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">......</span><br><span class="hljs-comment">前面一段是检查是否有足够的空间分配这么多，并且检查quota是否有足够的余额</span><br><span class="hljs-comment">......</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 从事先预留好的内存里分配一个ext4_allocation_context</span><br>ac = kmem_cache_zalloc(ext4_ac_cachep, GFP_NOFS);<br><span class="hljs-keyword">if</span> (!ac) &#123;<br>ar-&gt;len = <span class="hljs-number">0</span>;<br>*errp = -ENOMEM;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br>*errp = ext4_mb_initialize_context(ac, ar); <span class="hljs-comment">// 初始化allocation_context</span><br><span class="hljs-keyword">if</span> (*errp) &#123;<br>ar-&gt;len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br>ac-&gt;ac_op = EXT4_MB_HISTORY_PREALLOC;<br><span class="hljs-comment">// 非文件不用预分配</span><br><span class="hljs-keyword">if</span> (!ext4_mb_use_preallocated(ac)) &#123; <span class="hljs-comment">// 预分配失败</span><br>ac-&gt;ac_op = EXT4_MB_HISTORY_ALLOC;<br>ext4_mb_normalize_request(ac, ar); <span class="hljs-comment">// 对文件大小进行预估，预估后的大小比原来大一些</span><br>repeat:<br><span class="hljs-comment">// 常规分配</span><br>*errp = ext4_mb_regular_allocator(ac);<br><span class="hljs-keyword">if</span> (*errp)<br><span class="hljs-keyword">goto</span> discard_and_exit;<br><br><span class="hljs-comment">/* as we&#x27;ve just preallocated more space than</span><br><span class="hljs-comment"> * user requested originally, we store allocated</span><br><span class="hljs-comment"> * space in a special descriptor */</span><br><span class="hljs-keyword">if</span> (ac-&gt;ac_status == AC_STATUS_FOUND &amp;&amp;<br>    ac-&gt;ac_o_ex.fe_len &lt; ac-&gt;ac_b_ex.fe_len)<br>*errp = ext4_mb_new_preallocation(ac); <span class="hljs-comment">// 将分配的多余的空间放到预分配空间里</span><br><span class="hljs-keyword">if</span> (*errp) &#123;<br>discard_and_exit:<br>ext4_discard_allocated_blocks(ac);<br><span class="hljs-keyword">goto</span> errout;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (likely(ac-&gt;ac_status == AC_STATUS_FOUND)) &#123;<br>*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);<br><span class="hljs-keyword">if</span> (*errp) &#123;<br>ext4_discard_allocated_blocks(ac);<br><span class="hljs-keyword">goto</span> errout;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>block = ext4_grp_offs_to_block(sb, &amp;ac-&gt;ac_b_ex);<br>ar-&gt;len = ac-&gt;ac_b_ex.fe_len;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>freed  = ext4_mb_discard_preallocations(sb, ac-&gt;ac_o_ex.fe_len);<br><span class="hljs-keyword">if</span> (freed)<br><span class="hljs-keyword">goto</span> repeat;<br>*errp = -ENOSPC;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">......</span><br><span class="hljs-comment">分配失败的处理</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">return</span> block;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ext4_mb_initialize_context()函数初始化ext4_allocation_context。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_initialize_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_allocation_request *ar)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ar-&gt;inode-&gt;i_sb;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_super_block</span> *<span class="hljs-title">es</span> =</span> sbi-&gt;s_es;<br><span class="hljs-type">ext4_group_t</span> group;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;<br><span class="hljs-type">ext4_fsblk_t</span> goal;<br><span class="hljs-type">ext4_grpblk_t</span> block;<br><br><span class="hljs-comment">/* we can&#x27;t allocate &gt; group size */</span><br>len = ar-&gt;len; <span class="hljs-comment">// len就是要申请的cluster的数量</span><br><br><span class="hljs-comment">/* just a dirty hack to filter too big requests  */</span><br>    <span class="hljs-comment">// 分配的cluster数量超过了一个block group的cluster数量，减小之</span><br><span class="hljs-keyword">if</span> (len &gt;= EXT4_CLUSTERS_PER_GROUP(sb)) <br>len = EXT4_CLUSTERS_PER_GROUP(sb);<br><br><span class="hljs-comment">/* start searching from the goal */</span><br>goal = ar-&gt;goal;<br><span class="hljs-keyword">if</span> (goal &lt; le32_to_cpu(es-&gt;s_first_data_block) ||<br>goal &gt;= ext4_blocks_count(es))<br>goal = le32_to_cpu(es-&gt;s_first_data_block);<br>    <span class="hljs-comment">// group为goal的block group的编号</span><br>    <span class="hljs-comment">// block为在group中的cluster的偏移（块组中的第几个cluster）</span><br>ext4_get_group_no_and_offset(sb, goal, &amp;group, &amp;block);<br><br><span class="hljs-comment">/* set up allocation goals */</span><br>ac-&gt;ac_b_ex.fe_logical = EXT4_LBLK_CMASK(sbi, ar-&gt;logical); <span class="hljs-comment">// 逻辑块号</span><br>ac-&gt;ac_status = AC_STATUS_CONTINUE; <span class="hljs-comment">// 分配的结果状态</span><br>ac-&gt;ac_sb = sb;<br>ac-&gt;ac_inode = ar-&gt;inode;<br>    <span class="hljs-comment">// 初始化ac_o_ex，表示原始的分配请求，初始化为goal的值，表示最开始想从goal分配</span><br>ac-&gt;ac_o_ex.fe_logical = ac-&gt;ac_b_ex.fe_logical;<br>ac-&gt;ac_o_ex.fe_group = group;<br>ac-&gt;ac_o_ex.fe_start = block;<br>ac-&gt;ac_o_ex.fe_len = len; <span class="hljs-comment">// len就是要分配的cluster的数量</span><br>ac-&gt;ac_g_ex = ac-&gt;ac_o_ex; <span class="hljs-comment">// ac_g_ex被赋值成ac_o_ex</span><br>ac-&gt;ac_flags = ar-&gt;flags;<br><br><span class="hljs-comment">// 这个函数在预分配一节里分析</span><br>ext4_mb_group_or_file(ac);<br><br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;init ac: %u blocks @ %u, goal %u, flags %x, 2^%d, &quot;</span><br><span class="hljs-string">&quot;left: %u/%u, right %u/%u to %swritable\n&quot;</span>,<br>(<span class="hljs-type">unsigned</span>) ar-&gt;len, (<span class="hljs-type">unsigned</span>) ar-&gt;logical,<br>(<span class="hljs-type">unsigned</span>) ar-&gt;goal, ac-&gt;ac_flags, ac-&gt;ac_2order,<br>(<span class="hljs-type">unsigned</span>) ar-&gt;lleft, (<span class="hljs-type">unsigned</span>) ar-&gt;pleft,<br>(<span class="hljs-type">unsigned</span>) ar-&gt;lright, (<span class="hljs-type">unsigned</span>) ar-&gt;pright,<br><span class="hljs-type">atomic_read</span>(&amp;ar-&gt;inode-&gt;i_writecount) ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;non-&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="预分配-1"><a href="#预分配-1" class="headerlink" title="预分配"></a>预分配</h3><p> ext4对于大文件采用的是per inode预留分配空间的方式分配，对于小文件采用的是per_cpu locality group的方式，那么怎么定义文件是大文件还是小文件呢？在sys文件系统的“&#x2F;sys&#x2F;fs&#x2F;ext4&#x2F;<partition>&#x2F;mb_stream_req”的值，如果文件大小超过了这个值就是“大文件”，小于等于则是“小文件”，mb_stream_req默认为16个文件块，按照每个文件块4k计算为64k。</p><p>ext4在ext4_mb_group_or_file()函数决定是使用per inode预分配还是per_cpu locality group预分配，此时函数被ext4_mb_initialize_context()函数调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_group_or_file</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(ac-&gt;ac_sb);<br><span class="hljs-type">int</span> bsbits = ac-&gt;ac_sb-&gt;s_blocksize_bits;<br><span class="hljs-type">loff_t</span> size, isize;<br><br><span class="hljs-keyword">if</span> (!(ac-&gt;ac_flags &amp; EXT4_MB_HINT_DATA))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span> (unlikely(ac-&gt;ac_flags &amp; EXT4_MB_HINT_GOAL_ONLY))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">// 此次分配后文件的大小，单位为文件块</span><br>size = ac-&gt;ac_o_ex.fe_logical + EXT4_C2B(sbi, ac-&gt;ac_o_ex.fe_len);<br><span class="hljs-comment">// 文件当前总长度，单位为文件块</span><br>isize = (i_size_read(ac-&gt;ac_inode) + ac-&gt;ac_sb-&gt;s_blocksize - <span class="hljs-number">1</span>)<br>&gt;&gt; bsbits;<br><br><span class="hljs-keyword">if</span> ((size == isize) &amp;&amp;<br>    !ext4_fs_is_busy(sbi) &amp;&amp;<br>    (<span class="hljs-type">atomic_read</span>(&amp;ac-&gt;ac_inode-&gt;i_writecount) == <span class="hljs-number">0</span>)) &#123;<br>ac-&gt;ac_flags |= EXT4_MB_HINT_NOPREALLOC;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>    <span class="hljs-comment">// s_mb_group_prealloc未设置</span><br><span class="hljs-keyword">if</span> (sbi-&gt;s_mb_group_prealloc &lt;= <span class="hljs-number">0</span>) &#123;<br>ac-&gt;ac_flags |= EXT4_MB_STREAM_ALLOC;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* don&#x27;t use group allocation for large files */</span><br>size = max(size, isize);<br><span class="hljs-keyword">if</span> (size &gt; sbi-&gt;s_mb_stream_request) &#123; <span class="hljs-comment">// s_mb_stream_request默认是16个文件块</span><br>ac-&gt;ac_flags |= EXT4_MB_STREAM_ALLOC;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>    <span class="hljs-comment">// 小文件采用per_cpu locality group方式分配</span><br>BUG_ON(ac-&gt;ac_lg != <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * locality group prealloc space are per cpu. The reason for having</span><br><span class="hljs-comment"> * per cpu locality group is to reduce the contention between block</span><br><span class="hljs-comment"> * request from multiple CPUs.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 从ext4_sb_info里获取当前CPU的ext4_locality_group</span><br>ac-&gt;ac_lg = raw_cpu_ptr(sbi-&gt;s_locality_groups);<br><br><span class="hljs-comment">/* we&#x27;re going to use group allocation */</span><br>ac-&gt;ac_flags |= EXT4_MB_HINT_GROUP_ALLOC;<br><br><span class="hljs-comment">/* serialize all allocations in the group */</span><br>mutex_lock(&amp;ac-&gt;ac_lg-&gt;lg_mutex);<br>&#125;<br></code></pre></td></tr></table></figure><p>预分配空间struct ext4_prealloc_space结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> &#123;</span> <span class="hljs-comment">// 预分配空间</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">pa_inode_list</span>;</span> <span class="hljs-comment">// 如果是per inode的预分配空间则挂在ext4_inode_info的i_prealloc_list链表; 如果是per_cpu locality group的预分配空间则挂在ext4_locality_group的lg_prealloc_list链表上</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">pa_group_list</span>;</span> <span class="hljs-comment">// 预分配空间同时也会挂在ext4_group_info的bb_prealloc_list链表上，用于初始化buddy bitmap的之前给block bitmap置上对应的已使用标记</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">pa_tmp_list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span><span class="hljs-title">pa_rcu</span>;</span><br>&#125; u;<br><span class="hljs-type">spinlock_t</span>pa_lock;<br><span class="hljs-type">atomic_t</span>pa_count;<br><span class="hljs-type">unsigned</span>pa_deleted; <span class="hljs-comment">// 预分配空间是否处于删除状态</span><br><span class="hljs-type">ext4_fsblk_t</span>pa_pstart;<span class="hljs-comment">/* phys. block 起始物理地址 */</span><br><span class="hljs-type">ext4_lblk_t</span>pa_lstart;<span class="hljs-comment">/* log. block 起始逻辑地址，相对于文件而言 */</span><br><span class="hljs-type">ext4_grpblk_t</span>pa_len;<span class="hljs-comment">/* len of preallocated chunk， 空间长度 */</span><br><span class="hljs-type">ext4_grpblk_t</span>pa_free;<span class="hljs-comment">/* how many blocks are free，空间的可用长度 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>pa_type;<span class="hljs-comment">/* pa type. inode or group */</span><br><span class="hljs-type">spinlock_t</span>*pa_obj_lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>*<span class="hljs-title">pa_inode</span>;</span><span class="hljs-comment">/* hack, for history only */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>ext4_locality_group结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREALLOC_TB_SIZE 10</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_locality_group</span> &#123;</span><br><span class="hljs-comment">/* for allocator */</span><br><span class="hljs-comment">/* to serialize allocates */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span><span class="hljs-title">lg_mutex</span>;</span><br><span class="hljs-comment">/* list of preallocations */</span><br>    <span class="hljs-comment">// 挂ext4_prealloc_space的链表，按照预分配空间的可用长度进行分组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">lg_prealloc_list</span>[<span class="hljs-title">PREALLOC_TB_SIZE</span>];</span><br><span class="hljs-type">spinlock_t</span>lg_prealloc_lock;<br>&#125;;<br></code></pre></td></tr></table></figure><p>ext4_mb_use_preallocated()函数，检查预分配空间里是否能够分配goal：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_use_preallocated</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(ac-&gt;ac_sb);<br><span class="hljs-type">int</span> order, i;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_inode_info</span> *<span class="hljs-title">ei</span> =</span> EXT4_I(ac-&gt;ac_inode);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_locality_group</span> *<span class="hljs-title">lg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span>, *<span class="hljs-title">cpa</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">ext4_fsblk_t</span> goal_block;<br><br><span class="hljs-comment">/* only data can be preallocated */</span><br><span class="hljs-keyword">if</span> (!(ac-&gt;ac_flags &amp; EXT4_MB_HINT_DATA))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 先尝试per inode的预分配，遍历预分配空间链表</span><br>rcu_read_lock();<br>list_for_each_entry_rcu(pa, &amp;ei-&gt;i_prealloc_list, pa_inode_list) &#123;<br><br><span class="hljs-comment">/* all fields in this condition don&#x27;t change,</span><br><span class="hljs-comment"> * so we can skip locking for them */</span><br> <span class="hljs-comment">// 不在这个预分配空间范围内，跳到下一个预分配空间</span><br><span class="hljs-keyword">if</span> (ac-&gt;ac_o_ex.fe_logical &lt; pa-&gt;pa_lstart ||<br>    ac-&gt;ac_o_ex.fe_logical &gt;= (pa-&gt;pa_lstart +<br>       EXT4_C2B(sbi, pa-&gt;pa_len)))<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">/* non-extent files can&#x27;t have physical blocks past 2^32 */</span><br>    <span class="hljs-comment">// 非extent的ext4文件的最大可访问的物理块为2^32，如果</span><br><span class="hljs-keyword">if</span> (!(ext4_test_inode_flag(ac-&gt;ac_inode, EXT4_INODE_EXTENTS)) &amp;&amp;<br>    (pa-&gt;pa_pstart + EXT4_C2B(sbi, pa-&gt;pa_len) &gt;<br>     EXT4_MAX_BLOCK_FILE_PHYS))<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">// 找到了合适的预分配空间，则分配之</span><br>spin_lock(&amp;pa-&gt;pa_lock);<br><span class="hljs-keyword">if</span> (pa-&gt;pa_deleted == <span class="hljs-number">0</span> &amp;&amp; pa-&gt;pa_free) &#123;<br><span class="hljs-type">atomic_inc</span>(&amp;pa-&gt;pa_count);<br>            <span class="hljs-comment">// 往ext4_allocation_context记录分配的最终结果</span><br>ext4_mb_use_inode_pa(ac, pa);<br>spin_unlock(&amp;pa-&gt;pa_lock);<br>ac-&gt;ac_criteria = <span class="hljs-number">10</span>;<br>rcu_read_unlock();<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>spin_unlock(&amp;pa-&gt;pa_lock);<br>&#125;<br>rcu_read_unlock();<br><span class="hljs-comment">// 进行per_cpu locality group的预分配</span><br><span class="hljs-comment">/* can we use group allocation? */</span><br><span class="hljs-keyword">if</span> (!(ac-&gt;ac_flags &amp; EXT4_MB_HINT_GROUP_ALLOC))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* inode may have no locality group for some reason */</span><br>lg = ac-&gt;ac_lg;<br><span class="hljs-keyword">if</span> (lg == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// fls的意思是找到fe_len从右往左的最后一个1的位置，即为len的阶</span><br>order  = fls(ac-&gt;ac_o_ex.fe_len) - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (order &gt; PREALLOC_TB_SIZE - <span class="hljs-number">1</span>)<br><span class="hljs-comment">/* The max size of hash table is PREALLOC_TB_SIZE */</span><br>order = PREALLOC_TB_SIZE - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// goal_block为goal在block group中的偏移</span><br>goal_block = ext4_grp_offs_to_block(ac-&gt;ac_sb, &amp;ac-&gt;ac_g_ex);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * search for the prealloc space that is having</span><br><span class="hljs-comment"> * minimal distance from the goal block.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = order; i &lt; PREALLOC_TB_SIZE; i++) &#123;<br>rcu_read_lock();<br>        <span class="hljs-comment">// 遍历当前CPU的预分配空间链表</span><br>list_for_each_entry_rcu(pa, &amp;lg-&gt;lg_prealloc_list[i],<br>pa_inode_list) &#123;<br>spin_lock(&amp;pa-&gt;pa_lock);<br>            <span class="hljs-comment">// 预分配空间没有被删除，且有足够的可用空间进行分配</span><br><span class="hljs-keyword">if</span> (pa-&gt;pa_deleted == <span class="hljs-number">0</span> &amp;&amp;<br>pa-&gt;pa_free &gt;= ac-&gt;ac_o_ex.fe_len) &#123;<br><span class="hljs-comment">// 进一步检查，以找到最合适的</span><br>cpa = ext4_mb_check_group_pa(goal_block, pa, cpa);<br>&#125;<br>spin_unlock(&amp;pa-&gt;pa_lock);<br>&#125;<br>rcu_read_unlock();<br>&#125;<br><span class="hljs-keyword">if</span> (cpa) &#123;<br>ext4_mb_use_group_pa(ac, cpa);<br>ac-&gt;ac_criteria = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_use_inode_pa()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">per inode的预分配成功分配</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_use_inode_pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_prealloc_space *pa)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(ac-&gt;ac_sb);<br><span class="hljs-type">ext4_fsblk_t</span> start;<br><span class="hljs-type">ext4_fsblk_t</span> end;<br><span class="hljs-type">int</span> len;<br><br><span class="hljs-comment">/* found preallocated blocks, use them */</span><br>start = pa-&gt;pa_pstart + (ac-&gt;ac_o_ex.fe_logical - pa-&gt;pa_lstart);<br>end = min(pa-&gt;pa_pstart + EXT4_C2B(sbi, pa-&gt;pa_len),<br>  start + EXT4_C2B(sbi, ac-&gt;ac_o_ex.fe_len));<br>len = EXT4_NUM_B2C(sbi, end - start);<br>ext4_get_group_no_and_offset(ac-&gt;ac_sb, start, &amp;ac-&gt;ac_b_ex.fe_group,<br>&amp;ac-&gt;ac_b_ex.fe_start);<br>ac-&gt;ac_b_ex.fe_len = len; <span class="hljs-comment">// 将分配结果置在ac_b_ex</span><br>ac-&gt;ac_status = AC_STATUS_FOUND; <span class="hljs-comment">// 分配结果为找到了</span><br>ac-&gt;ac_pa = pa; <span class="hljs-comment">// 保存是从哪个预分配空间分配的</span><br><br>BUG_ON(start &lt; pa-&gt;pa_pstart);<br>BUG_ON(end &gt; pa-&gt;pa_pstart + EXT4_C2B(sbi, pa-&gt;pa_len));<br>BUG_ON(pa-&gt;pa_free &lt; len);<br>pa-&gt;pa_free -= len; <span class="hljs-comment">// 减少预分配空间的可用长度</span><br><br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;use %llu/%u from inode pa %p\n&quot;</span>, start, len, pa);<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_check_group_pa()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">找到一个最合适的预分配空间，什么是“最合适的”呢？</span><br><span class="hljs-comment">要分配的目标物理块地址跟预分配空间的起始地址最近的预分配空间。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> ext4_prealloc_space *<br><span class="hljs-title function_">ext4_mb_check_group_pa</span><span class="hljs-params">(<span class="hljs-type">ext4_fsblk_t</span> goal_block,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_prealloc_space *pa,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_prealloc_space *cpa)</span><br>&#123;<br><span class="hljs-type">ext4_fsblk_t</span> cur_distance, new_distance;<br><br><span class="hljs-keyword">if</span> (cpa == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-type">atomic_inc</span>(&amp;pa-&gt;pa_count);<br><span class="hljs-keyword">return</span> pa;<br>&#125;<br>cur_distance = <span class="hljs-built_in">abs</span>(goal_block - cpa-&gt;pa_pstart);<br>new_distance = <span class="hljs-built_in">abs</span>(goal_block - pa-&gt;pa_pstart);<br><span class="hljs-comment">// 找到一个goal离预分配空间起始地址最近的预分配空间</span><br><span class="hljs-keyword">if</span> (cur_distance &lt;= new_distance)<br><span class="hljs-keyword">return</span> cpa;<br><br><span class="hljs-comment">/* drop the previous reference */</span><br><span class="hljs-type">atomic_dec</span>(&amp;cpa-&gt;pa_count);<br><span class="hljs-type">atomic_inc</span>(&amp;pa-&gt;pa_count);<br><span class="hljs-keyword">return</span> pa;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_use_group_pa()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 当从per_cpu locality group分配成功时</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_use_group_pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_prealloc_space *pa)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = ac-&gt;ac_o_ex.fe_len;<br><br>ext4_get_group_no_and_offset(ac-&gt;ac_sb, pa-&gt;pa_pstart,<br>&amp;ac-&gt;ac_b_ex.fe_group,<br>&amp;ac-&gt;ac_b_ex.fe_start);<br>ac-&gt;ac_b_ex.fe_len = len;<br>ac-&gt;ac_status = AC_STATUS_FOUND;<br>ac-&gt;ac_pa = pa;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">对比ext4_mb_use_inode_pa()我们可以发现这里并没有着急地减少预分配空间的可用空间，一方面是因为此时是加了lg_mutex锁的，另一方面是为了防止其他流程也加载了block group而带来的竞争，最后在更新了block bitmap的时候才减少预分配空间的可用空间。</span><br><span class="hljs-comment"> */</span><br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;use %u/%u from group pa %p\n&quot;</span>, pa-&gt;pa_lstart-len, len, pa);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="预分配空间的来源"><a href="#预分配空间的来源" class="headerlink" title="预分配空间的来源"></a>预分配空间的来源</h3><p>在ext4_mb_new_blocks()函数，当采用常规的分配方式分配成功后，如果所分得的长度大于最初要求分配的长度，那么多余出来的这部分空间就可以用来预分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">ext4_fsblk_t</span> <span class="hljs-title function_">ext4_mb_new_blocks</span><span class="hljs-params">(<span class="hljs-type">handle_t</span> *handle,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_allocation_request *ar, <span class="hljs-type">int</span> *errp)</span><br>&#123;<br>    <span class="hljs-comment">/* ...... */</span><br><span class="hljs-keyword">if</span> (!ext4_mb_use_preallocated(ac)) &#123; <span class="hljs-comment">// 预分配失败</span><br>ac-&gt;ac_op = EXT4_MB_HISTORY_ALLOC;<br>ext4_mb_normalize_request(ac, ar); <span class="hljs-comment">// 对文件大小进行预估，预估后的大小比原来大一些</span><br>repeat:<br><span class="hljs-comment">/* 常规多块分配 */</span><br>*errp = ext4_mb_regular_allocator(ac);<br><span class="hljs-keyword">if</span> (*errp)<br><span class="hljs-keyword">goto</span> discard_and_exit;<br><br><span class="hljs-comment">/* as we&#x27;ve just preallocated more space than</span><br><span class="hljs-comment"> * user requested originally, we store allocated</span><br><span class="hljs-comment"> * space in a special descriptor */</span><br><span class="hljs-keyword">if</span> (ac-&gt;ac_status == AC_STATUS_FOUND &amp;&amp;<br>    ac-&gt;ac_o_ex.fe_len &lt; ac-&gt;ac_b_ex.fe_len)<br>*errp = ext4_mb_new_preallocation(ac); <span class="hljs-comment">// 有多余的分配的空间作为预分配空间</span><br><span class="hljs-keyword">if</span> (*errp) &#123;<br>discard_and_exit:<br>ext4_discard_allocated_blocks(ac);<br><span class="hljs-keyword">goto</span> errout;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">/* ...... */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_new_preallocation()函数，将分配的多余的空间加入到预分配链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_new_preallocation</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br><span class="hljs-type">int</span> err;<br><br>    <span class="hljs-comment">// 如果该文件是小文件则将多余空间加入到per_cpu locality group预分配空间，如果是大文件则将多余空间加入到per inode预分配空间</span><br>    <span class="hljs-comment">// 这个标记是在ext4_mb_group_or_file()函数根据配置的判别文件是大文件还是小文件的配置项来置上的</span><br><span class="hljs-keyword">if</span> (ac-&gt;ac_flags &amp; EXT4_MB_HINT_GROUP_ALLOC)<br>err = ext4_mb_new_group_pa(ac);<br><span class="hljs-keyword">else</span><br>err = ext4_mb_new_inode_pa(ac);<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_new_group_pa()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_new_group_pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_locality_group</span> *<span class="hljs-title">lg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span>;</span><br><br><span class="hljs-comment">/* preallocate only when found space is larger then requested */</span><br>BUG_ON(ac-&gt;ac_o_ex.fe_len &gt;= ac-&gt;ac_b_ex.fe_len);<br>BUG_ON(ac-&gt;ac_status != AC_STATUS_FOUND);<br>BUG_ON(!S_ISREG(ac-&gt;ac_inode-&gt;i_mode));<br><br>BUG_ON(ext4_pspace_cachep == <span class="hljs-literal">NULL</span>);<br>pa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);<br><span class="hljs-keyword">if</span> (pa == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br><span class="hljs-comment">/* preallocation can change ac_b_ex, thus we store actually</span><br><span class="hljs-comment"> * allocated blocks for history */</span><br>ac-&gt;ac_f_ex = ac-&gt;ac_b_ex;<br><br>pa-&gt;pa_pstart = ext4_grp_offs_to_block(sb, &amp;ac-&gt;ac_b_ex);<br>pa-&gt;pa_lstart = pa-&gt;pa_pstart;<br>pa-&gt;pa_len = ac-&gt;ac_b_ex.fe_len; <span class="hljs-comment">// 注意到pa的len是常规分配后分配到的长度！</span><br>pa-&gt;pa_free = pa-&gt;pa_len;<br><span class="hljs-type">atomic_set</span>(&amp;pa-&gt;pa_count, <span class="hljs-number">1</span>);<br>spin_lock_init(&amp;pa-&gt;pa_lock);<br>INIT_LIST_HEAD(&amp;pa-&gt;pa_inode_list);<br>INIT_LIST_HEAD(&amp;pa-&gt;pa_group_list);<br>pa-&gt;pa_deleted = <span class="hljs-number">0</span>;<br>pa-&gt;pa_type = MB_GROUP_PA;<br><br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;new group pa %p: %llu/%u for %u\n&quot;</span>, pa,<br>pa-&gt;pa_pstart, pa-&gt;pa_len, pa-&gt;pa_lstart);<br>trace_ext4_mb_new_group_pa(ac, pa);<br><br>ext4_mb_use_group_pa(ac, pa); <span class="hljs-comment">// 注意这一行</span><br><span class="hljs-type">atomic_add</span>(pa-&gt;pa_free, &amp;EXT4_SB(sb)-&gt;s_mb_preallocated);<br><br>grp = ext4_get_group_info(sb, ac-&gt;ac_b_ex.fe_group);<br>lg = ac-&gt;ac_lg;<br>BUG_ON(lg == <span class="hljs-literal">NULL</span>);<br><br>pa-&gt;pa_obj_lock = &amp;lg-&gt;lg_prealloc_lock;<br>pa-&gt;pa_inode = <span class="hljs-literal">NULL</span>;<br><br>ext4_lock_group(sb, ac-&gt;ac_b_ex.fe_group);<br>list_add(&amp;pa-&gt;pa_group_list, &amp;grp-&gt;bb_prealloc_list);<br>ext4_unlock_group(sb, ac-&gt;ac_b_ex.fe_group);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We will later add the new pa to the right bucket</span><br><span class="hljs-comment"> * after updating the pa_free in ext4_mb_release_context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察整个函数以及第38行可知，ext4_mb_new_group_pa()函数生成了一个ext4_prealloc_space但是没有急于将其挂入到per_cpu locality group中，而且ext4_prealloc_space的长度也是常规分配后分配到的长度而不是多余的长度，而是先调用ext4_mb_use_group_pa()函数将其保存到ac中(这里会改变分配到的长度len，因此在21行先将ac_b_ex拷贝到ac_f_ex)，然后在最后的ext4_mb_release_context()流程中将其加入到per_cpu locality group，这样做是为了跟如果从per_cpu locality group分配到了预分配空间一起统一处理。</p><p>ext4_mb_release_context()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_release_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(ac-&gt;ac_sb);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span> =</span> ac-&gt;ac_pa;<br><span class="hljs-keyword">if</span> (pa) &#123;<br>        <span class="hljs-comment">// 这里才减少ext4_prealloc_space的可用长度</span><br><span class="hljs-keyword">if</span> (pa-&gt;pa_type == MB_GROUP_PA) &#123;<br><span class="hljs-comment">/* see comment in ext4_mb_use_group_pa() */</span><br>spin_lock(&amp;pa-&gt;pa_lock);<br>pa-&gt;pa_pstart += EXT4_C2B(sbi, ac-&gt;ac_b_ex.fe_len);<br>pa-&gt;pa_lstart += EXT4_C2B(sbi, ac-&gt;ac_b_ex.fe_len);<br>pa-&gt;pa_free -= ac-&gt;ac_b_ex.fe_len;<br>pa-&gt;pa_len -= ac-&gt;ac_b_ex.fe_len;<br>spin_unlock(&amp;pa-&gt;pa_lock);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (pa) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We want to add the pa to the right bucket.</span><br><span class="hljs-comment"> * Remove it from the list and while adding</span><br><span class="hljs-comment"> * make sure the list to which we are adding</span><br><span class="hljs-comment"> * doesn&#x27;t grow big.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((pa-&gt;pa_type == MB_GROUP_PA) &amp;&amp; likely(pa-&gt;pa_free)) &#123;<br>spin_lock(pa-&gt;pa_obj_lock);<br>list_del_rcu(&amp;pa-&gt;pa_inode_list);<br>spin_unlock(pa-&gt;pa_obj_lock);<br>ext4_mb_add_n_trim(ac); <span class="hljs-comment">// 将其加入到per_cpu locality group中</span><br>&#125;<br>ext4_mb_put_pa(ac, ac-&gt;ac_sb, pa);<br>&#125;<br><span class="hljs-keyword">if</span> (ac-&gt;ac_bitmap_page)<br>put_page(ac-&gt;ac_bitmap_page);<br><span class="hljs-keyword">if</span> (ac-&gt;ac_buddy_page)<br>put_page(ac-&gt;ac_buddy_page);<br><span class="hljs-keyword">if</span> (ac-&gt;ac_flags &amp; EXT4_MB_HINT_GROUP_ALLOC)<br>mutex_unlock(&amp;ac-&gt;ac_lg-&gt;lg_mutex);<br>ext4_mb_collect_stats(ac);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_add_n_trim()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_add_n_trim</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br><span class="hljs-type">int</span> order, added = <span class="hljs-number">0</span>, lg_prealloc_count = <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_locality_group</span> *<span class="hljs-title">lg</span> =</span> ac-&gt;ac_lg;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">tmp_pa</span>, *<span class="hljs-title">pa</span> =</span> ac-&gt;ac_pa;<br><br>    <span class="hljs-comment">// 根据预留空间的长度找到其应该所在的桶</span><br>order = fls(pa-&gt;pa_free) - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (order &gt; PREALLOC_TB_SIZE - <span class="hljs-number">1</span>)<br><span class="hljs-comment">/* The max size of hash table is PREALLOC_TB_SIZE */</span><br>order = PREALLOC_TB_SIZE - <span class="hljs-number">1</span>;<br><span class="hljs-comment">/* Add the prealloc space to lg */</span><br>spin_lock(&amp;lg-&gt;lg_prealloc_lock);<br>    <span class="hljs-comment">// 遍历桶的链表，然后将ext4_prealloc_space插入其中</span><br>list_for_each_entry_rcu(tmp_pa, &amp;lg-&gt;lg_prealloc_list[order],<br>pa_inode_list) &#123;<br>spin_lock(&amp;tmp_pa-&gt;pa_lock);<br><span class="hljs-keyword">if</span> (tmp_pa-&gt;pa_deleted) &#123;<br>spin_unlock(&amp;tmp_pa-&gt;pa_lock);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <span class="hljs-comment">// 在链表里面ext4_prealloc_space是按照可用空间由前到后的顺序排列的</span><br><span class="hljs-keyword">if</span> (!added &amp;&amp; pa-&gt;pa_free &lt; tmp_pa-&gt;pa_free) &#123;<br><span class="hljs-comment">/* Add to the tail of the previous entry */</span><br>list_add_tail_rcu(&amp;pa-&gt;pa_inode_list,<br>&amp;tmp_pa-&gt;pa_inode_list);<br>added = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * we want to count the total</span><br><span class="hljs-comment"> * number of entries in the list</span><br><span class="hljs-comment"> */</span><br>&#125;<br>spin_unlock(&amp;tmp_pa-&gt;pa_lock);<br>lg_prealloc_count++;<br>&#125;<br>    <span class="hljs-comment">// 如果新的这个ext4_prealloc_space的可用空间是最大的，那么插入到链表尾端</span><br><span class="hljs-keyword">if</span> (!added)<br>list_add_tail_rcu(&amp;pa-&gt;pa_inode_list,<br>&amp;lg-&gt;lg_prealloc_list[order]);<br>spin_unlock(&amp;lg-&gt;lg_prealloc_lock);<br><br><span class="hljs-comment">// 如果当前桶的预分配空间个数超过了8个，则相应的减少它们</span><br><span class="hljs-keyword">if</span> (lg_prealloc_count &gt; <span class="hljs-number">8</span>) &#123;<br>ext4_mb_discard_lg_preallocations(sb, lg,<br>  order, lg_prealloc_count);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_discard_lg_preallocations()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">void</span><br><span class="hljs-title function_">ext4_mb_discard_lg_preallocations</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_locality_group *lg,</span><br><span class="hljs-params"><span class="hljs-type">int</span> order, <span class="hljs-type">int</span> total_entries)</span><br>&#123;<br><span class="hljs-type">ext4_group_t</span> group = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_buddy</span> <span class="hljs-title">e4b</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">discard_list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span>, *<span class="hljs-title">tmp</span>;</span><br><br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;discard locality group preallocation\n&quot;</span>);<br><br>INIT_LIST_HEAD(&amp;discard_list);<br><br>spin_lock(&amp;lg-&gt;lg_prealloc_lock);<br>list_for_each_entry_rcu(pa, &amp;lg-&gt;lg_prealloc_list[order],<br>pa_inode_list) &#123;<br>spin_lock(&amp;pa-&gt;pa_lock);<br>        <span class="hljs-comment">// 如果预分配空间正在使用(刚刚分配流程在使用)，则不能删除</span><br><span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;pa-&gt;pa_count)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is the pa that we just used</span><br><span class="hljs-comment"> * for block allocation. So don&#x27;t</span><br><span class="hljs-comment"> * free that</span><br><span class="hljs-comment"> */</span><br>spin_unlock(&amp;pa-&gt;pa_lock);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (pa-&gt;pa_deleted) &#123;<br>spin_unlock(&amp;pa-&gt;pa_lock);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">/* only lg prealloc space */</span><br>BUG_ON(pa-&gt;pa_type != MB_GROUP_PA);<br><br><span class="hljs-comment">/* seems this one can be freed ... */</span><br>pa-&gt;pa_deleted = <span class="hljs-number">1</span>;<br>spin_unlock(&amp;pa-&gt;pa_lock);<br><span class="hljs-comment">// 将预分配空间摘链</span><br>list_del_rcu(&amp;pa-&gt;pa_inode_list);<br>        <span class="hljs-comment">// 加入到临时的discard_list链表中</span><br>list_add(&amp;pa-&gt;u.pa_tmp_list, &amp;discard_list);<br><br>total_entries--;<br><span class="hljs-keyword">if</span> (total_entries &lt;= <span class="hljs-number">5</span>) &#123; <span class="hljs-comment">// 预分配空间个数减少到5个的时候才停止，以防止很快又调用本函数</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * we want to keep only 5 entries</span><br><span class="hljs-comment"> * allowing it to grow to 8. This</span><br><span class="hljs-comment"> * mak sure we don&#x27;t call discard</span><br><span class="hljs-comment"> * soon for this list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>spin_unlock(&amp;lg-&gt;lg_prealloc_lock);<br><br>list_for_each_entry_safe(pa, tmp, &amp;discard_list, u.pa_tmp_list) &#123;<br><span class="hljs-type">int</span> err;<br><br>group = ext4_get_group_number(sb, pa-&gt;pa_pstart);<br>err = ext4_mb_load_buddy_gfp(sb, group, &amp;e4b,<br>     GFP_NOFS|__GFP_NOFAIL);<br><span class="hljs-keyword">if</span> (err) &#123;<br>ext4_error(sb, <span class="hljs-string">&quot;Error %d loading buddy information for %u&quot;</span>,<br>   err, group);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>ext4_lock_group(sb, group);<br>list_del(&amp;pa-&gt;pa_group_list); <span class="hljs-comment">// 从ext4_group_info里面摘链</span><br>ext4_mb_release_group_pa(&amp;e4b, pa); <span class="hljs-comment">// 释放预分配空间，将其返还给文件系统</span><br>ext4_unlock_group(sb, group);<br><br>ext4_mb_unload_buddy(&amp;e4b);<br>list_del(&amp;pa-&gt;u.pa_tmp_list);<br>call_rcu(&amp;(pa)-&gt;u.pa_rcu, ext4_mb_pa_callback); <span class="hljs-comment">// 在callback里面会释放掉ext4_prealloc_space</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_new_inode_pa()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_new_inode_pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_inode_info</span> *<span class="hljs-title">ei</span>;</span><br><br><span class="hljs-comment">/* preallocate only when found space is larger then requested */</span><br>BUG_ON(ac-&gt;ac_o_ex.fe_len &gt;= ac-&gt;ac_b_ex.fe_len);<br>BUG_ON(ac-&gt;ac_status != AC_STATUS_FOUND);<br>BUG_ON(!S_ISREG(ac-&gt;ac_inode-&gt;i_mode));<br><br>pa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);<br><span class="hljs-keyword">if</span> (pa == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br><span class="hljs-keyword">if</span> (ac-&gt;ac_b_ex.fe_len &lt; ac-&gt;ac_g_ex.fe_len) &#123;<br><span class="hljs-type">int</span> winl;<br><span class="hljs-type">int</span> wins;<br><span class="hljs-type">int</span> win;<br><span class="hljs-type">int</span> offs;<br><br><span class="hljs-comment">/* we can&#x27;t allocate as much as normalizer wants.</span><br><span class="hljs-comment"> * so, found space must get proper lstart</span><br><span class="hljs-comment"> * to cover original request */</span><br>BUG_ON(ac-&gt;ac_g_ex.fe_logical &gt; ac-&gt;ac_o_ex.fe_logical);<br>BUG_ON(ac-&gt;ac_g_ex.fe_len &lt; ac-&gt;ac_o_ex.fe_len);<br><br><span class="hljs-comment">/* we&#x27;re limited by original request in that</span><br><span class="hljs-comment"> * logical block must be covered any way</span><br><span class="hljs-comment"> * winl is window we can move our chunk within */</span><br>winl = ac-&gt;ac_o_ex.fe_logical - ac-&gt;ac_g_ex.fe_logical;<br><br><span class="hljs-comment">/* also, we should cover whole original request */</span><br>wins = EXT4_C2B(sbi, ac-&gt;ac_b_ex.fe_len - ac-&gt;ac_o_ex.fe_len);<br><br><span class="hljs-comment">/* the smallest one defines real window */</span><br>win = min(winl, wins);<br><br>offs = ac-&gt;ac_o_ex.fe_logical %<br>EXT4_C2B(sbi, ac-&gt;ac_b_ex.fe_len);<br><span class="hljs-keyword">if</span> (offs &amp;&amp; offs &lt; win)<br>win = offs;<br><br>ac-&gt;ac_b_ex.fe_logical = ac-&gt;ac_o_ex.fe_logical -<br>EXT4_NUM_B2C(sbi, win);<br>BUG_ON(ac-&gt;ac_o_ex.fe_logical &lt; ac-&gt;ac_b_ex.fe_logical);<br>BUG_ON(ac-&gt;ac_o_ex.fe_len &gt; ac-&gt;ac_b_ex.fe_len);<br>&#125;<br><br><span class="hljs-comment">/* preallocation can change ac_b_ex, thus we store actually</span><br><span class="hljs-comment"> * allocated blocks for history */</span><br>ac-&gt;ac_f_ex = ac-&gt;ac_b_ex; <span class="hljs-comment">// 还是先将ac_b_ex拷贝到ac_f_ex</span><br><br>pa-&gt;pa_lstart = ac-&gt;ac_b_ex.fe_logical;<br>pa-&gt;pa_pstart = ext4_grp_offs_to_block(sb, &amp;ac-&gt;ac_b_ex);<br>pa-&gt;pa_len = ac-&gt;ac_b_ex.fe_len;<br>pa-&gt;pa_free = pa-&gt;pa_len;<br><span class="hljs-type">atomic_set</span>(&amp;pa-&gt;pa_count, <span class="hljs-number">1</span>);<br>spin_lock_init(&amp;pa-&gt;pa_lock);<br>INIT_LIST_HEAD(&amp;pa-&gt;pa_inode_list);<br>INIT_LIST_HEAD(&amp;pa-&gt;pa_group_list);<br>pa-&gt;pa_deleted = <span class="hljs-number">0</span>;<br>pa-&gt;pa_type = MB_INODE_PA;<br><br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;new inode pa %p: %llu/%u for %u\n&quot;</span>, pa,<br>pa-&gt;pa_pstart, pa-&gt;pa_len, pa-&gt;pa_lstart);<br>trace_ext4_mb_new_inode_pa(ac, pa);<br><span class="hljs-comment">// 同样的也会走ext4_mb_release_context()流程</span><br>ext4_mb_use_inode_pa(ac, pa);<br><span class="hljs-type">atomic_add</span>(pa-&gt;pa_free, &amp;sbi-&gt;s_mb_preallocated);<br><br>ei = EXT4_I(ac-&gt;ac_inode);<br>grp = ext4_get_group_info(sb, ac-&gt;ac_b_ex.fe_group);<br><br>pa-&gt;pa_obj_lock = &amp;ei-&gt;i_prealloc_lock;<br>pa-&gt;pa_inode = ac-&gt;ac_inode;<br><span class="hljs-comment">// 加入到block group的链表下</span><br>ext4_lock_group(sb, ac-&gt;ac_b_ex.fe_group);<br>list_add(&amp;pa-&gt;pa_group_list, &amp;grp-&gt;bb_prealloc_list);<br>ext4_unlock_group(sb, ac-&gt;ac_b_ex.fe_group);<br><span class="hljs-comment">// 加入到ext4_inode_info的i_prealloc_list链表下，供后续大文件的预分配</span><br>spin_lock(pa-&gt;pa_obj_lock);<br>list_add_rcu(&amp;pa-&gt;pa_inode_list, &amp;ei-&gt;i_prealloc_list);<br>spin_unlock(pa-&gt;pa_obj_lock);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述流程分析可以看出per_cpu locality group的预分配方式的预分配空间是文件系统全局的，这样可以使得小文件都聚集在一起，而per inode的预分配方式是针对单个文件的，使得文件所占的物理空间尽量挨在一起。</p><h3 id="mballoc多块分配-1"><a href="#mballoc多块分配-1" class="headerlink" title="mballoc多块分配"></a>mballoc多块分配</h3><p>在开始分析ext4_mb_regular_allocator()的多块分配流程之前，我们先来分析多块分配所采用的buddy系统的数据结构和初始化流程。</p><p>buddy系统将block group内的空闲空间按照其长度的阶进行分组，分组的长度为2^0到2^13次方，一个block group通常有32768个block，因此最多可以划分成4个2^13和32768个2^0，其他的阶以此类推。</p><p>查看&#x2F;proc&#x2F;fs&#x2F;ext4&#x2F;<partition>&#x2F;mb_groups可以看到当前所有block group的空闲空间分组情况：</p><p><img src="/assets/image-20210926201914119.png" alt="image-20210926201914119"></p><p>struct ext4_buddy结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_buddy</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">bd_buddy_page</span>;</span> <span class="hljs-comment">// buddy系统有一个4k大小的bitmap来表示block group内的空间使用情况，而这个bitmap是由页缓存来管理的，这里就是bitmap所在的页</span><br><span class="hljs-type">void</span> *bd_buddy; <span class="hljs-comment">// 指向页里面具体的buddy的bitmap</span><br>    <span class="hljs-comment">// buddy的bitmap是根据block group内的block bitmap构建而成的，这里是对应的block bitmap</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">bd_bitmap_page</span>;</span> <br><span class="hljs-type">void</span> *bd_bitmap;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">bd_info</span>;</span> <span class="hljs-comment">// block group的信息</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">bd_sb</span>;</span><br>__u16 bd_blkbits; <span class="hljs-comment">// 在load buddy的时候初始化为super_block的s_blocksize_bits，通常为12</span><br><span class="hljs-type">ext4_group_t</span> bd_group;<br>&#125;;<br></code></pre></td></tr></table></figure><p>buddy系统的bitmap是由页缓存来管理的，而这个页缓存必须是整个文件系统范围内的，因此ext4在ext4_sb_info结构里面用一个inode结构体来管理buddy的页缓存，字段名为s_buddy_cache。我们通过分析buddy系统的初始化流程来深入理解其构造：</p><p>ext4调用ext4_mb_init_group()函数对buddy系统进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_init_group</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">ext4_group_t</span> group, <span class="hljs-type">gfp_t</span> gfp)</span><br>&#123;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">this_grp</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_buddy</span> <span class="hljs-title">e4b</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>might_sleep();<br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;init group %u\n&quot;</span>, group);<br>this_grp = ext4_get_group_info(sb, group);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This ensures that we don&#x27;t reinit the buddy cache</span><br><span class="hljs-comment"> * page which map to the group from which we are already</span><br><span class="hljs-comment"> * allocating. If we are looking at the buddy cache we would</span><br><span class="hljs-comment"> * have taken a reference using ext4_mb_load_buddy and that</span><br><span class="hljs-comment"> * would have pinned buddy page to page cache.</span><br><span class="hljs-comment"> * The call to ext4_mb_get_buddy_page_lock will mark the</span><br><span class="hljs-comment"> * page accessed.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 申请buddy系统的页</span><br>ret = ext4_mb_get_buddy_page_lock(sb, group, &amp;e4b, gfp);<br><span class="hljs-keyword">if</span> (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * somebody initialized the group</span><br><span class="hljs-comment"> * return without doing anything</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">goto</span> err;<br>&#125;<br><br>page = e4b.bd_bitmap_page;<br>    <span class="hljs-comment">// 负责读取磁盘，并且初始化block bitmap</span><br>ret = ext4_mb_init_cache(page, <span class="hljs-literal">NULL</span>, gfp); <br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> err;<br><span class="hljs-keyword">if</span> (!PageUptodate(page)) &#123;<br>ret = -EIO;<br><span class="hljs-keyword">goto</span> err;<br>&#125;<br><br><span class="hljs-keyword">if</span> (e4b.bd_buddy_page == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If both the bitmap and buddy are in</span><br><span class="hljs-comment"> * the same page we don&#x27;t need to force</span><br><span class="hljs-comment"> * init the buddy</span><br><span class="hljs-comment"> */</span><br>ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">goto</span> err;<br>&#125;<br><span class="hljs-comment">// 初始化buddy bit map</span><br>page = e4b.bd_buddy_page;<br>ret = ext4_mb_init_cache(page, e4b.bd_bitmap, gfp);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> err;<br><span class="hljs-keyword">if</span> (!PageUptodate(page)) &#123;<br>ret = -EIO;<br><span class="hljs-keyword">goto</span> err;<br>&#125;<br>err:<br>ext4_mb_put_buddy_page_lock(&amp;e4b);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_get_buddy_page_lock()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_get_buddy_page_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params"><span class="hljs-type">ext4_group_t</span> group, <span class="hljs-keyword">struct</span> ext4_buddy *e4b, <span class="hljs-type">gfp_t</span> gfp)</span><br>&#123;<br><span class="hljs-comment">// 所有buddy的内存内容都是由s_buddy_cache管理</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> EXT4_SB(sb)-&gt;s_buddy_cache;<br><span class="hljs-type">int</span> block, pnum, poff;<br><span class="hljs-type">int</span> blocks_per_page;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br>e4b-&gt;bd_buddy_page = <span class="hljs-literal">NULL</span>;<br>e4b-&gt;bd_bitmap_page = <span class="hljs-literal">NULL</span>;<br><br>blocks_per_page = PAGE_SIZE / sb-&gt;s_blocksize; <span class="hljs-comment">// 假定块大小为4k，则blocks_per_page为1</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    在s_buddy_cache的页缓存里，page的index为偶数的时候代表这个page里面装的是block group的block bitmap，为奇数的时候page里面装的是buddy bitmap，也叫buddy cache，也就是说0、2、4、6、8...为block bit map的page，每个block bitmap page紧挨着的1、3、5、7、9..为buddy bitmap page，依次对应的block group的编号为0、1、2、3、4...</span><br><span class="hljs-comment">    */</span><br>block = group * <span class="hljs-number">2</span>;<br>pnum = block / blocks_per_page; <span class="hljs-comment">// 就是block</span><br>poff = block % blocks_per_page; <span class="hljs-comment">// 0</span><br>    <span class="hljs-comment">// 找到或者创建page来存储block bitmap</span><br>page = find_or_create_page(inode-&gt;i_mapping, pnum, gfp);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>BUG_ON(page-&gt;mapping != inode-&gt;i_mapping);<br>e4b-&gt;bd_bitmap_page = page;<br>    <span class="hljs-comment">// 通常这里就是page的首地址</span><br>e4b-&gt;bd_bitmap = page_address(page) + (poff * sb-&gt;s_blocksize);<br><br><span class="hljs-keyword">if</span> (blocks_per_page &gt;= <span class="hljs-number">2</span>) &#123;<br><span class="hljs-comment">/* buddy and bitmap are on the same page */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>block++; <span class="hljs-comment">// 获取到buddy_page，buddy bitmap的page排在block bitmap page的后面</span><br>pnum = block / blocks_per_page;<br>page = find_or_create_page(inode-&gt;i_mapping, pnum, gfp);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>BUG_ON(page-&gt;mapping != inode-&gt;i_mapping);<br>e4b-&gt;bd_buddy_page = page;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_init_cache()函数，ext4_mb_init_group()函数会调用两次这个函数，区别是第一次调时incore为空，为的是初始化block bitmap；第二次调用时，incore传入的是bd_bitmap，用block bitmap来初始化buddy bitmap。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_init_cache</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">char</span> *incore, <span class="hljs-type">gfp_t</span> gfp)</span><br>&#123;<br><span class="hljs-type">ext4_group_t</span> ngroups;<br><span class="hljs-type">int</span> blocksize;<br><span class="hljs-type">int</span> blocks_per_page;<br><span class="hljs-type">int</span> groups_per_page;<br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">ext4_group_t</span> first_group, group;<br><span class="hljs-type">int</span> first_block;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> *<span class="hljs-title">bhs</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> **<span class="hljs-title">bh</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span>;</span><br><span class="hljs-type">char</span> *data;<br><span class="hljs-type">char</span> *bitmap;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grinfo</span>;</span><br><br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;init page %lu\n&quot;</span>, page-&gt;index);<br><br>inode = page-&gt;mapping-&gt;host;<br>sb = inode-&gt;i_sb;<br>ngroups = ext4_get_groups_count(sb);<br>blocksize = i_blocksize(inode);<br>blocks_per_page = PAGE_SIZE / blocksize;<br><br>    <span class="hljs-comment">// 通常情况下blocks_per_page为1，这里groups_per_page的最终结果为1</span><br>groups_per_page = blocks_per_page &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (groups_per_page == <span class="hljs-number">0</span>)<br>groups_per_page = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/* allocate buffer_heads to read bitmaps */</span><br><span class="hljs-keyword">if</span> (groups_per_page &gt; <span class="hljs-number">1</span>) &#123;<br>i = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> buffer_head *) * groups_per_page;<br>bh = kzalloc(i, gfp);<br><span class="hljs-keyword">if</span> (bh == <span class="hljs-literal">NULL</span>) &#123;<br>err = -ENOMEM;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span><br>bh = &amp;bhs;<br><br>first_group = page-&gt;index * blocks_per_page / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">/* read all groups the page covers into the cache */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, group = first_group; i &lt; groups_per_page; i++, group++) &#123;<br><span class="hljs-keyword">if</span> (group &gt;= ngroups)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// block group信息以二维数组的形式存在ext4_sb_info里面的，</span><br>        <span class="hljs-comment">// 二维数组一行64个，通过对64取商能找到其在第几行，通过对64取余能找到在第几列</span><br>grinfo = ext4_get_group_info(sb, group);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If page is uptodate then we came here after online resize</span><br><span class="hljs-comment"> * which added some new uninitialized group info structs, so</span><br><span class="hljs-comment"> * we must skip all initialized uptodate buddies on the page,</span><br><span class="hljs-comment"> * which may be currently in use by an allocating task.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (PageUptodate(page) &amp;&amp; !EXT4_MB_GRP_NEED_INIT(grinfo)) &#123;<br>bh[i] = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <span class="hljs-comment">// 发送读IO去读取block bitmap</span><br>        <span class="hljs-comment">// 通过block group的编号能够拿到block group在磁盘上的描述ext4_group_desc，通过ext4_group_desc能够拿到block group的block bitmap在哪个block，然后通过在super_block里面的页缓存获取到block bitmap的具体内容</span><br>        <span class="hljs-comment">// 在super_block里面的页缓存是针对文件系统的元素据的缓存，而在inode里面的缓存是文件的数据的页缓存</span><br>bh[i] = ext4_read_block_bitmap_nowait(sb, group);<br><span class="hljs-keyword">if</span> (IS_ERR(bh[i])) &#123;<br>err = PTR_ERR(bh[i]);<br>bh[i] = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;read bitmap for group %u\n&quot;</span>, group);<br>&#125;<br><br><span class="hljs-comment">// 等待读block bitmap的IO完成</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, group = first_group; i &lt; groups_per_page; i++, group++) &#123;<br><span class="hljs-type">int</span> err2;<br><br><span class="hljs-keyword">if</span> (!bh[i])<br><span class="hljs-keyword">continue</span>;<br>err2 = ext4_wait_block_bitmap(sb, group, bh[i]);<br><span class="hljs-keyword">if</span> (!err)<br>err = err2;<br>&#125;<br><br>first_block = page-&gt;index * blocks_per_page; <span class="hljs-comment">// 这个页里面的第一个block</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; blocks_per_page; i++) &#123;<br>group = (first_block + i) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 除以2，得到block group号</span><br><span class="hljs-keyword">if</span> (group &gt;= ngroups)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">if</span> (!bh[group - first_group])<br><span class="hljs-comment">/* skip initialized uptodate buddy */</span><br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span> (!buffer_verified(bh[group - first_group]))<br><span class="hljs-comment">/* Skip faulty bitmaps */</span><br><span class="hljs-keyword">continue</span>;<br>err = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * data carry information regarding this</span><br><span class="hljs-comment"> * particular group in the format specified</span><br><span class="hljs-comment"> * above</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br>data = page_address(page) + (i * blocksize);<br>bitmap = bh[group - first_group]-&gt;b_data;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We place the buddy block and bitmap block</span><br><span class="hljs-comment"> * close together</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((first_block + i) &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 奇数则为buddy bitmap</span><br><span class="hljs-comment">/* this is block of buddy */</span><br>BUG_ON(incore == <span class="hljs-literal">NULL</span>);<br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;put buddy for group %u in page %lu/%x\n&quot;</span>,<br>group, page-&gt;index, i * blocksize);<br>trace_ext4_mb_buddy_bitmap_load(sb, group);<br>grinfo = ext4_get_group_info(sb, group);<br>grinfo-&gt;bb_fragments = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(grinfo-&gt;bb_counters, <span class="hljs-number">0</span>,<br>       <span class="hljs-keyword">sizeof</span>(*grinfo-&gt;bb_counters) *<br>(sb-&gt;s_blocksize_bits+<span class="hljs-number">2</span>)); <span class="hljs-comment">// 0 到 13 一共14个</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * incore got set to the group block bitmap below</span><br><span class="hljs-comment"> */</span><br>ext4_lock_group(sb, group);<br><span class="hljs-comment">/* init the buddy */</span><br><span class="hljs-built_in">memset</span>(data, <span class="hljs-number">0xff</span>, blocksize); <span class="hljs-comment">// 先把buddy page全部置成1，有空闲的则清为0</span><br><span class="hljs-comment">// 初始化buddy重点这个函数</span><br>ext4_mb_generate_buddy(sb, data, incore, group);<br>ext4_unlock_group(sb, group);<br>incore = <span class="hljs-literal">NULL</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 偶数为block bitmap</span><br><span class="hljs-comment">/* this is block of bitmap */</span><br>BUG_ON(incore != <span class="hljs-literal">NULL</span>);<br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;put bitmap for group %u in page %lu/%x\n&quot;</span>,<br>group, page-&gt;index, i * blocksize);<br>trace_ext4_mb_bitmap_load(sb, group);<br><br><span class="hljs-comment">/* see comments in ext4_mb_put_pa() */</span><br>ext4_lock_group(sb, group);<br>            <span class="hljs-comment">// 将读上来的block bitmap拷贝到buddy系统的页缓存里面</span><br><span class="hljs-built_in">memcpy</span>(data, bitmap, blocksize); <br><br><span class="hljs-comment">/* mark all preallocated blks used in in-core bitmap */</span><br>ext4_mb_generate_from_pa(sb, data, group);<br>ext4_mb_generate_from_freelist(sb, data, group);<br>ext4_unlock_group(sb, group);<br><br><span class="hljs-comment">/* set incore so that the buddy information can be</span><br><span class="hljs-comment"> * generated using this</span><br><span class="hljs-comment"> */</span><br>incore = data;<br>&#125;<br>&#125;<br>SetPageUptodate(page);<br><br>out:<br><span class="hljs-keyword">if</span> (bh) &#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; groups_per_page; i++)<br>brelse(bh[i]);<br><span class="hljs-keyword">if</span> (bh != &amp;bhs)<br>kfree(bh);<br>&#125;<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>在读取了block bitmap后将其拷贝到buddy系统的页缓存里面，此后还要调用两个函数来做一些标记：</p><p>1）ext4_mb_generate_from_pa()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_generate_from_pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *bitmap,</span><br><span class="hljs-params"><span class="hljs-type">ext4_group_t</span> group)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span> =</span> ext4_get_group_info(sb, group);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_prealloc_space</span> *<span class="hljs-title">pa</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">cur</span>;</span><br><span class="hljs-type">ext4_group_t</span> groupnr;<br><span class="hljs-type">ext4_grpblk_t</span> start;<br><span class="hljs-type">int</span> preallocated = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> len;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">遍历所有该block group下的预分配空间，将预分配空间的范围标记到block bitmap里面</span><br><span class="hljs-comment">*/</span><br>list_for_each(cur, &amp;grp-&gt;bb_prealloc_list) &#123;<br>pa = list_entry(cur, <span class="hljs-keyword">struct</span> ext4_prealloc_space, pa_group_list);<br>spin_lock(&amp;pa-&gt;pa_lock);<br>ext4_get_group_no_and_offset(sb, pa-&gt;pa_pstart,<br>     &amp;groupnr, &amp;start);<br>len = pa-&gt;pa_len;<br>spin_unlock(&amp;pa-&gt;pa_lock);<br><span class="hljs-keyword">if</span> (unlikely(len == <span class="hljs-number">0</span>))<br><span class="hljs-keyword">continue</span>;<br>BUG_ON(groupnr != group);<br>ext4_set_bits(bitmap, start, len);<br>preallocated += len;<br>&#125;<br>    <br>mb_debug(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;preallocated %u for group %u\n&quot;</span>, preallocated, group);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2）ext4_mb_generate_from_freelist()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_generate_from_freelist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *bitmap,</span><br><span class="hljs-params"><span class="hljs-type">ext4_group_t</span> group)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">n</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_data</span> *<span class="hljs-title">entry</span>;</span><br><br>grp = ext4_get_group_info(sb, group);<br>n = rb_first(&amp;(grp-&gt;bb_free_root));<br><span class="hljs-comment">// 遍历block group的bb_free_root红黑树，将空间范围标记到block bitmap里面</span><br><span class="hljs-keyword">while</span> (n) &#123;<br>entry = rb_entry(n, <span class="hljs-keyword">struct</span> ext4_free_data, efd_node);<br>ext4_set_bits(bitmap, entry-&gt;efd_start_cluster, entry-&gt;efd_count);<br>n = rb_next(n);<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化buddy bitmap：</p><p>struct ext4_group_info结构体，用于描述block group在内存中的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   bb_state;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span>  <span class="hljs-title">bb_free_root</span>;</span> <span class="hljs-comment">// 挂ext4_free_data的红黑树</span><br><span class="hljs-type">ext4_grpblk_t</span>bb_first_free;<span class="hljs-comment">// 第一个是空闲的块</span><br><span class="hljs-type">ext4_grpblk_t</span>bb_free;<span class="hljs-comment">// 总的空间块个数</span><br><span class="hljs-type">ext4_grpblk_t</span>bb_fragments;<span class="hljs-comment">// 连续的空闲空间段数目</span><br><span class="hljs-type">ext4_grpblk_t</span>bb_largest_free_order; <span class="hljs-comment">// block group中最大的空闲空间的阶</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span>          <span class="hljs-title">list_head</span> <span class="hljs-title">bb_prealloc_list</span>;</span> <span class="hljs-comment">// 挂ext4_prealloc_space</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DOUBLE_CHECK</span><br><span class="hljs-type">void</span>            *bb_bitmap;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span> <span class="hljs-title">alloc_sem</span>;</span><br><span class="hljs-type">ext4_grpblk_t</span>bb_counters[];<span class="hljs-comment">// 用一个0长数组记录每个阶的空闲空间有多少个</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>初始化buddy bitmap需要知道这到底是个什么，它跟block bitmap的关系是什么：</p><p>通常情况下block bitmap和buddy bitmap的大小都是4k，对于block bitmap来说，4k的空间有32768个bit位，而每一个bit位代表一个block块(4k）的使用情况(1为占用，0为空闲)，因此能表示128M的空间。</p><p>buddy bitmap首先拿出这32768个bit位的前一半，也就是0-16383，这些bit位每一个bit位表示连续的两个(2^1)block的空闲情况；然后再从剩下的一半bit中拿出一半的bit来表示连续4个(2^2)block的使用情况；接着再从剩下的一半bit位里面拿出一半来表示连续8个(2^3)block的使用情况……依次类推，最终可以表示4个2^13个block的使用情况。</p><p>![buddy bitmap](assets&#x2F;buddy bitmap.jpg)</p><p>举个例子，在初始化的时候，buddy系统通过block bitmap发现有连续的14个空间是连续的，并假设其地址为0-13(相对于block group的第一个block而言的)，此时流程会将这个14个block按照阶划分为8+4+2，即分到3阶、2阶和1阶，对应在buddy bitmap的bit位里面（借用一张其他人画的图）：</p><p><img src="/assets/image-20210919211523460.png" alt="image-20210919211523460"></p><p>由图可见，buddy bitmap里面不仅仅包含了block的使用情况信息，而且还包含了block的位置信息(划分到1阶的那两个block的偏移为12-13，bitmap里面的第7个bit位为0)。此外，我们还可以看出当高阶为0时所有的低阶都为1，这是初始化的结果。</p><p>那么有的同学会问了，当只有一个block是连续的空闲空间时怎么表示呢？</p><p>当空闲空间只有一个block时，buddy系统将其记录在ext4_group_info的bb_counters[0]里面。</p><p>ext4_mb_init_cache()函数的第114到133行：</p><p>首先获取ext4_group_info准备初始化，将bb_fragments和bb_counters都置为0，后续会增加这两个值，接着第129行将buddy bitmap全部置1，当后续遍历block bitmap时划分了阶再置相应的bit为0，最后调用ext4_mb_generate_buddy()函数根据block bitmap初始化buddy bitmap：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_generate_buddy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params"><span class="hljs-type">void</span> *buddy, <span class="hljs-type">void</span> *bitmap, <span class="hljs-type">ext4_group_t</span> group)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span> =</span> ext4_get_group_info(sb, group);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br><span class="hljs-type">ext4_grpblk_t</span> max = EXT4_CLUSTERS_PER_GROUP(sb); <span class="hljs-comment">// max为每个group的cluster数量</span><br><span class="hljs-type">ext4_grpblk_t</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">ext4_grpblk_t</span> first;<br><span class="hljs-type">ext4_grpblk_t</span> len;<br><span class="hljs-type">unsigned</span> <span class="hljs-built_in">free</span> = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> fragments = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> period = get_cycles();<br><br><span class="hljs-comment">/* initialize buddy from bitmap which is aggregation</span><br><span class="hljs-comment"> * of on-disk bitmap and preallocations */</span><br>i = mb_find_next_zero_bit(bitmap, max, <span class="hljs-number">0</span>); <span class="hljs-comment">// 找到bitmap里面第一个0，也就是第一个空闲block的位置</span><br>grp-&gt;bb_first_free = i;<br><span class="hljs-keyword">while</span> (i &lt; max) &#123;<br>fragments++;<br>first = i;<br>        <span class="hljs-comment">// 找到从i开始的下一个1的位置，从i到这个位置就是这一段空闲空间的长度（i - first）</span><br>i = mb_find_next_bit(bitmap, max, i);<br>len = i - first;<br><span class="hljs-built_in">free</span> += len; <span class="hljs-comment">// 记录总的空闲空间的长度</span><br><span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 如果长度大于1则去划分阶，然后记录到buddy bitmap和bb_counters</span><br>ext4_mb_mark_free_simple(sb, buddy, first, len, grp);<br><span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 如果长度为1则记录到bb_counters中即可</span><br>grp-&gt;bb_counters[<span class="hljs-number">0</span>]++;<br>        <span class="hljs-comment">// 继续寻找下一段空闲空间</span><br><span class="hljs-keyword">if</span> (i &lt; max)<br>i = mb_find_next_zero_bit(bitmap, max, i);<br>&#125;<br>grp-&gt;bb_fragments = fragments; <span class="hljs-comment">// 碎片数</span><br><br>.......<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_mark_free_simple()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_mark_free_simple</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params"><span class="hljs-type">void</span> *buddy, <span class="hljs-type">ext4_grpblk_t</span> first, <span class="hljs-type">ext4_grpblk_t</span> len,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_group_info *grp)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br><span class="hljs-type">ext4_grpblk_t</span> min;<br><span class="hljs-type">ext4_grpblk_t</span> max;<br><span class="hljs-type">ext4_grpblk_t</span> chunk;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> border;<br><br>BUG_ON(len &gt; EXT4_CLUSTERS_PER_GROUP(sb));<br><br>border = <span class="hljs-number">2</span> &lt;&lt; sb-&gt;s_blocksize_bits; <span class="hljs-comment">// 8192即2^13次方, 32M的空间</span><br><br><span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 将长度进行拆分，比如长度为14会拆分成8+4+2</span><br><span class="hljs-comment">/* find how many blocks can be covered since this position */</span><br><span class="hljs-comment">// ffs为find first set，转换成二进制之后从右往左的第一个1的位置</span><br>max = ffs(first | border) - <span class="hljs-number">1</span>;<br><br> <span class="hljs-comment">// find last set，转换成二进制之后从右往左的最后一个1的位置</span><br>min = fls(len) - <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (max &lt; min)<br>min = max;<br>chunk = <span class="hljs-number">1</span> &lt;&lt; min;<br><br><span class="hljs-comment">// 往bb_counters记录计数</span><br>grp-&gt;bb_counters[min]++;<br><span class="hljs-keyword">if</span> (min &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 将buddy bitmap里面的相应的bit位置0</span><br>            <span class="hljs-comment">// buddy + sbi-&gt;s_mb_offsets[min]的意思是找到对应阶的bit位的起始位置</span><br>            <span class="hljs-comment">// 例如1阶的起始位置是0，二阶的起始位置是16384......</span><br>mb_clear_bit(first &gt;&gt; min,<br>     buddy + sbi-&gt;s_mb_offsets[min]);<br><br>len -= chunk;<br>first += chunk;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此位置buddy bitmap和相关的计数就已经完成了，可以进行多块分配动作，让我们回到ext4_mb_regular_allocator()函数，这个函数太长，我们还是分成两个部分来分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_regular_allocator</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br><span class="hljs-type">ext4_group_t</span> ngroups, group, i;<br><span class="hljs-type">int</span> cr;<br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>, first_err = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_buddy</span> <span class="hljs-title">e4b</span>;</span><br><br>sb = ac-&gt;ac_sb;<br>sbi = EXT4_SB(sb);<br>ngroups = ext4_get_groups_count(sb); <span class="hljs-comment">// 文件系统的block group个数</span><br><span class="hljs-comment">/* non-extent files are limited to low blocks/groups */</span><br><span class="hljs-keyword">if</span> (!(ext4_test_inode_flag(ac-&gt;ac_inode, EXT4_INODE_EXTENTS)))<br>ngroups = sbi-&gt;s_blockfile_groups;<br><br>BUG_ON(ac-&gt;ac_status == AC_STATUS_FOUND);<br><br><span class="hljs-comment">// 先尝试在goal的地方能不能分配</span><br>err = ext4_mb_find_by_goal(ac, &amp;e4b);<br><span class="hljs-keyword">if</span> (err || ac-&gt;ac_status == AC_STATUS_FOUND)<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-keyword">if</span> (unlikely(ac-&gt;ac_flags &amp; EXT4_MB_HINT_GOAL_ONLY))<br><span class="hljs-keyword">goto</span> out;<br><br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_find_by_goal()函数，从goal的位置尝试进行分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_find_by_goal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br><span class="hljs-type">ext4_group_t</span> group = ac-&gt;ac_g_ex.fe_group;<br><span class="hljs-type">int</span> max;<br><span class="hljs-type">int</span> err;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(ac-&gt;ac_sb);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span> =</span> ext4_get_group_info(ac-&gt;ac_sb, group);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ex</span>;</span><br><br><span class="hljs-keyword">if</span> (!(ac-&gt;ac_flags &amp; EXT4_MB_HINT_TRY_GOAL))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (grp-&gt;bb_free == <span class="hljs-number">0</span>) <span class="hljs-comment">// block group已经没有空闲空间了，直接返回</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 初始化buddy bitmap，详细见上面</span><br>err = ext4_mb_load_buddy(ac-&gt;ac_sb, group, e4b);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><br><span class="hljs-keyword">if</span> (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b-&gt;bd_info))) &#123;<br>ext4_mb_unload_buddy(e4b);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>ext4_lock_group(ac-&gt;ac_sb, group);<br><br>    <span class="hljs-comment">// 根据buddy bitmap寻找合适的空闲空间</span><br>max = mb_find_extent(e4b, ac-&gt;ac_g_ex.fe_start, <span class="hljs-comment">// start为在group内的偏移</span><br>     ac-&gt;ac_g_ex.fe_len, &amp;ex);<br>ex.fe_logical = <span class="hljs-number">0xDEADFA11</span>; <span class="hljs-comment">/* debug value */</span><br><br>    <span class="hljs-comment">// 这个分支是ext4文件系统对raid的优化，当分配的起始地址和长度都对齐到stripe时才分配</span><br><span class="hljs-keyword">if</span> (max &gt;= ac-&gt;ac_g_ex.fe_len &amp;&amp; ac-&gt;ac_g_ex.fe_len == sbi-&gt;s_stripe) &#123;<br><span class="hljs-type">ext4_fsblk_t</span> start;<br><br>start = ext4_group_first_block_no(ac-&gt;ac_sb, e4b-&gt;bd_group) +<br>ex.fe_start;<br><span class="hljs-comment">/* use do_div to get remainder (would be 64-bit modulo) */</span><br><span class="hljs-keyword">if</span> (do_div(start, sbi-&gt;s_stripe) == <span class="hljs-number">0</span>) &#123;<br>ac-&gt;ac_found++;<br>ac-&gt;ac_b_ex = ex;<br>ext4_mb_use_best_found(ac, e4b);<br>&#125;<br>    <span class="hljs-comment">// 分配成功</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max &gt;= ac-&gt;ac_g_ex.fe_len) &#123;<br>BUG_ON(ex.fe_len &lt;= <span class="hljs-number">0</span>);<br>BUG_ON(ex.fe_group != ac-&gt;ac_g_ex.fe_group);<br>BUG_ON(ex.fe_start != ac-&gt;ac_g_ex.fe_start);<br>ac-&gt;ac_found++;<br>ac-&gt;ac_b_ex = ex;<br>ext4_mb_use_best_found(ac, e4b);<br>    <span class="hljs-comment">// 调用者只是想合并某些小的空闲空间，这就是其他流程了</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max &gt; <span class="hljs-number">0</span> &amp;&amp; (ac-&gt;ac_flags &amp; EXT4_MB_HINT_MERGE)) &#123;<br><span class="hljs-comment">/* Sometimes, caller may want to merge even small</span><br><span class="hljs-comment"> * number of blocks to an existing extent */</span><br>BUG_ON(ex.fe_len &lt;= <span class="hljs-number">0</span>);<br>BUG_ON(ex.fe_group != ac-&gt;ac_g_ex.fe_group);<br>BUG_ON(ex.fe_start != ac-&gt;ac_g_ex.fe_start);<br>ac-&gt;ac_found++;<br>ac-&gt;ac_b_ex = ex;<br>ext4_mb_use_best_found(ac, e4b);<br>&#125;<br>ext4_unlock_group(ac-&gt;ac_sb, group);<br>ext4_mb_unload_buddy(e4b);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>mb_find_extent()函数，分配的核心函数，根据buddy bitmap进行分配动作，传入的block和needed都是以cluster为单位的，分别表示起始和长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mb_find_extent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_buddy *e4b, <span class="hljs-type">int</span> block, </span><br><span class="hljs-params"><span class="hljs-type">int</span> needed, <span class="hljs-keyword">struct</span> ext4_free_extent *ex)</span><br>&#123;<br><span class="hljs-type">int</span> next = block;<br><span class="hljs-type">int</span> max, order;<br><span class="hljs-type">void</span> *buddy;<br><br>assert_spin_locked(ext4_group_lock_ptr(e4b-&gt;bd_sb, e4b-&gt;bd_group));<br>BUG_ON(ex == <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// max表示传入的阶能够遍历多少个bit位</span><br>    <span class="hljs-comment">// 例如0阶可以遍历整个block bitmap，此时max为32768</span><br>    <span class="hljs-comment">// 1阶就必须遍历buddy bitmap的前半段，max为16384</span><br>    <span class="hljs-comment">// 2阶max为8192</span><br>    <span class="hljs-comment">// 3阶......</span><br>buddy = mb_find_buddy(e4b, <span class="hljs-number">0</span>, &amp;max); <br>BUG_ON(buddy == <span class="hljs-literal">NULL</span>);<br>BUG_ON(block &gt;= max);<br><span class="hljs-keyword">if</span> (mb_test_bit(block, buddy)) &#123; <span class="hljs-comment">// 起始位置已经被分配了</span><br>ex-&gt;fe_len = <span class="hljs-number">0</span>;<br>ex-&gt;fe_start = <span class="hljs-number">0</span>;<br>ex-&gt;fe_group = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 注意这里的block是起始位置，不是长度</span><br>    <span class="hljs-comment">// order表示的是从block位置开始的最长空闲空闲长度的阶</span><br>order = mb_find_order_for_block(e4b, block);<br>block = block &gt;&gt; order; <span class="hljs-comment">// 将起始位置对齐到order</span><br><br>    <span class="hljs-comment">// fe_len表示已经分配到的长度，当前是假设分配了这么多</span><br>ex-&gt;fe_len = <span class="hljs-number">1</span> &lt;&lt; order;<br>    <span class="hljs-comment">// 暂时将fe_start与当前的阶对齐</span><br>ex-&gt;fe_start = block &lt;&lt; order;<br>ex-&gt;fe_group = e4b-&gt;bd_group; <br><br><span class="hljs-comment">/* calc difference from given start */</span><br>next = next - ex-&gt;fe_start; <span class="hljs-comment">//原始为起始位置减去当前阶的起始位置表示&quot;多分配了&quot;多少个block</span><br>    <span class="hljs-comment">// 与阶对齐的分配长度减去多分配的block就是实际分配到的长度</span><br>ex-&gt;fe_len -= next; <br>ex-&gt;fe_start += next; <span class="hljs-comment">// 起始位置最终又被还原到最初的起始位置了 </span><br><br><span class="hljs-keyword">while</span> (needed &gt; ex-&gt;fe_len &amp;&amp;<br>       mb_find_buddy(e4b, order, &amp;max)) &#123; <br><br><span class="hljs-keyword">if</span> (block + <span class="hljs-number">1</span> &gt;= max)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// 此时的next被赋值为上一次的阶能找到的最长的分配长度后紧接着要从哪里开始分配</span><br>        <span class="hljs-comment">// next与上一次分配的起始位置相差上一次分配的长度</span><br>next = (block + <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; order); <br>        <span class="hljs-comment">// 如果这一次探测的起始位置已经被占用了则结束后续的探测，因为空闲的block已经不连续了</span><br><span class="hljs-keyword">if</span> (mb_test_bit(next, e4b-&gt;bd_bitmap))<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// 从next开始的连续的空闲空间的长度的阶</span><br>order = mb_find_order_for_block(e4b, next); <br><span class="hljs-comment">// 如果申请分配的长度还没有分配完毕则继续往后探测</span><br>block = next &gt;&gt; order; <br>ex-&gt;fe_len += <span class="hljs-number">1</span> &lt;&lt; order; <br>&#125;<br><span class="hljs-comment">// 检查一下</span><br><span class="hljs-keyword">if</span> (ex-&gt;fe_start + ex-&gt;fe_len &gt; (<span class="hljs-number">1</span> &lt;&lt; (e4b-&gt;bd_blkbits + <span class="hljs-number">3</span>))) &#123;<br><span class="hljs-comment">/* Should never happen! (but apparently sometimes does?!?) */</span><br>WARN_ON(<span class="hljs-number">1</span>);<br>ext4_error(e4b-&gt;bd_sb, <span class="hljs-string">&quot;corruption or bug in mb_find_extent &quot;</span><br>   <span class="hljs-string">&quot;block=%d, order=%d needed=%d ex=%u/%d/%d@%u&quot;</span>,<br>   block, order, needed, ex-&gt;fe_group, ex-&gt;fe_start,<br>   ex-&gt;fe_len, ex-&gt;fe_logical);<br>ex-&gt;fe_len = <span class="hljs-number">0</span>;<br>ex-&gt;fe_start = <span class="hljs-number">0</span>;<br>ex-&gt;fe_group = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ex-&gt;fe_len;<br>&#125;<br></code></pre></td></tr></table></figure><p>mb_find_order_for_block()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">block为起始地址，根据buddy bitmap探测从起始位置开始能够分配的最长空闲空间的阶</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mb_find_order_for_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_buddy *e4b, <span class="hljs-type">int</span> block)</span><br>&#123;<br><span class="hljs-type">int</span> order = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> bb_incr = <span class="hljs-number">1</span> &lt;&lt; (e4b-&gt;bd_blkbits - <span class="hljs-number">1</span>); <span class="hljs-comment">// 2048个字节</span><br><span class="hljs-type">void</span> *bb;<br><br>BUG_ON(e4b-&gt;bd_bitmap == e4b-&gt;bd_buddy);<br>BUG_ON(block &gt;= (<span class="hljs-number">1</span> &lt;&lt; (e4b-&gt;bd_blkbits + <span class="hljs-number">3</span>)));<br><br>bb = e4b-&gt;bd_buddy;<br><br><span class="hljs-keyword">while</span> (order &lt;= e4b-&gt;bd_blkbits + <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// order &lt;= 13</span><br>        <span class="hljs-comment">// order等于1时，buddy bitmap的一个bit位表示两个block，因此起始位置要除以2得到的便是这个起始位置对应这buddy bitmap里面的第几个bit位，然后看这个bit位有无被占用</span><br>block = block &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 如果这个bit位没有被占用表示可以分配1 &lt;&lt; order个block</span><br><span class="hljs-keyword">if</span> (!mb_test_bit(block, bb)) &#123;<br><span class="hljs-comment">/* this block is part of buddy of order &#x27;order&#x27; */</span><br><span class="hljs-keyword">return</span> order;<br>&#125;<br>        <span class="hljs-comment">// 如果当前bit位为1，那么有两种情况：</span><br>        <span class="hljs-comment">// 1) 其上阶对应的bit位都为1表示占用，最终会返回order=0</span><br>        <span class="hljs-comment">// 2) 其上阶的某一阶对应的bit位为0表示可用，因此这里向高阶搜索</span><br>bb += bb_incr; <span class="hljs-comment">// order = 1时，这里加的量是2048字节也就是16384个bit位，就找到了第2阶的buddy bitmap的起始位置</span><br>bb_incr &gt;&gt;= <span class="hljs-number">1</span>;<br>order++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>mb_find_extent()函数的第26到59行需要举个例子：</p><p>假设申请从7开始分配，分配9个block：</p><p>1）假设6-7的block是空闲的，0-5的block是占用的，8-15的block是空闲的，那么它构建出来的buddy bitmap如下：</p><p>![buddy bitmap1](assets&#x2F;buddy bitmap1.jpg)</p><ul><li><input disabled="" type="checkbox"> 28行：order的值为1</li><li><input disabled="" type="checkbox"> 29行：block &#x3D; 7 &gt;&gt; 1 &#x3D; 3</li><li><input disabled="" type="checkbox"> 32行：fe_len &#x3D; 1 &lt;&lt; 1 &#x3D; 2</li><li><input disabled="" type="checkbox"> 34行：fe_start &#x3D; 3 &lt;&lt; 1 &#x3D; 6</li><li><input disabled="" type="checkbox"> 38行：next &#x3D; 7 - 6 &#x3D; 1 此时实际应该只分配到了1个block，但却分配到了2个block，多分配了1个block</li><li><input disabled="" type="checkbox"> 40行：fe_len &#x3D; 2 - 1 &#x3D; 1表示当前已经分配到了的block，还剩下8个block需要分配，而且是紧接着的连续的8个。</li><li><input disabled="" type="checkbox"> 41行：fe_start  &#x3D; 6 + 1 &#x3D; 7 start被恢复到原始的起始位置。</li><li><input disabled="" type="checkbox"> 43行-59行：进入while循环，next &#x3D; ( 3 + 1)  * (1 &lt;&lt; 1) &#x3D; 8表示从8开始搜索，此时计算所得的order &#x3D; 3，表示能分配8个block，循环结束。</li></ul><p>2）假设0-7和8-9的空间都是空闲的，那么它构建出来的buddy bitmap如下：</p><p>![buddy bitmap2](assets&#x2F;buddy bitmap2.jpg)</p><ul><li><input disabled="" type="checkbox"> 28行：order的值为3</li><li><input disabled="" type="checkbox"> 29行：block &#x3D; 7 &gt;&gt; 3 &#x3D; 0</li><li><input disabled="" type="checkbox"> 32行：fe_len &#x3D; 1 &lt;&lt; 3 &#x3D; 8</li><li><input disabled="" type="checkbox"> 34行：fe_start &#x3D; 0 &lt;&lt; 3 &#x3D; 0</li><li><input disabled="" type="checkbox"> 38行：next &#x3D; 7 - 0 &#x3D; 7 此时实际应该只分配到了1个block，但却分配到了8个block，多分配了7个block</li><li><input disabled="" type="checkbox"> 40行：fe_len &#x3D; 8 - 7 &#x3D; 1表示当前实际已经分配到了的block，还剩下8个block需要分配，而且是紧接着的连续的8个。</li><li><input disabled="" type="checkbox"> 41行：fe_start  &#x3D; 0 + 7 &#x3D; 7 start被恢复到原始的起始位置。</li><li><input disabled="" type="checkbox"> 43行-59行：进入while循环，next &#x3D; ( 3 + 1)  * (1 &lt;&lt; 1) &#x3D; 8表示从8开始搜索，此时计算所得的order &#x3D; 3，表示能分配8个block，循环结束。</li></ul><p>可以把buddy bitmap当成一棵树来看待，28到41行的代码就是要找到起始位置所在的子树能够申请到多少个block，进入while循环后就是在”紧挨着的子树”上从最底层往上寻找能否分配了。</p><p>如果从goal分配成功会调用函数ext4_mb_use_best_found()置上最终的结果。</p><p>我们回到ext4_mb_regular_allocator()函数，分析一下如果在goal分配失败了会作何策略：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack <span class="hljs-type">int</span><br><span class="hljs-title function_">ext4_mb_regular_allocator</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac)</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">......</span><br><span class="hljs-comment">尝试从goal开始分配</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 找到目标长度的二进制的从右往左数最后一个1的位置，len的order</span><br>i = fls(ac-&gt;ac_g_ex.fe_len);<br>ac-&gt;ac_2order = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">当请求分配的长度的order大于等于s_mb_order2_reqs时，</span><br><span class="hljs-comment">s_mb_order2_reqs可以通过/sys/fs/ext4/&lt;partition&gt;/mb_order2_req配置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (i &gt;= sbi-&gt;s_mb_order2_reqs &amp;&amp; i &lt;= sb-&gt;s_blocksize_bits + <span class="hljs-number">2</span>) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 申请分配的数量刚好是2的N次方</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((ac-&gt;ac_g_ex.fe_len &amp; (~(<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>)))) == <span class="hljs-number">0</span>)<br>ac-&gt;ac_2order = array_index_nospec(i - <span class="hljs-number">1</span>,<br>   sb-&gt;s_blocksize_bits + <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">/* if stream allocation is enabled, use global goal */</span><br><span class="hljs-keyword">if</span> (ac-&gt;ac_flags &amp; EXT4_MB_STREAM_ALLOC) &#123;<br><span class="hljs-comment">/* TBD: may be hot point */</span><br>spin_lock(&amp;sbi-&gt;s_md_lock);<br><span class="hljs-comment">// 从文件系统上一次分配的地方开始分配</span><br>ac-&gt;ac_g_ex.fe_group = sbi-&gt;s_mb_last_group;<br>ac-&gt;ac_g_ex.fe_start = sbi-&gt;s_mb_last_start;<br>spin_unlock(&amp;sbi-&gt;s_md_lock);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">cr表示搜索block group的严苛程度，严苛程度从高到低</span><br><span class="hljs-comment">0是最严苛的程度，详见ext4_mb_good_group()函数</span><br><span class="hljs-comment">*/</span><br>cr = ac-&gt;ac_2order ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br><br>repeat:<br>    <span class="hljs-comment">// 每一轮的严苛程度不一样</span><br><span class="hljs-keyword">for</span> (; cr &lt; <span class="hljs-number">4</span> &amp;&amp; ac-&gt;ac_status == AC_STATUS_CONTINUE; cr++) &#123;<br>ac-&gt;ac_criteria = cr;<br><span class="hljs-comment">// 从goal的那个block group开始搜索，如果遍历到了最后一个block group则转去第一个block group</span><br>group = ac-&gt;ac_g_ex.fe_group;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ngroups; group++, i++) &#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>cond_resched();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Artificially restricted ngroups for non-extent</span><br><span class="hljs-comment"> * files makes group &gt; ngroups possible on first loop.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (group &gt;= ngroups) <span class="hljs-comment">// 回到起始的第一个group看能否分配</span><br>group = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 在不加锁的情况下先检查一下能否分配，如果能则加锁去检查</span><br>ret = ext4_mb_good_group(ac, group, cr);<br><span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (!first_err)<br>first_err = ret;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">// 加载buddy</span><br>err = ext4_mb_load_buddy(sb, group, &amp;e4b);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> out;<br><br>ext4_lock_group(sb, group);<br><br><span class="hljs-comment">// 加载了buddy，加了锁之后再check能否分配</span><br>ret = ext4_mb_good_group(ac, group, cr);<br><span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br>ext4_unlock_group(sb, group);<br>ext4_mb_unload_buddy(&amp;e4b);<br><span class="hljs-keyword">if</span> (!first_err)<br>first_err = ret;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br>ac-&gt;ac_groups_scanned++;<br><span class="hljs-keyword">if</span> (cr == <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 申请分配的长度刚好是2的N次方的时候才会走这里</span><br>ext4_mb_simple_scan_group(ac, &amp;e4b);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cr == <span class="hljs-number">1</span> &amp;&amp; sbi-&gt;s_stripe &amp;&amp;<br>!(ac-&gt;ac_g_ex.fe_len % sbi-&gt;s_stripe)) <span class="hljs-comment">// 要分配的长度是stripe的整数倍，这是对raid的优化</span><br>ext4_mb_scan_aligned(ac, &amp;e4b);<br><span class="hljs-keyword">else</span><br>ext4_mb_complex_scan_group(ac, &amp;e4b);<br><br>ext4_unlock_group(sb, group);<br>ext4_mb_unload_buddy(&amp;e4b);<br><br><span class="hljs-keyword">if</span> (ac-&gt;ac_status != AC_STATUS_CONTINUE)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 最终也还是没有分配成功</span><br><span class="hljs-keyword">if</span> (ac-&gt;ac_b_ex.fe_len &gt; <span class="hljs-number">0</span> &amp;&amp; ac-&gt;ac_status != AC_STATUS_FOUND &amp;&amp;<br>    !(ac-&gt;ac_flags &amp; EXT4_MB_HINT_FIRST)) &#123;<br><br>        <span class="hljs-comment">// 有空闲空间就行</span><br>ext4_mb_try_best_found(ac, &amp;e4b);<br><span class="hljs-keyword">if</span> (ac-&gt;ac_status != AC_STATUS_FOUND) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">再尝试遍历一次所有的block group有空闲空间就行</span><br><span class="hljs-comment"> */</span><br>ac-&gt;ac_b_ex.fe_group = <span class="hljs-number">0</span>;<br>ac-&gt;ac_b_ex.fe_start = <span class="hljs-number">0</span>;<br>ac-&gt;ac_b_ex.fe_len = <span class="hljs-number">0</span>;<br>ac-&gt;ac_status = AC_STATUS_CONTINUE;<br>ac-&gt;ac_flags |= EXT4_MB_HINT_FIRST;<br>cr = <span class="hljs-number">3</span>;<br><span class="hljs-type">atomic_inc</span>(&amp;sbi-&gt;s_mb_lost_chunks);<br><span class="hljs-keyword">goto</span> repeat;<br>&#125;<br>&#125;<br>out:<br><span class="hljs-keyword">if</span> (!err &amp;&amp; ac-&gt;ac_status != AC_STATUS_FOUND &amp;&amp; first_err)<br>err = first_err;<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_good_group()函数，检查在当前的严苛程度下可否进行分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_good_group</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params"><span class="hljs-type">ext4_group_t</span> group, <span class="hljs-type">int</span> cr)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-built_in">free</span>, fragments;<br><span class="hljs-type">int</span> flex_size = ext4_flex_bg_size(EXT4_SB(ac-&gt;ac_sb));<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span> =</span> ext4_get_group_info(ac-&gt;ac_sb, group);<br><br>BUG_ON(cr &lt; <span class="hljs-number">0</span> || cr &gt;= <span class="hljs-number">4</span>);<br><br><span class="hljs-built_in">free</span> = grp-&gt;bb_free;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">// 没有空闲空间了直接返回</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 如果空闲空间小于要分配的长度时，只在严苛程度为3，即最低时才往下走去检查</span><br><span class="hljs-keyword">if</span> (cr &lt;= <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">free</span> &lt; ac-&gt;ac_g_ex.fe_len)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(grp)))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 有必要则初始化block group</span><br><span class="hljs-keyword">if</span> (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) &#123;<br><span class="hljs-type">int</span> ret = ext4_mb_init_group(ac-&gt;ac_sb, group, GFP_NOFS);<br><span class="hljs-keyword">if</span> (ret) <br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br>fragments = grp-&gt;bb_fragments;<br><span class="hljs-keyword">if</span> (fragments == <span class="hljs-number">0</span>) <span class="hljs-comment">// 没有空闲空间段了，直接返回 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">switch</span> (cr) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>BUG_ON(ac-&gt;ac_2order == <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/* Avoid using the first bg of a flexgroup for data files */</span><br><span class="hljs-comment">// flex块组的第一个块组一般是给目录和特殊文件用的，当“最严苛的时候”跳过</span><br><span class="hljs-keyword">if</span> ((ac-&gt;ac_flags &amp; EXT4_MB_HINT_DATA) &amp;&amp;<br>    (flex_size &gt;= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) &amp;&amp;<br>    ((group % flex_size) == <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> ((ac-&gt;ac_2order &gt; ac-&gt;ac_sb-&gt;s_blocksize_bits+<span class="hljs-number">1</span>) || <span class="hljs-comment">// 大于13</span><br>    (<span class="hljs-built_in">free</span> / fragments) &gt;= ac-&gt;ac_g_ex.fe_len) <span class="hljs-comment">// 或者空闲空间的平均长度大于等于申请的长度，可以进行分配</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 如果block group内最大的空闲空间的阶小于要分配的阶则不能分配</span><br><span class="hljs-keyword">if</span> (grp-&gt;bb_largest_free_order &lt; ac-&gt;ac_2order)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-keyword">if</span> ((<span class="hljs-built_in">free</span> / fragments) &gt;= ac-&gt;ac_g_ex.fe_len) <span class="hljs-comment">// 空闲空间的平均长度大于等于申请的长度，可以进行分配</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> &gt;= ac-&gt;ac_g_ex.fe_len) <span class="hljs-comment">// 空闲空间的总长度大于申请的长度时可进行分配</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">// 只要有空闲空间就可以进行分配</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">default</span>:<br>BUG();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_simple_scan_group()函数，当申请的长度刚好是2的N次方时才会调用这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_simple_scan_group</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_group_info</span> *<span class="hljs-title">grp</span> =</span> e4b-&gt;bd_info;<br><span class="hljs-type">void</span> *buddy;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> k;<br><span class="hljs-type">int</span> max;<br><br>BUG_ON(ac-&gt;ac_2order &lt;= <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (i = ac-&gt;ac_2order; i &lt;= sb-&gt;s_blocksize_bits + <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (grp-&gt;bb_counters[i] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br><br>buddy = mb_find_buddy(e4b, i, &amp;max);<br>BUG_ON(buddy == <span class="hljs-literal">NULL</span>);<br><br>k = mb_find_next_zero_bit(buddy, max, <span class="hljs-number">0</span>);<br>BUG_ON(k &gt;= max);<br><br>ac-&gt;ac_found++;<br><br>ac-&gt;ac_b_ex.fe_len = <span class="hljs-number">1</span> &lt;&lt; i;<br>ac-&gt;ac_b_ex.fe_start = k &lt;&lt; i;<br>ac-&gt;ac_b_ex.fe_group = e4b-&gt;bd_group;<br><span class="hljs-comment">// 这里更新的是best，也就是最终的分配地方</span><br>ext4_mb_use_best_found(ac, e4b);<br><br>BUG_ON(ac-&gt;ac_b_ex.fe_len != ac-&gt;ac_g_ex.fe_len);<br><br><span class="hljs-keyword">if</span> (EXT4_SB(sb)-&gt;s_mb_stats)<br><span class="hljs-type">atomic_inc</span>(&amp;EXT4_SB(sb)-&gt;s_bal_2orders);<br><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_scan_aligned()函数，这是ext4文件系统对raid的优化，针对分配的长度是stripe的整数倍的场景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_scan_aligned</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params"> <span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_sb_info</span> *<span class="hljs-title">sbi</span> =</span> EXT4_SB(sb);<br><span class="hljs-type">void</span> *bitmap = e4b-&gt;bd_bitmap;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ex</span>;</span><br><span class="hljs-type">ext4_fsblk_t</span> first_group_block;<br><span class="hljs-type">ext4_fsblk_t</span> a;<br><span class="hljs-type">ext4_grpblk_t</span> i;<br><span class="hljs-type">int</span> max;<br><br>BUG_ON(sbi-&gt;s_stripe == <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/* find first stripe-aligned block in group */</span><br>first_group_block = ext4_group_first_block_no(sb, e4b-&gt;bd_group);<br><br>a = first_group_block + sbi-&gt;s_stripe - <span class="hljs-number">1</span>;<br>do_div(a, sbi-&gt;s_stripe); <span class="hljs-comment">// 计算后a表示起始块在第几个stripe</span><br>i = (a * sbi-&gt;s_stripe) - first_group_block; <span class="hljs-comment">// 计算后的i为在block group内第一个与stripe对齐的块在block group内的编号</span><br><br>    <span class="hljs-comment">// 在一个cluster的范围内开始寻找</span><br><span class="hljs-keyword">while</span> (i &lt; EXT4_CLUSTERS_PER_GROUP(sb)) &#123;<br>        <span class="hljs-comment">// block group的block bitmap是从0开始编号的，结合上面对i的注释理解</span><br><span class="hljs-keyword">if</span> (!mb_test_bit(i, bitmap)) &#123;<br>            <span class="hljs-comment">// 查看从这里起始能否找到一个stripe长度的空闲空间</span><br>max = mb_find_extent(e4b, i, sbi-&gt;s_stripe, &amp;ex);<br><span class="hljs-keyword">if</span> (max &gt;= sbi-&gt;s_stripe) &#123; <span class="hljs-comment">// 找到则置上best</span><br>ac-&gt;ac_found++;<br>ex.fe_logical = <span class="hljs-number">0xDEADF00D</span>; <span class="hljs-comment">/* debug value */</span><br>ac-&gt;ac_b_ex = ex;<br>ext4_mb_use_best_found(ac, e4b);<br><span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 虽然调用者要求的是申请stripe的整数倍长度的空间，但是这里一次也只分配一个stripe长度的空间</span><br>&#125;<br>&#125;<br>i += sbi-&gt;s_stripe; <span class="hljs-comment">// i指向下一个与stripe对齐的块</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_complex_scan_group()函数， 遍历block group内的所有空闲空间段，然后找出最合适的空闲空间段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_complex_scan_group</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> ac-&gt;ac_sb;<br><span class="hljs-type">void</span> *bitmap = e4b-&gt;bd_bitmap;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ex</span>;</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br><br><span class="hljs-built_in">free</span> = e4b-&gt;bd_info-&gt;bb_free;<br>BUG_ON(<span class="hljs-built_in">free</span> &lt;= <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 从第一个空闲的block开始搜索</span><br>i = e4b-&gt;bd_info-&gt;bb_first_free;<br><span class="hljs-comment">// 遍历搜索最佳的空闲空间，在ext4_mb_measure_extent()函数确定是否为最佳</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">free</span> &amp;&amp; ac-&gt;ac_status == AC_STATUS_CONTINUE) &#123;<br>        <span class="hljs-comment">// 每一轮循环开始就找到下一段空闲空间的起始位置，第一轮的时候就是其本身，即第一个空闲空间的起始位置</span><br>i = mb_find_next_zero_bit(bitmap,<br>EXT4_CLUSTERS_PER_GROUP(sb), i);<br><span class="hljs-keyword">if</span> (i &gt;= EXT4_CLUSTERS_PER_GROUP(sb)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * IF we have corrupt bitmap, we won&#x27;t find any</span><br><span class="hljs-comment"> * free blocks even though group info says we</span><br><span class="hljs-comment"> * we have free blocks</span><br><span class="hljs-comment"> */</span><br>ext4_grp_locked_error(sb, e4b-&gt;bd_group, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br><span class="hljs-string">&quot;%d free clusters as per &quot;</span><br><span class="hljs-string">&quot;group info. But bitmap says 0&quot;</span>,<br><span class="hljs-built_in">free</span>);<br>ext4_mark_group_bitmap_corrupted(sb, e4b-&gt;bd_group,<br>EXT4_GROUP_INFO_BBITMAP_CORRUPT);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 返回的ex的fe_len表示的是此次寻找能分配的最大的长度</span><br>mb_find_extent(e4b, i, ac-&gt;ac_g_ex.fe_len, &amp;ex);<br>BUG_ON(ex.fe_len &lt;= <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> &lt; ex.fe_len) &#123;<br>ext4_grp_locked_error(sb, e4b-&gt;bd_group, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br><span class="hljs-string">&quot;%d free clusters as per &quot;</span><br><span class="hljs-string">&quot;group info. But got %d blocks&quot;</span>,<br><span class="hljs-built_in">free</span>, ex.fe_len);<br>ext4_mark_group_bitmap_corrupted(sb, e4b-&gt;bd_group,<br>EXT4_GROUP_INFO_BBITMAP_CORRUPT);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The number of free blocks differs. This mostly</span><br><span class="hljs-comment"> * indicate that the bitmap is corrupt. So exit</span><br><span class="hljs-comment"> * without claiming the space.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>ex.fe_logical = <span class="hljs-number">0xDEADC0DE</span>; <span class="hljs-comment">/* debug value */</span><br>        <span class="hljs-comment">// 检查是否合适</span><br>ext4_mb_measure_extent(ac, &amp;ex, e4b);<br><span class="hljs-comment">// 进入到下一轮寻找</span><br>i += ex.fe_len;<br><span class="hljs-built_in">free</span> -= ex.fe_len;<br>&#125;<br><br>ext4_mb_check_limits(ac, e4b, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_measure_extent()函数，负责判断当前的空闲空间段是否就是分配的最佳的段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ext4_mb_measure_extent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_free_extent *ex,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> *<span class="hljs-title">bex</span> =</span> &amp;ac-&gt;ac_b_ex;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> *<span class="hljs-title">gex</span> =</span> &amp;ac-&gt;ac_g_ex;<br><br>BUG_ON(ex-&gt;fe_len &lt;= <span class="hljs-number">0</span>);<br>BUG_ON(ex-&gt;fe_len &gt; EXT4_CLUSTERS_PER_GROUP(ac-&gt;ac_sb));<br>BUG_ON(ex-&gt;fe_start &gt;= EXT4_CLUSTERS_PER_GROUP(ac-&gt;ac_sb));<br>BUG_ON(ac-&gt;ac_status != AC_STATUS_CONTINUE);<br><br>ac-&gt;ac_found++;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 如果调用者要求直接就是找到的第一个段那么就直接分配</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(ac-&gt;ac_flags &amp; EXT4_MB_HINT_FIRST)) &#123;<br>*bex = *ex;<br>ext4_mb_use_best_found(ac, e4b); <span class="hljs-comment">// 这里面会把ext4_allocation_context的状态置为FOUND，外面调用的循环自然就停止了。</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 检查是否最佳：</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 如果空闲空间长度刚好跟要求分配的长度一致那么这个就是最佳的</span><br><span class="hljs-keyword">if</span> (ex-&gt;fe_len == gex-&gt;fe_len) &#123;<br>*bex = *ex;<br>ext4_mb_use_best_found(ac, e4b);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 第一个段进来还没有可比较的，就先保存着</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (bex-&gt;fe_len == <span class="hljs-number">0</span>) &#123;<br>*bex = *ex;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If new found extent is better, store it in the context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (bex-&gt;fe_len &lt; gex-&gt;fe_len) &#123;<br><span class="hljs-comment">// 如果前面找到的段的长度小于要求分配的长度，而且当前找到的段的可分配长度比前面找到的要长，那么自然就是比前面的段要更合适一些</span><br><span class="hljs-keyword">if</span> (ex-&gt;fe_len &gt; bex-&gt;fe_len)<br>*bex = *ex;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex-&gt;fe_len &gt; gex-&gt;fe_len) &#123;<br><span class="hljs-comment">// 如果当前找到的段的可分配长度已经大于了要求分配的长度，那么就找到分配后剩余的长度最短的段</span><br><span class="hljs-keyword">if</span> (ex-&gt;fe_len &lt; bex-&gt;fe_len)<br>*bex = *ex;<br>&#125;<br><br>ext4_mb_check_limits(ac, e4b, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>ext4_mb_try_best_found()函数，遍历了很久但还是没有找到最佳的分配地点，需要做最后的尝试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> noinline_for_stack<br><span class="hljs-type">int</span> <span class="hljs-title function_">ext4_mb_try_best_found</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ext4_allocation_context *ac,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> ext4_buddy *e4b)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_free_extent</span> <span class="hljs-title">ex</span> =</span> ac-&gt;ac_b_ex;<br><span class="hljs-type">ext4_group_t</span> group = ex.fe_group;<br><span class="hljs-type">int</span> max;<br><span class="hljs-type">int</span> err;<br><br>    <span class="hljs-comment">// ac_b_ex可能是在ext4_mb_complex_scan_group()的时候置上的，但没有成为最终的分配地点</span><br>BUG_ON(ex.fe_len &lt;= <span class="hljs-number">0</span>);<br>err = ext4_mb_load_buddy(ac-&gt;ac_sb, group, e4b);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><span class="hljs-comment">// 尝试从这个前面可能找到的ext4_free_extent进行分配</span><br>ext4_lock_group(ac-&gt;ac_sb, group);<br>max = mb_find_extent(e4b, ex.fe_start, ex.fe_len, &amp;ex);<br><br><span class="hljs-keyword">if</span> (max &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 都此时此刻了，有空闲空间就行，能分配多少分配多少了</span><br>ac-&gt;ac_b_ex = ex;<br>ext4_mb_use_best_found(ac, e4b);<br>&#125;<br><br>ext4_unlock_group(ac-&gt;ac_sb, group);<br>ext4_mb_unload_buddy(e4b);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在ext4_mb_regular_allocator()函数的最后，当所有的手段都不能分配到空闲空间，那么会做最后的一搏，将严苛程度置为3，然后回到repeat再一次遍历所有的block group看能否分配。</p><h2 id="持久预分配-1"><a href="#持久预分配-1" class="headerlink" title="持久预分配"></a>持久预分配</h2><p>linux提供了一个非posix标准的接口fallocate()以实现持久预分配，同时还提供了一个posix标准的接口posix_fallocate()，此接口不需要下层文件系统支持持久预分配，而前面的fallocate()需要。</p><p>fallocate()从vfs最终会调到ext4文件系统注册的ext4_fallocate()接口，fallocate()提供持久预分配的同时还会提供打洞、清零等操作，这个可以单独开一期分析，但对于持久预分配来说就是调用ext4_map_blocks()函数去分配传入的逻辑空间。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://oenhan.com/ext4-mballoc">https://oenhan.com/ext4-mballoc</a></p><p><a href="https://younger.blog.csdn.net/article/details/22759619">https://younger.blog.csdn.net/article/details/22759619</a></p><p><a href="https://blog.csdn.net/tobbeone/article/details/80852816">https://blog.csdn.net/tobbeone/article/details/80852816</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/04/29/block/kyber/"/>
    <url>/2023/04/29/block/kyber/</url>
    
    <content type="html"><![CDATA[<h1 id="kyber调度器原理及源码分析"><a href="#kyber调度器原理及源码分析" class="headerlink" title="kyber调度器原理及源码分析"></a>kyber调度器原理及源码分析</h1><p>linux内核块层有kyber、mq-deadline以及bfq三个针对multi queue设计的调度器，这篇文章主要是讲解kyber调度器的原理和源码，分析的内核版本是4.20。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们知道当Block层不使用任何的调度器的时候，调度队列是按照每个cpu核一个软队列，一定数量的硬队列，并将软队列和硬队列建立一定的映射关系“map”来调度IO的，通过当前的cpu_id能找到per_cpu的软队列，在软队列里面完成插入、合并等动作，然后通过map[cpu_id]找到其映射的硬队列，从而将IO分发到硬队列，最后硬队列将IO下发到驱动层，由驱动层将IO通过某个总线(PCIe、FC、RoCE等)发送到设备层。</p><p>当kyber调度器启用时，kyber舍弃软队列，创建read、write、discard、other四个队列将IO分类处理。kyber不是消耗光了某个队列再去分发下一个队列，而是消耗到一定的个数就切换到下一个队列，从而防止后面的队列被饿死，这个个数分别是16、8、1、1，也就是分发了16个读IO之后去分发写，分发了8个写之后再分发一个discard，最后分发一个other的IO，以此类推循环。</p><p>kyber是怎么找到应该往哪个硬队列分发呢？</p><p>答案是根据当前cpu_id找到软队列，然后通过记录在软队列里面的“该软队列在其对应的硬队列里面的所有跟这个硬队列关联的软队列的编号”就能找到其对应的硬队列。前面这句话有点绕，解释一下，系统内最好的情况下是软队列个数等于硬队列个数，这样软队列和硬队列就能一一对应，但是通常情况下受限于实际的块设备的处理能力，硬队列个数往往小于软队列的个数，因此需要将多个软队列跟一个硬队列映射绑定，形成多对一的关系，在硬队列里面有个数组<strong>struct blk_mq_ctxctxs</strong>就记录了该硬队列对应的所有软队列，其下标则存在于软队列结构体里面<strong>unsigned int  index_hw</strong>，详细可参考源码函数blk_mq_map_swqueue()。</p><p>下面说说kyber的这个“分发队列”，让人反直觉的是request（block层io结构体）不是直接insert到分发队列的，而是先insert到“暂存队列”（我们暂时给它这么个名字，后面有详细的结构体），在暂存队列IO被合并、分类，然后当分发队列为空而需要分发一个IO的时候就会将暂存队列的IO都挂到分发队列上，然后选择一个IO分发到硬队列。</p><p><img src="/assets/kyber.jpg" alt="kyber"></p><p>​                                                        图中我们假设cpu0、cpu1对应这个硬队列。</p><p>挂入分发队列的IO个数理论是无限的，虽然每轮只会分发固定数量的IO，但是一轮循环完毕就会立马进行下一轮循环，而此时前面分发的IO可能都还没有回来，就没有起到控制的作用了。kyber针对read、write、discard、other分别设置了总的token数目，分别为256、128、64、16，当要分发一个IO到硬队列的时候，先得拿到这个token，然后才能分发，如果当前token已经耗光，也就是说底层硬处理地慢而上层下发地快了，就要将当前的分发队列挂起，在下层的某个IO执行完毕回来后看这个IO的类型的分发队列是否挂起的，有则将其唤醒去分发IO。</p><p>此外kyber还会统计IO的时延，并且针对read、write、discard设置了时延参考值，分别为2000000nsec、10000000nsec、5000000nsec。kyber通过将统计的时延与参考值进行对比，动态地调整每种类型IO的token数目，以求公平。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="kyber-queue-data"><a href="#kyber-queue-data" class="headerlink" title="kyber_queue_data"></a>kyber_queue_data</h3><p>kyber_queue_data是kyber的主要数据结构之一，当将块设备的调度器切换到kyber时就会生成这样的结构体存放在elevator_queue的elevator_data中，通过request_queue可以找到elevator_queue，自然就能找到kyber_queue_data。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_queue_data</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span>;</span> <span class="hljs-comment">// 块设备对应一个request_queue，也就对应一个kyber_queue_data</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Each scheduling domain has a limited number of in-flight requests</span><br><span class="hljs-comment"> * device-wide, limited by these tokens.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 每种队列的token占用情况，分发IO时从这里申请</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sbitmap_queue</span> <span class="hljs-title">domain_tokens</span>[<span class="hljs-title">KYBER_NUM_DOMAINS</span>];</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Async request percentage, converted to per-word depth for</span><br><span class="hljs-comment"> * sbitmap_get_shallow().</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 用该值限制异步请求的带宽，防止同步请求被饿死</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> async_depth;<br><span class="hljs-comment">// per_cpu地统计时延信息，IO完成时就会统计时延到这里</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_cpu_latency</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">cpu_latency</span>;</span><br><br><span class="hljs-comment">/* Timer for stats aggregation and adjusting domain tokens. */</span><br>    <span class="hljs-comment">// 有一个timer，每隔一段时间统计一下时延情况，根据统计情况调整token数量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span><br><span class="hljs-comment">// 上面的timer每隔一段时间会将per_cpu统计的时延加到这里面计算新的token数量</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> latency_buckets[KYBER_OTHER][<span class="hljs-number">2</span>][KYBER_LATENCY_BUCKETS];<br><span class="hljs-comment">// 记录上一次调整token的时间</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> latency_timeout[KYBER_OTHER];<br><span class="hljs-comment">// 记录上一次timer得到的时延好坏结果，如果下一次timer的时候时延的样本数量不够则用这一次的</span><br>    <span class="hljs-comment">// 下一次timer如果采用了这一次计算的延时好坏结果，则将其值置为-1，不再使用，只使用一次</span><br><span class="hljs-type">int</span> domain_p99[KYBER_OTHER];<br><br><span class="hljs-comment">/* Target latencies in nanoseconds. */</span><br>    <span class="hljs-comment">// 每种IO类型的时延参考值</span><br>u64 latency_targets[KYBER_OTHER];<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="kyber-hctx-data"><a href="#kyber-hctx-data" class="headerlink" title="kyber_hctx_data"></a>kyber_hctx_data</h3><p>存放于硬队列blk_mq_hw_ctx的sched_data字段，包含了原理一章中提到的“暂存队列”和“分发队列”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_hctx_data</span> &#123;</span><br><span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rqs</span>[<span class="hljs-title">KYBER_NUM_DOMAINS</span>];</span> <span class="hljs-comment">// 分发队列，IO从这个队列提交到硬队列</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cur_domain; <span class="hljs-comment">// 当前分发的是read、write、discard还是other</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> batching; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_ctx_queue</span> *<span class="hljs-title">kcqs</span>;</span> <span class="hljs-comment">// 暂存队列，硬队列对应的软队列有多少个就有多少个暂存队列</span><br>    <span class="hljs-comment">// kcq_map用于表示暂存队列上是否有IO</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sbitmap</span> <span class="hljs-title">kcq_map</span>[<span class="hljs-title">KYBER_NUM_DOMAINS</span>];</span><br> <span class="hljs-comment">// 当token耗光的时候，分发队列进入wait状态，等待回来的io释放token将之唤醒，以下是这个流程需要用到的结构</span><br><span class="hljs-type">wait_queue_entry_t</span> domain_wait[KYBER_NUM_DOMAINS];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sbq_wait_state</span> *<span class="hljs-title">domain_ws</span>[<span class="hljs-title">KYBER_NUM_DOMAINS</span>];</span><br><span class="hljs-type">atomic_t</span> wait_index[KYBER_NUM_DOMAINS];<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_ctx_queue</span> &#123;</span> <span class="hljs-comment">// 暂存队列，由此可见一个暂存队列就有4个种类的队列</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Used to ensure operations on rq_list and kcq_map to be an atmoic one.</span><br><span class="hljs-comment"> * Also protect the rqs on rq_list when merge.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rq_list</span>[<span class="hljs-title">KYBER_NUM_DOMAINS</span>];</span><br>&#125; ____cacheline_aligned_in_smp;<br></code></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="初始化kyber"><a href="#初始化kyber" class="headerlink" title="初始化kyber"></a>初始化kyber</h3><p>当kyber模块注册时回调用kyber_init()函数注册kyber给elevator，包括kyber的名字、属性、debugfs相关信息、owner以及最重要的hook。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">kyber_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> elv_register(&amp;kyber_sched);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elevator_type</span> <span class="hljs-title">kyber_sched</span> =</span> &#123; <span class="hljs-comment">// 这些hook在后续的章节中会一一讲到</span><br>.ops.mq = &#123;<br>.init_sched = kyber_init_sched,<br>.exit_sched = kyber_exit_sched,<br>.init_hctx = kyber_init_hctx,<br>.exit_hctx = kyber_exit_hctx, <span class="hljs-comment">// 以上是初始化和释放kyber内部结构体的函数</span><br>.limit_depth = kyber_limit_depth, <span class="hljs-comment">// 限制request队列的深度</span><br>.bio_merge = kyber_bio_merge, <span class="hljs-comment">// 将bio合并到kyber</span><br>.prepare_request = kyber_prepare_request, <span class="hljs-comment">// 初始化request时调用</span><br>.insert_requests = kyber_insert_requests, <span class="hljs-comment">// 将request插入到kyber</span><br>.finish_request = kyber_finish_request, <span class="hljs-comment">// 释放request时调用</span><br>.requeue_request = kyber_finish_request, <span class="hljs-comment">// 将request重新入队时调用</span><br>.completed_request = kyber_completed_request, <span class="hljs-comment">// request完成时调用</span><br>.dispatch_request = kyber_dispatch_request, <span class="hljs-comment">// 分发request</span><br>.has_work = kyber_has_work, <span class="hljs-comment">// kyber是否有未分发的request</span><br>&#125;,<br>.uses_mq = <span class="hljs-literal">true</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEBUG_FS</span><br>.queue_debugfs_attrs = kyber_queue_debugfs_attrs,<br>.hctx_debugfs_attrs = kyber_hctx_debugfs_attrs,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.elevator_attrs = kyber_sched_attrs,<br>.elevator_name = <span class="hljs-string">&quot;kyber&quot;</span>,<br>.elevator_owner = THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="初始化kyber-queue-data"><a href="#初始化kyber-queue-data" class="headerlink" title="初始化kyber_queue_data"></a>初始化kyber_queue_data</h3><p>当块设备的调度器被设置成kyber时会调用kyber_init_sched()函数初始化kyber_queue_data，将kyber_queue_data与request_queue绑定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kyber_init_sched</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-keyword">struct</span> elevator_type *e)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_queue_data</span> *<span class="hljs-title">kqd</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elevator_queue</span> *<span class="hljs-title">eq</span>;</span><br><br>eq = elevator_alloc(q, e); <span class="hljs-comment">// 申请电梯队列结构，request可通过该结构访问到kyber_queue_data</span><br><span class="hljs-keyword">if</span> (!eq)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br>kqd = kyber_queue_data_alloc(q); <span class="hljs-comment">// 申请kyber_queue_data并初始化</span><br><span class="hljs-keyword">if</span> (IS_ERR(kqd)) &#123;<br>kobject_put(&amp;eq-&gt;kobj);<br><span class="hljs-keyword">return</span> PTR_ERR(kqd);<br>&#125;<br><br>blk_stat_enable_accounting(q);<br><br>eq-&gt;elevator_data = kqd; <span class="hljs-comment">// 将kyber_queue_data和elevator_queue绑定</span><br>q-&gt;elevator = eq; <span class="hljs-comment">// 将elevator_queue和request_queue绑定</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>kyber_queue_data_alloc函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> kyber_queue_data *<span class="hljs-title function_">kyber_queue_data_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_queue_data</span> *<span class="hljs-title">kqd</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shift;<br><span class="hljs-type">int</span> ret = -ENOMEM;<br><span class="hljs-type">int</span> i;<br><br>kqd = kzalloc_node(<span class="hljs-keyword">sizeof</span>(*kqd), GFP_KERNEL, q-&gt;node);<br><span class="hljs-keyword">if</span> (!kqd)<br><span class="hljs-keyword">goto</span> err;<br><br>kqd-&gt;q = q; <span class="hljs-comment">// 将kyber_queue_data与request_queue绑定</span><br><span class="hljs-comment">// 初始化per_cpu的时延统计</span><br>kqd-&gt;cpu_latency = alloc_percpu_gfp(<span class="hljs-keyword">struct</span> kyber_cpu_latency,<br>    GFP_KERNEL | __GFP_ZERO);<br><span class="hljs-keyword">if</span> (!kqd-&gt;cpu_latency)<br><span class="hljs-keyword">goto</span> err_kqd;<br><span class="hljs-comment">// 初始化时延统计timer</span><br>    <span class="hljs-comment">// kyber_timer_fn会将所有per_cpu的时延统计加起来，然后通过一定的算法调整每个类型队列的    token数目</span><br>timer_setup(&amp;kqd-&gt;timer, kyber_timer_fn, <span class="hljs-number">0</span>);<br>    <br><span class="hljs-comment">// 初始化每种队列的token数，kyber_depth全局变量显示为256、128、64、16</span><br>    <span class="hljs-comment">// token的申请、挂起、释放是通过sbitmap实现的</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++) &#123;<br>WARN_ON(!kyber_depth[i]);<br>WARN_ON(!kyber_batch_size[i]);<br>ret = sbitmap_queue_init_node(&amp;kqd-&gt;domain_tokens[i],<br>      kyber_depth[i], <span class="hljs-number">-1</span>, <span class="hljs-literal">false</span>,<br>      GFP_KERNEL, q-&gt;node);<br><span class="hljs-keyword">if</span> (ret) &#123;<br><span class="hljs-keyword">while</span> (--i &gt;= <span class="hljs-number">0</span>)<br>sbitmap_queue_free(&amp;kqd-&gt;domain_tokens[i]);<br><span class="hljs-keyword">goto</span> err_buckets;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 初始化总的时延统计和每种队列的时延参考值(kyber_latency_targets)</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KYBER_OTHER; i++) &#123;<br>kqd-&gt;domain_p99[i] = <span class="hljs-number">-1</span>;<br>kqd-&gt;latency_targets[i] = kyber_latency_targets[i];<br>&#125;<br><br>shift = kyber_sched_tags_shift(q);<br>    <span class="hljs-comment">// 限制异步IO的带宽为百分之七十五，留百分之二十五给同步IO，防止同步IO被饿死</span><br>kqd-&gt;async_depth = (<span class="hljs-number">1U</span> &lt;&lt; shift) * KYBER_ASYNC_PERCENT / <span class="hljs-number">100U</span>;<br><br><span class="hljs-keyword">return</span> kqd;<br><br>err_buckets:<br>free_percpu(kqd-&gt;cpu_latency);<br>err_kqd:<br>kfree(kqd);<br>err:<br><span class="hljs-keyword">return</span> ERR_PTR(ret);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="初始化kyber-hctx-data"><a href="#初始化kyber-hctx-data" class="headerlink" title="初始化kyber_hctx_data"></a>初始化kyber_hctx_data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kyber_init_hctx</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hctx_idx)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_queue_data</span> *<span class="hljs-title">kqd</span> =</span> hctx-&gt;<span class="hljs-built_in">queue</span>-&gt;elevator-&gt;elevator_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_hctx_data</span> *<span class="hljs-title">khd</span>;</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-comment">// 申请kyber_hctx_data</span><br>khd = kmalloc_node(<span class="hljs-keyword">sizeof</span>(*khd), GFP_KERNEL, hctx-&gt;numa_node);<br><span class="hljs-keyword">if</span> (!khd)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><span class="hljs-comment">// 申请hctx-&gt;nr_ctx个kyber_ctx_queue(暂存队列)</span><br>    <span class="hljs-comment">// hctx-&gt;nr_ctx就是与硬队列对应的软队列的个数</span><br>khd-&gt;kcqs = kmalloc_array_node(hctx-&gt;nr_ctx,<br>       <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> kyber_ctx_queue),<br>       GFP_KERNEL, hctx-&gt;numa_node);<br><span class="hljs-keyword">if</span> (!khd-&gt;kcqs)<br><span class="hljs-keyword">goto</span> err_khd;<br><span class="hljs-comment">// 初始化暂存队列</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; hctx-&gt;nr_ctx; i++)<br>kyber_ctx_queue_init(&amp;khd-&gt;kcqs[i]);<br><span class="hljs-comment">// 初始化kcq_map，用来记录暂存队列上是否有IO挂着，如果有当分发队列为空时就从暂存队列将IO都取到分发队列。</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++) &#123;<br><span class="hljs-keyword">if</span> (sbitmap_init_node(&amp;khd-&gt;kcq_map[i], hctx-&gt;nr_ctx,<br>      ilog2(<span class="hljs-number">8</span>), GFP_KERNEL, hctx-&gt;numa_node)) &#123;<br><span class="hljs-keyword">while</span> (--i &gt;= <span class="hljs-number">0</span>)<br>sbitmap_free(&amp;khd-&gt;kcq_map[i]);<br><span class="hljs-keyword">goto</span> err_kcqs;<br>&#125;<br>&#125;<br><br>spin_lock_init(&amp;khd-&gt;lock);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++) &#123;<br>        <span class="hljs-comment">// 初始化分发队列</span><br>INIT_LIST_HEAD(&amp;khd-&gt;rqs[i]);<br>        <span class="hljs-comment">// 初始化token消耗完了时挂起的IO被唤醒的函数</span><br>init_waitqueue_func_entry(&amp;khd-&gt;domain_wait[i],<br>  kyber_domain_wake);<br>khd-&gt;domain_wait[i].private = hctx;<br>        <span class="hljs-comment">// 挂起的IO就挂在这里</span><br>INIT_LIST_HEAD(&amp;khd-&gt;domain_wait[i].entry);<br><span class="hljs-type">atomic_set</span>(&amp;khd-&gt;wait_index[i], <span class="hljs-number">0</span>);<br>&#125;<br><br>khd-&gt;cur_domain = <span class="hljs-number">0</span>;<br>khd-&gt;batching = <span class="hljs-number">0</span>;<br><br>hctx-&gt;sched_data = khd;<br>sbitmap_queue_min_shallow_depth(&amp;hctx-&gt;sched_tags-&gt;bitmap_tags,<br>kqd-&gt;async_depth);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err_kcqs:<br>kfree(khd-&gt;kcqs);<br>err_khd:<br>kfree(khd);<br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="bio合并入kyber"><a href="#bio合并入kyber" class="headerlink" title="bio合并入kyber"></a>bio合并入kyber</h2><p>当一个bio来到块层时，首先看看这个bio是否能够合并到当前已有的request里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">kyber_bio_merge</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx, <span class="hljs-keyword">struct</span> bio *bio)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_hctx_data</span> *<span class="hljs-title">khd</span> =</span> hctx-&gt;sched_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ctx</span> *<span class="hljs-title">ctx</span> =</span> blk_mq_get_ctx(hctx-&gt;<span class="hljs-built_in">queue</span>);<br>    <span class="hljs-comment">// 根据软队列在硬队列里的下标找到应该合并哪个暂存队列</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_ctx_queue</span> *<span class="hljs-title">kcq</span> =</span> &amp;khd-&gt;kcqs[ctx-&gt;index_hw];<br>    <span class="hljs-comment">// 根据op flag找到是read、write、discard还是other</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_domain = kyber_sched_domain(bio-&gt;bi_opf);<br>    <span class="hljs-comment">// 是什么类型的IO就尝试合并到什么类型的暂存队列</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">rq_list</span> =</span> &amp;kcq-&gt;rq_list[sched_domain];<br><span class="hljs-type">bool</span> merged;<br><br>spin_lock(&amp;kcq-&gt;lock);<br>    <span class="hljs-comment">// 调用block层通用函数去合并bio到某个request</span><br>    <span class="hljs-comment">// blk_mq_bio_list_merge会从后往前遍历队列，检查8次能否合并</span><br>merged = blk_mq_bio_list_merge(hctx-&gt;<span class="hljs-built_in">queue</span>, rq_list, bio);<br>spin_unlock(&amp;kcq-&gt;lock);<br>blk_mq_put_ctx(ctx);<br><br><span class="hljs-keyword">return</span> merged;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="request插入到kyber"><a href="#request插入到kyber" class="headerlink" title="request插入到kyber"></a>request插入到kyber</h2><p>当发现bio并不能合并到已有的request时，根据这个bio生成一个新的request，并且将这个request插入到kyber当前的队列里面。</p><p>生成时调用prepare函数进行request的调度器相关的初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kyber_prepare_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *rq, <span class="hljs-keyword">struct</span> bio *bio)</span><br>&#123;<br>    <span class="hljs-comment">// 设置token为-1，表示还未分配token</span><br>rq_set_domain_token(rq, <span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>插入到相应的队列上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kyber_insert_requests</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> list_head *rq_list, <span class="hljs-type">bool</span> at_head)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_hctx_data</span> *<span class="hljs-title">khd</span> =</span> hctx-&gt;sched_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>, *<span class="hljs-title">next</span>;</span><br><br>list_for_each_entry_safe(rq, next, rq_list, queuelist) &#123;<br>        <span class="hljs-comment">// 与bio合并时同理找到sched_domain和kyber_ctx_queue</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_domain = kyber_sched_domain(rq-&gt;cmd_flags);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_ctx_queue</span> *<span class="hljs-title">kcq</span> =</span> &amp;khd-&gt;kcqs[rq-&gt;mq_ctx-&gt;index_hw];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">head</span> =</span> &amp;kcq-&gt;rq_list[sched_domain];<br><br>spin_lock(&amp;kcq-&gt;lock);<br>        <span class="hljs-comment">// 将request插入到队列上</span><br><span class="hljs-keyword">if</span> (at_head)<br>list_move(&amp;rq-&gt;queuelist, head);<br><span class="hljs-keyword">else</span><br>list_move_tail(&amp;rq-&gt;queuelist, head);<br>        <span class="hljs-comment">// 设置bit表示暂存队列上有request</span><br>sbitmap_set_bit(&amp;khd-&gt;kcq_map[sched_domain],<br>rq-&gt;mq_ctx-&gt;index_hw);<br>blk_mq_sched_request_inserted(rq);<br>spin_unlock(&amp;kcq-&gt;lock);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kyber分发request"><a href="#kyber分发request" class="headerlink" title="kyber分发request"></a>kyber分发request</h2><p>kyber注册的分发hook为kyber_dispatch_request()函数。kyber采用round robin的方式遍历分发队列的read、write、discard、other队列，选择一个IO分发到硬队列，当分发队列上没有IO时会遍历与这个分发队列相关联的所有暂存队列，将暂存队列上的所有IO都转到分发队列上，然后再看有没有IO可以分发的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> request *<span class="hljs-title function_">kyber_dispatch_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_queue_data</span> *<span class="hljs-title">kqd</span> =</span> hctx-&gt;<span class="hljs-built_in">queue</span>-&gt;elevator-&gt;elevator_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_hctx_data</span> *<span class="hljs-title">khd</span> =</span> hctx-&gt;sched_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>;</span><br><span class="hljs-type">int</span> i;<br><br>spin_lock(&amp;khd-&gt;lock);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * First, if we are still entitled to batch, try to dispatch a request</span><br><span class="hljs-comment"> * from the batch.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 如果当前队列派发的IO个数还没有达到最大值则继续派发当前队列的IO</span><br><span class="hljs-keyword">if</span> (khd-&gt;batching &lt; kyber_batch_size[khd-&gt;cur_domain]) &#123;<br>rq = kyber_dispatch_cur_domain(kqd, khd, hctx);<br><span class="hljs-keyword">if</span> (rq)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Either,</span><br><span class="hljs-comment"> * 1. We were no longer entitled to a batch.</span><br><span class="hljs-comment"> * 2. The domain we were batching didn&#x27;t have any requests.</span><br><span class="hljs-comment"> * 3. The domain we were batching was out of tokens.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Start another batch. Note that this wraps back around to the original</span><br><span class="hljs-comment"> * domain if no other domains have requests or tokens.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 否则将batching置为0，选择下一个派发的队列，如果当前已经是other队列了，</span><br>    <span class="hljs-comment">// 则跳到第一个的read队列</span><br>khd-&gt;batching = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++) &#123;<br><span class="hljs-keyword">if</span> (khd-&gt;cur_domain == KYBER_NUM_DOMAINS - <span class="hljs-number">1</span>)<br>khd-&gt;cur_domain = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>khd-&gt;cur_domain++;<br><br>rq = kyber_dispatch_cur_domain(kqd, khd, hctx);<br><span class="hljs-keyword">if</span> (rq)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br>rq = <span class="hljs-literal">NULL</span>;<br>out:<br>spin_unlock(&amp;khd-&gt;lock);<br><span class="hljs-keyword">return</span> rq;<br>&#125;<br></code></pre></td></tr></table></figure><p>kyber_dispatch_cur_domain()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> request *<br><span class="hljs-title function_">kyber_dispatch_cur_domain</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kyber_queue_data *kqd,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> kyber_hctx_data *khd,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">rqs</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>;</span><br><span class="hljs-type">int</span> nr;<br><br>    <span class="hljs-comment">// 获取当前的分发队列</span><br>rqs = &amp;khd-&gt;rqs[khd-&gt;cur_domain];<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we already have a flushed request, then we just need to get a</span><br><span class="hljs-comment"> * token for it. Otherwise, if there are pending requests in the kcqs,</span><br><span class="hljs-comment"> * flush the kcqs, but only if we can get a token. If not, we should</span><br><span class="hljs-comment"> * leave the requests in the kcqs so that they can be merged. Note that</span><br><span class="hljs-comment"> * khd-&gt;lock serializes the flushes, so if we observed any bit set in</span><br><span class="hljs-comment"> * the kcq_map, we will always get a request.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 选择队列里面第一个IO</span><br>rq = list_first_entry_or_null(rqs, <span class="hljs-keyword">struct</span> request, queuelist);<br><span class="hljs-keyword">if</span> (rq) &#123;<br>        <span class="hljs-comment">// 获取token</span><br>nr = kyber_get_domain_token(kqd, khd, hctx);<br><span class="hljs-keyword">if</span> (nr &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 获取到了token</span><br>khd-&gt;batching++;<br>            <span class="hljs-comment">// 将token保存在request的priv字段里面</span><br>rq_set_domain_token(rq, nr);<br>            <span class="hljs-comment">// 从分发队列上摘链</span><br>list_del_init(&amp;rq-&gt;queuelist);<br><span class="hljs-keyword">return</span> rq;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>trace_kyber_throttled(kqd-&gt;q,<br>      kyber_domain_names[khd-&gt;cur_domain]);<br>&#125;<br>       <span class="hljs-comment">// kcq_map的bit位被设置表示当前分发的IO类型在暂存队列是有IO的</span><br>       <span class="hljs-comment">// kcq_map在insert request的时候置的</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sbitmap_any_bit_set(&amp;khd-&gt;kcq_map[khd-&gt;cur_domain])) &#123;<br>       <br>nr = kyber_get_domain_token(kqd, khd, hctx);<br><span class="hljs-keyword">if</span> (nr &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 暂存队列有IO，并且当前IO类型的token还没有被消耗完</span><br>            <span class="hljs-comment">// 将暂存队列的IO转到分发队列上</span><br>kyber_flush_busy_kcqs(khd, khd-&gt;cur_domain, rqs);<br>            <span class="hljs-comment">// IO转到分发队列后肯定能获取到IO进行分发</span><br>rq = list_first_entry(rqs, <span class="hljs-keyword">struct</span> request, queuelist);<br>khd-&gt;batching++;<br>rq_set_domain_token(rq, nr);<br>list_del_init(&amp;rq-&gt;queuelist);<br><span class="hljs-keyword">return</span> rq;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>trace_kyber_throttled(kqd-&gt;q,<br>      kyber_domain_names[khd-&gt;cur_domain]);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* There were either no pending requests or no tokens. */</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>kyber_get_domain_token()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kyber_get_domain_token</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kyber_queue_data *kqd,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> kyber_hctx_data *khd,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_domain = khd-&gt;cur_domain;<br>    <span class="hljs-comment">// 根据当前分发的IO类型找到申请token的sbitmap_queue</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sbitmap_queue</span> *<span class="hljs-title">domain_tokens</span> =</span> &amp;kqd-&gt;domain_tokens[sched_domain];<br>    <span class="hljs-comment">// 用于将当前分发队列挂到等待队列的结构</span><br><span class="hljs-type">wait_queue_entry_t</span> *wait = &amp;khd-&gt;domain_wait[sched_domain];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sbq_wait_state</span> *<span class="hljs-title">ws</span>;</span><br><span class="hljs-type">int</span> nr;<br><span class="hljs-comment">// 从sbitmap_queue获取一个没有在用的token</span><br>nr = __sbitmap_queue_get(domain_tokens);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we failed to get a domain token, make sure the hardware queue is</span><br><span class="hljs-comment"> * run when one becomes available. Note that this is serialized on</span><br><span class="hljs-comment"> * khd-&gt;lock, but we still need to be careful about the waker.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// nr &lt; 0表示没有获取到token，并且当前分发队列没有被挂起</span><br><span class="hljs-keyword">if</span> (nr &lt; <span class="hljs-number">0</span> &amp;&amp; list_empty_careful(&amp;wait-&gt;entry)) &#123;<br>ws = sbq_wait_ptr(domain_tokens,<br>  &amp;khd-&gt;wait_index[sched_domain]);<br>khd-&gt;domain_ws[sched_domain] = ws;<br>        <span class="hljs-comment">// 将当前的分发队列挂到相应的等待队列</span><br>add_wait_queue(&amp;ws-&gt;wait, wait);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Try again in case a token was freed before we got on the wait</span><br><span class="hljs-comment"> * queue.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 可能在挂起的时候有IO回来释放了token，在挂起之后再尝试一次看能否获取到token</span><br>        <span class="hljs-comment">// 如果能获取到则从等待队列上取下</span><br>nr = __sbitmap_queue_get(domain_tokens);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we got a token while we were on the wait queue, remove ourselves</span><br><span class="hljs-comment"> * from the wait queue to ensure that all wake ups make forward</span><br><span class="hljs-comment"> * progress. It&#x27;s possible that the waker already deleted the entry</span><br><span class="hljs-comment"> * between the !list_empty_careful() check and us grabbing the lock, but</span><br><span class="hljs-comment"> * list_del_init() is okay with that.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 如果获取到了token，并且分发队列是被挂起的</span><br><span class="hljs-keyword">if</span> (nr &gt;= <span class="hljs-number">0</span> &amp;&amp; !list_empty_careful(&amp;wait-&gt;entry)) &#123;<br>ws = khd-&gt;domain_ws[sched_domain];<br>spin_lock_irq(&amp;ws-&gt;wait.lock);<br>        <span class="hljs-comment">// 将分发队列从等待队列上摘下</span><br>list_del_init(&amp;wait-&gt;entry);<br>spin_unlock_irq(&amp;ws-&gt;wait.lock);<br>&#125;<br><br><span class="hljs-keyword">return</span> nr;<br>&#125;<br></code></pre></td></tr></table></figure><p>kyber_flush_busy_kcqs()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kyber_flush_busy_kcqs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kyber_hctx_data *khd,</span><br><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_domain,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flush_kcq_data</span> <span class="hljs-title">data</span> =</span> &#123;<br>.khd = khd,<br>.sched_domain = sched_domain,<br>.<span class="hljs-built_in">list</span> = <span class="hljs-built_in">list</span>,<br>&#125;;<br><span class="hljs-comment">// 这个函数会遍历当前IO类型的kcq_map的每一个bit，</span><br>    <span class="hljs-comment">// 然后执行flush_busy_kcq函数将暂存队列的IO都摘到分发队列上</span><br>    <span class="hljs-comment">// 我们知道一个bit代表一个跟硬队列对应的CPU核</span><br>sbitmap_for_each_set(&amp;khd-&gt;kcq_map[sched_domain],<br>     flush_busy_kcq, &amp;data);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// bitnr就代表是跟硬队列对应的第几个cpu核</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">flush_busy_kcq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sbitmap *sb, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bitnr, <span class="hljs-type">void</span> *data)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flush_kcq_data</span> *<span class="hljs-title">flush_data</span> =</span> data;<br>    <span class="hljs-comment">// 获取到这个核的暂存队列</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_ctx_queue</span> *<span class="hljs-title">kcq</span> =</span> &amp;flush_data-&gt;khd-&gt;kcqs[bitnr];<br><br>spin_lock(&amp;kcq-&gt;lock);<br>    <span class="hljs-comment">// 将暂存队列的sched_domain IO种类的队列上的IO都摘到分发队列去，</span><br>    <span class="hljs-comment">// sched_domain是kyber_flush_busy_kcqs函数传入的</span><br>list_splice_tail_init(&amp;kcq-&gt;rq_list[flush_data-&gt;sched_domain],<br>      flush_data-&gt;<span class="hljs-built_in">list</span>);<br>    <span class="hljs-comment">// 清理到bit位，表示当前这个核的这个IO类型的暂存队列已经没有IO了</span><br>sbitmap_clear_bit(sb, bitnr);<br>spin_unlock(&amp;kcq-&gt;lock);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>IO结束的时候释放token，同时这也是kyber的requeue操作的hook，重新进入队列要释放掉已经拿到的token。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kyber_finish_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_queue_data</span> *<span class="hljs-title">kqd</span> =</span> rq-&gt;q-&gt;elevator-&gt;elevator_data;<br><br>    <span class="hljs-comment">// 释放掉request的priv字段记录的token</span><br>rq_clear_domain_token(kqd, rq);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rq_clear_domain_token</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kyber_queue_data *kqd,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_domain;<br><span class="hljs-type">int</span> nr;<br><br>nr = rq_get_domain_token(rq); <span class="hljs-comment">// token保存在request的priv字段</span><br><span class="hljs-keyword">if</span> (nr != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-comment">// 获取IO类型</span><br>sched_domain = kyber_sched_domain(rq-&gt;cmd_flags);<br>        <span class="hljs-comment">// 释放token</span><br>sbitmap_queue_clear(&amp;kqd-&gt;domain_tokens[sched_domain], nr,<br>    rq-&gt;mq_ctx-&gt;cpu);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">sbitmap_queue_clear</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sbitmap_queue *sbq, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr,</span><br><span class="hljs-params"> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu)</span><br>&#123;<br>sbitmap_clear_bit_unlock(&amp;sbq-&gt;sb, nr); <span class="hljs-comment">// 清除bit位</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Pairs with the memory barrier in set_current_state() to ensure the</span><br><span class="hljs-comment"> * proper ordering of clear_bit_unlock()/waitqueue_active() in the waker</span><br><span class="hljs-comment"> * and test_and_set_bit_lock()/prepare_to_wait()/finish_wait() in the</span><br><span class="hljs-comment"> * waiter. See the comment on waitqueue_active().</span><br><span class="hljs-comment"> */</span><br>smp_mb__after_atomic();<br>sbitmap_queue_wake_up(sbq); <span class="hljs-comment">// 唤醒分发队列</span><br><br><span class="hljs-keyword">if</span> (likely(!sbq-&gt;round_robin &amp;&amp; nr &lt; sbq-&gt;sb.depth))<br>*per_cpu_ptr(sbq-&gt;alloc_hint, cpu) = nr;<br>&#125;<br></code></pre></td></tr></table></figure><p>唤醒动作会调用在初始化流程注册的kyber_domain_wake()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kyber_domain_wake</span><span class="hljs-params">(<span class="hljs-type">wait_queue_entry_t</span> *wait, <span class="hljs-type">unsigned</span> mode, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">     <span class="hljs-type">void</span> *key)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_hw_ctx</span> *<span class="hljs-title">hctx</span> =</span> READ_ONCE(wait-&gt;private);<br><br>list_del_init(&amp;wait-&gt;entry); <span class="hljs-comment">// 移出等待队列</span><br>blk_mq_run_hw_queue(hctx, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 执行run_hw_queue函数，去分发IO</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="request完成"><a href="#request完成" class="headerlink" title="request完成"></a>request完成</h2><p>IO从设备驱动回到block层的时候会调用kyber调度器注册的hook–completed_request即kyber_completed_request()函数，在完成函数里面统计IO的时延以调整token数量。</p><p>kyber会统计两种时延：</p><p>KYBER_TOTAL_LATENCY：表示IO在kernel里的时延，即总的时延。</p><p>KYBER_IO_LATENCY：表示IO在设备上的执行时延。</p><p>kyber_cpu_latency：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* buckets是一个atomic_t的三维数组，第一维表示要统计的IO类型，第二维表示是KYBER_TOTAL_LATENCY还是KYBER_IO_LATENCY，第三维表示的是8个IO时延相对于参考值的倍数的桶，先将时延统计到per_cpu的kyber_cpu_latency中，然后通过timer将所有cpu的统计加起来，通过一定的算法调整token数。 */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">KYBER_LATENCY_BUCKETS: 值为8，表示个桶，前KYBER_GOOD_BUCKETS(4)个桶表示“GOOD”的时延，后面4个表示“BAD”的时延。</span><br><span class="hljs-comment">GOOD时延表示IO时延小于等于时延参考值。</span><br><span class="hljs-comment">BAD时延表示IO时延大于时延参考值。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_cpu_latency</span> &#123;</span><br><span class="hljs-type">atomic_t</span> buckets[KYBER_OTHER][<span class="hljs-number">2</span>][KYBER_LATENCY_BUCKETS];<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kyber_completed_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *rq, u64 now)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_queue_data</span> *<span class="hljs-title">kqd</span> =</span> rq-&gt;q-&gt;elevator-&gt;elevator_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_cpu_latency</span> *<span class="hljs-title">cpu_latency</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_domain;<br>u64 target;<br><span class="hljs-comment">// 获取完成的IO的类型</span><br>sched_domain = kyber_sched_domain(rq-&gt;cmd_flags);<br>    <span class="hljs-comment">// other类型的IO不会统计时延，自然也不会去调整其token数量</span><br><span class="hljs-keyword">if</span> (sched_domain == KYBER_OTHER)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// cpu_latency延迟统计是per_cpu的，这里获取当前CPU的指针，将IO的时延统计到当前CPU</span><br>cpu_latency = get_cpu_ptr(kqd-&gt;cpu_latency);<br>    <span class="hljs-comment">// 当前IO的类型的延迟参考值</span><br>target = kqd-&gt;latency_targets[sched_domain];<br>    <span class="hljs-comment">// 统计总的IO时延，与下面对比，now减去的起始时间不一样的</span><br>add_latency_sample(cpu_latency, sched_domain, KYBER_TOTAL_LATENCY,<br>   target, now - rq-&gt;start_time_ns);<br>    <span class="hljs-comment">// 统计IO在设备上的时延</span><br>add_latency_sample(cpu_latency, sched_domain, KYBER_IO_LATENCY, target,<br>   now - rq-&gt;io_start_time_ns);<br>put_cpu_ptr(kqd-&gt;cpu_latency);<br><br>    <span class="hljs-comment">// 减小timer的到期时间</span><br>timer_reduce(&amp;kqd-&gt;timer, jiffies + HZ / <span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>add_latency_sample()统计函数，kyber会统计当前IO的时延相对于参考时延的倍数（0~7倍），然后将这个倍数的计数记录在per_cpu的kyber_cpu_latency中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">add_latency_sample</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kyber_cpu_latency *cpu_latency,</span><br><span class="hljs-params">       <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_domain, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type,</span><br><span class="hljs-params">       u64 target, u64 latency)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bucket;<br>u64 divisor;<br><br><span class="hljs-keyword">if</span> (latency &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 这里将参考值除以4，计算所得的bucket表示时延是</span><br>        <span class="hljs-comment">// &lt;= 1/4 * 时延参考值</span><br>        <span class="hljs-comment">// &lt;= 1/2 * 时延参考值</span><br>        <span class="hljs-comment">// &lt;= 3/4 * 时延参考值</span><br>        <span class="hljs-comment">// &lt;= 时延参考值</span><br>        <span class="hljs-comment">// &lt;= (1 + 1/4) * 时延参考值</span><br>        <span class="hljs-comment">// &lt;= (1 + 1/2) * 时延参考值</span><br>        <span class="hljs-comment">// &lt;= (1 + 3/4) * 时延参考值</span><br>        <span class="hljs-comment">// &gt; 3/4 * 时延参考值</span><br>divisor = <span class="hljs-type">max_t</span>(u64, target &gt;&gt; KYBER_LATENCY_SHIFT, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 这里将latency减去1，除法所得的值可以准确的落入buckets的下标里面，因为数组下标是从0开始的。 </span><br>        <span class="hljs-comment">// 如果时延过大，除法所得的值超过了7，则约束其到7，这里取一个最小值</span><br>        <span class="hljs-comment">// 大家可以假设一些值来计算一下。</span><br>bucket = <span class="hljs-type">min_t</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, div64_u64(latency - <span class="hljs-number">1</span>, divisor),<br>       KYBER_LATENCY_BUCKETS - <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>bucket = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 增加相应的桶的计数</span><br><span class="hljs-type">atomic_inc</span>(&amp;cpu_latency-&gt;buckets[sched_domain][type][bucket]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="根据时延统计调整token数"><a href="#根据时延统计调整token数" class="headerlink" title="根据时延统计调整token数"></a>根据时延统计调整token数</h2><p>在初始化流程的kyber_queue_data_alloc()函数初始化了一个timer，timer每隔一段时间会执行来动态调整token数量，执行的函数为kyber_timer_fn()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kyber_timer_fn</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *t)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_queue_data</span> *<span class="hljs-title">kqd</span> =</span> from_timer(kqd, t, timer);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_domain;<br><span class="hljs-type">int</span> cpu;<br><span class="hljs-type">bool</span> bad = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/* Sum all of the per-cpu latency histograms. */</span><br>    <span class="hljs-comment">// 将per_cpu的统计信息合并到kyber_queue_data的latency_buckets里面</span><br>for_each_online_cpu(cpu) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_cpu_latency</span> *<span class="hljs-title">cpu_latency</span>;</span><br><br>cpu_latency = per_cpu_ptr(kqd-&gt;cpu_latency, cpu);<br><span class="hljs-keyword">for</span> (sched_domain = <span class="hljs-number">0</span>; sched_domain &lt; KYBER_OTHER; sched_domain++) &#123;<br>flush_latency_buckets(kqd, cpu_latency, sched_domain,<br>      KYBER_TOTAL_LATENCY);<br>flush_latency_buckets(kqd, cpu_latency, sched_domain,<br>      KYBER_IO_LATENCY);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Check if any domains have a high I/O latency, which might indicate</span><br><span class="hljs-comment"> * congestion in the device. Note that we use the p90; we don&#x27;t want to</span><br><span class="hljs-comment"> * be too sensitive to outliers here.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 看IO在设备上的时延是否是BAD的</span><br><span class="hljs-keyword">for</span> (sched_domain = <span class="hljs-number">0</span>; sched_domain &lt; KYBER_OTHER; sched_domain++) &#123;<br><span class="hljs-type">int</span> p90;<br><br>p90 = calculate_percentile(kqd, sched_domain, KYBER_IO_LATENCY,<br>   <span class="hljs-number">90</span>);<br><span class="hljs-keyword">if</span> (p90 &gt;= KYBER_GOOD_BUCKETS)<br>bad = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Adjust the scheduling domain depths. If we determined that there was</span><br><span class="hljs-comment"> * congestion, we throttle all domains with good latencies. Either way,</span><br><span class="hljs-comment"> * we ease up on throttling domains with bad latencies.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (sched_domain = <span class="hljs-number">0</span>; sched_domain &lt; KYBER_OTHER; sched_domain++) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_depth, depth;<br><span class="hljs-type">int</span> p99;<br><br>p99 = calculate_percentile(kqd, sched_domain,<br>   KYBER_TOTAL_LATENCY, <span class="hljs-number">99</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is kind of subtle: different domains will not</span><br><span class="hljs-comment"> * necessarily have enough samples to calculate the latency</span><br><span class="hljs-comment"> * percentiles during the same window, so we have to remember</span><br><span class="hljs-comment"> * the p99 for the next time we observe congestion; once we do,</span><br><span class="hljs-comment"> * we don&#x27;t want to throttle again until we get more data, so we</span><br><span class="hljs-comment"> * reset it to -1.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (bad) &#123;<br>            <span class="hljs-comment">// 当前的样本数不够或者timer的时间不够1s，则返回的p99 &lt; 0</span><br>            <span class="hljs-comment">// 采用上一次timer计算所得的p99</span><br><span class="hljs-keyword">if</span> (p99 &lt; <span class="hljs-number">0</span>)<br>p99 = kqd-&gt;domain_p99[sched_domain];<br>kqd-&gt;domain_p99[sched_domain] = <span class="hljs-number">-1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p99 &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 记录这一次计算的p99，下一次timer可能用到</span><br>kqd-&gt;domain_p99[sched_domain] = p99;<br>&#125;<br><span class="hljs-keyword">if</span> (p99 &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If this domain has bad latency, throttle less. Otherwise,</span><br><span class="hljs-comment"> * throttle more iff we determined that there is congestion.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The new depth is scaled linearly with the p99 latency vs the</span><br><span class="hljs-comment"> * latency target. E.g., if the p99 is 3/4 of the target, then</span><br><span class="hljs-comment"> * we throttle down to 3/4 of the current depth, and if the p99</span><br><span class="hljs-comment"> * is 2x the target, then we double the depth.</span><br><span class="hljs-comment"> */</span><br>         <span class="hljs-comment">// 根据总的IO时延统计动态调整token数量的算法比较的“启发式”，也就是根据测试结果和经验来判断应该怎样去调整token的数量</span><br><span class="hljs-keyword">if</span> (bad || p99 &gt;= KYBER_GOOD_BUCKETS) &#123;<br>orig_depth = kqd-&gt;domain_tokens[sched_domain].sb.depth;<br>depth = (orig_depth * (p99 + <span class="hljs-number">1</span>)) &gt;&gt; KYBER_LATENCY_SHIFT;<br>kyber_resize_domain(kqd, sched_domain, depth);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 根据统计的时延计算时延的“好坏”</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate_percentile</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kyber_queue_data *kqd,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_domain, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> percentile)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *buckets = kqd-&gt;latency_buckets[sched_domain][type];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bucket, samples = <span class="hljs-number">0</span>, percentile_samples;<br><br><span class="hljs-keyword">for</span> (bucket = <span class="hljs-number">0</span>; bucket &lt; KYBER_LATENCY_BUCKETS; bucket++)<br>samples += buckets[bucket];<br><span class="hljs-comment">// 没有样本，表明这段时间没有IO</span><br><span class="hljs-keyword">if</span> (!samples)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We do the calculation once we have 500 samples or one second passes</span><br><span class="hljs-comment"> * since the first sample was recorded, whichever comes first.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 记录超时时间为1s</span><br><span class="hljs-keyword">if</span> (!kqd-&gt;latency_timeout[sched_domain])<br>kqd-&gt;latency_timeout[sched_domain] = max(jiffies + HZ, <span class="hljs-number">1UL</span>);<br><br>    <span class="hljs-keyword">if</span> (samples &lt; <span class="hljs-number">500</span> &amp;&amp;<br>    time_is_after_jiffies(kqd-&gt;latency_timeout[sched_domain])) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>kqd-&gt;latency_timeout[sched_domain] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 找到最能代表延迟情况的那个bucket，</span><br>    <span class="hljs-comment">// 至于这里的算法以及为什么要先计算一个百分比就不清楚了，代码能看懂但却不知为什么。</span><br>percentile_samples = DIV_ROUND_UP(samples * percentile, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">for</span> (bucket = <span class="hljs-number">0</span>; bucket &lt; KYBER_LATENCY_BUCKETS - <span class="hljs-number">1</span>; bucket++) &#123;<br><span class="hljs-keyword">if</span> (buckets[bucket] &gt;= percentile_samples)<br><span class="hljs-keyword">break</span>;<br>percentile_samples -= buckets[bucket];<br>&#125;<br><span class="hljs-built_in">memset</span>(buckets, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(kqd-&gt;latency_buckets[sched_domain][type]));<br><br>trace_kyber_latency(kqd-&gt;q, kyber_domain_names[sched_domain],<br>    kyber_latency_type_names[type], percentile,<br>    bucket + <span class="hljs-number">1</span>, <span class="hljs-number">1</span> &lt;&lt; KYBER_LATENCY_SHIFT, samples);<br><br><span class="hljs-keyword">return</span> bucket;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kyber_resize_domain</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kyber_queue_data *kqd,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_domain, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> depth)</span><br>&#123;<br>    <span class="hljs-comment">// 新的token数量不会大于最初的初始化值，也不会为0</span><br>depth = clamp(depth, <span class="hljs-number">1U</span>, kyber_depth[sched_domain]);<br><span class="hljs-keyword">if</span> (depth != kqd-&gt;domain_tokens[sched_domain].sb.depth) &#123;<br>sbitmap_queue_resize(&amp;kqd-&gt;domain_tokens[sched_domain], depth);<br>trace_kyber_adjust(kqd-&gt;q, kyber_domain_names[sched_domain],<br>   depth);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kyber退出"><a href="#kyber退出" class="headerlink" title="kyber退出"></a>kyber退出</h2><p>kyber退出的时候有两个hook函数需要执行，kyber_exit_sched()和kyber_exit_hctx()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kyber_exit_hctx</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hctx_idx)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_hctx_data</span> *<span class="hljs-title">khd</span> =</span> hctx-&gt;sched_data;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++)<br>sbitmap_free(&amp;khd-&gt;kcq_map[i]);<br>kfree(khd-&gt;kcqs);<br>kfree(hctx-&gt;sched_data);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kyber_exit_sched</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> elevator_queue *e)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kyber_queue_data</span> *<span class="hljs-title">kqd</span> =</span> e-&gt;elevator_data;<br><span class="hljs-type">int</span> i;<br><br>del_timer_sync(&amp;kqd-&gt;timer);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++)<br>sbitmap_queue_free(&amp;kqd-&gt;domain_tokens[i]);<br>free_percpu(kqd-&gt;cpu_latency);<br>kfree(kqd);<br>&#125;<br></code></pre></td></tr></table></figure><p>释放掉timer和所有初始化时申请的内存。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>kyber调度器是一个适合于高速存储介质(如NVMe)的IO调度器，文章对其做了机制介绍和源码分析，关于根据时延统计动态调整token数目的部分还未弄懂开发者的用意，算是这篇文章的一个遗憾，如果有知道的大佬还请不吝赐教。</p><p>另外mq-deadline调度器和bfq调度器的分析文章也在撰写中，bfq比kyber复杂的很多（仅从代码量上看就能大概推断），因此可能需要一些时间理解代码，mq-deadline调度器则会尽快呈现。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.dazhuanlan.com/olunx/topics/1559753">https://www.dazhuanlan.com/olunx/topics/1559753</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/04/29/block/mq-deadline/"/>
    <url>/2023/04/29/block/mq-deadline/</url>
    
    <content type="html"><![CDATA[<h1 id="mq-deadline调度器原理及源码分析"><a href="#mq-deadline调度器原理及源码分析" class="headerlink" title="mq-deadline调度器原理及源码分析"></a>mq-deadline调度器原理及源码分析</h1><p>linux内核块层有kyber、mq-deadline以及bfq三个针对multi queue设计的调度器，这篇文章主要是讲解mq-deadline调度器的原理和源码，分析的内核版本是4.20。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>mq-deadline调度器是根据以前的deadline调度器来的，适配了block层的多队列，基本原理和代码都差不多，因此如果熟悉deadline调度器的话，mq-deadline调度器也不在话下。</p><p>mq-deadline调度器将IO分为read和write两种类型，对于这每种类型的IO有一棵红黑树和一个fifo的队列，红黑树用于将IO按照其访问的LBA排列方便查找合并，fifo队列则记录了io进入mq-deadline调度器的顺序，以提供超时期限的保障。</p><p>read类型的IO可以抢write的分发机会，但不可一直抢，有一个计数保证read不会饿死write。</p><p>mq-deadline调度器会优先去批量式地分发IO而不去管IO的到期时间，当批量分发到一定的个数再关心到期时间，然后去分发即将到期的IO。</p><p>最后mq-deadline针对穿透性IO这种需要尽快发送到设备的IO设置另外一个dispatch队列，然后每次派发的时候都优先派发dispatch队列上的IO。</p><p><img src="/assets/mq-deadline.jpg" alt="mq-deadline"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>一个块设备对应一个deadline_data，上述的队列也都只存在于deadline_data中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> &#123;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * run time data</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * requests (deadline_rq s) are present on both sort_list and fifo_list</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 这里的数组的下标分别是read(0)和write(1)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">sort_list</span>[2];</span> <span class="hljs-comment">// IO在红黑树上按照LBA排列</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">fifo_list</span>[2];</span> <span class="hljs-comment">// IO在fifo队列上按照进入mq-deadline的先后排列</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * next in sort order. read, write or both are NULL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">next_rq</span>[2];</span> <span class="hljs-comment">// 批量分发时记录下一个要分发的IO</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> batching;<span class="hljs-comment">// 批量分发的个数，分发到一定个数就查看到期时间情况</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> starved;<span class="hljs-comment">// read让write饿的次数，不能超过writes_startved</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * settings that change how the i/o scheduler behaves</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> fifo_expire[<span class="hljs-number">2</span>]; <span class="hljs-comment">// read和write的到期时间</span><br><span class="hljs-type">int</span> fifo_batch; <span class="hljs-comment">// 批量分发的IO个数的最大值，默认值是16</span><br><span class="hljs-type">int</span> writes_starved; <span class="hljs-comment">// read让write饿的最大次数，默认值是2</span><br><span class="hljs-type">int</span> front_merges; <span class="hljs-comment">// 是否可以向前合并，在bio合并到mq-deadline的时候使用</span><br><br><span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-type">spinlock_t</span> zone_lock; <span class="hljs-comment">// </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">dispatch</span>;</span> <span class="hljs-comment">// 优先派发的队列，穿透性IO</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="Init的时候注册调度器"><a href="#Init的时候注册调度器" class="headerlink" title="Init的时候注册调度器"></a>Init的时候注册调度器</h3><p>mq-deadline模块初始化注册调度器，包含了mq-deadline的名称、别名、模块、属性以及最重要的操作集。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">deadline_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> elv_register(&amp;mq_deadline);<br>&#125;<br></code></pre></td></tr></table></figure><p>注册的调度器如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elevator_type</span> <span class="hljs-title">mq_deadline</span> =</span> &#123;<br>.ops.mq = &#123;<br>.insert_requests= dd_insert_requests, <span class="hljs-comment">// 插入request</span><br>.dispatch_request= dd_dispatch_request, <span class="hljs-comment">// 分发request</span><br>.prepare_request= dd_prepare_request, <br>.finish_request= dd_finish_request, <span class="hljs-comment">// request结束时调用</span><br>.next_request= elv_rb_latter_request, <span class="hljs-comment">// 找到当前request的前一个request</span><br>.former_request= elv_rb_former_request, <span class="hljs-comment">// 找到当前request的后一个request</span><br>.bio_merge= dd_bio_merge, <span class="hljs-comment">// bio合并到mq-deadline的时候调用</span><br>.request_merge= dd_request_merge, <span class="hljs-comment">// 找到一个可以将bio合并进去的request</span><br>.requests_merged= dd_merged_requests, <span class="hljs-comment">// 两个request合并后调用</span><br>.request_merged= dd_request_merged, <span class="hljs-comment">// 将bio合并到request后调用</span><br>.has_work= dd_has_work,<br>.init_sched= dd_init_queue, <span class="hljs-comment">// 初始化</span><br>.exit_sched= dd_exit_queue,<br>&#125;,<br><br>.uses_mq= <span class="hljs-literal">true</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEBUG_FS</span><br>.queue_debugfs_attrs = deadline_queue_debugfs_attrs,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.elevator_attrs = deadline_attrs,<br>.elevator_name = <span class="hljs-string">&quot;mq-deadline&quot;</span>,<br>.elevator_alias = <span class="hljs-string">&quot;deadline&quot;</span>,<br>.elevator_owner = THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="初始化mq-deadline"><a href="#初始化mq-deadline" class="headerlink" title="初始化mq-deadline"></a>初始化mq-deadline</h3><p>当启用mq-deadline调度器时会调用其初始化函数dd_init_queue()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dd_init_queue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-keyword">struct</span> elevator_type *e)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> *<span class="hljs-title">dd</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elevator_queue</span> *<span class="hljs-title">eq</span>;</span><br><br>eq = elevator_alloc(q, e);<br><span class="hljs-keyword">if</span> (!eq)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br>dd = kzalloc_node(<span class="hljs-keyword">sizeof</span>(*dd), GFP_KERNEL, q-&gt;node);<br><span class="hljs-keyword">if</span> (!dd) &#123;<br>kobject_put(&amp;eq-&gt;kobj);<br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br>eq-&gt;elevator_data = dd; <span class="hljs-comment">// 关联deadline_data和elevator_queue</span><br><br>INIT_LIST_HEAD(&amp;dd-&gt;fifo_list[READ]);<br>INIT_LIST_HEAD(&amp;dd-&gt;fifo_list[WRITE]);<br>dd-&gt;sort_list[READ] = RB_ROOT;<br>dd-&gt;sort_list[WRITE] = RB_ROOT; <span class="hljs-comment">// 初始化队列</span><br>dd-&gt;fifo_expire[READ] = read_expire; <span class="hljs-comment">// 设置读写的超时时间</span><br>dd-&gt;fifo_expire[WRITE] = write_expire;<br>dd-&gt;writes_starved = writes_starved;<br>dd-&gt;front_merges = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化是1，还未找到在哪里修改的</span><br>dd-&gt;fifo_batch = fifo_batch; <span class="hljs-comment">// 批量分发的IO个数上限</span><br>spin_lock_init(&amp;dd-&gt;lock);<br>spin_lock_init(&amp;dd-&gt;zone_lock);<br>INIT_LIST_HEAD(&amp;dd-&gt;dispatch); <span class="hljs-comment">// 初始化dispatch队列</span><br><br>q-&gt;elevator = eq; <span class="hljs-comment">// 关联elevator_queue和request_queue</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="bio合并如mq-deadline"><a href="#bio合并如mq-deadline" class="headerlink" title="bio合并如mq-deadline"></a>bio合并如mq-deadline</h2><p>到达block层的bio会首先尝试与现有的request进行合并，如果合并不成功再生成request，尝试合并调用的hook是bio_merge，对mq-deadline来说就是dd_bio_merge()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">dd_bio_merge</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx, <span class="hljs-keyword">struct</span> bio *bio)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span> =</span> hctx-&gt;<span class="hljs-built_in">queue</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> *<span class="hljs-title">dd</span> =</span> q-&gt;elevator-&gt;elevator_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">free</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> ret;<br><br>spin_lock(&amp;dd-&gt;lock);<br>    <span class="hljs-comment">// 调用通用处理流程的合并函数，详解这个函数不在本文范围内，</span><br>    <span class="hljs-comment">// 该函数会依次调用hook: request_merge找到一个可以跟bio合并的request</span><br>    <span class="hljs-comment">//                     requests_merged 尝试合并了两个相邻的request之后调用</span><br>    <span class="hljs-comment">//                     request_merged当request成功地与bio或者某个相邻的request合并之后调用                 </span><br>ret = blk_mq_sched_try_merge(q, bio, &amp;<span class="hljs-built_in">free</span>);<br>spin_unlock(&amp;dd-&gt;lock);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span>)<br>blk_mq_free_request(<span class="hljs-built_in">free</span>);<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>dd_request_merge()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 找到一个可以跟bio合并的request， 参数rq返回这个request</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dd_request_merge</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-keyword">struct</span> request **rq,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> bio *bio)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> *<span class="hljs-title">dd</span> =</span> q-&gt;elevator-&gt;elevator_data;<br><span class="hljs-type">sector_t</span> sector = bio_end_sector(bio);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *__<span class="hljs-title">rq</span>;</span><br><br>    <span class="hljs-comment">// front_merges默认是1</span><br><span class="hljs-keyword">if</span> (!dd-&gt;front_merges)<br><span class="hljs-keyword">return</span> ELEVATOR_NO_MERGE;<br><br>    <span class="hljs-comment">// 从红黑树中找到一个起始LBA是bio的结束LBA的request，表明bio可以front merge到request</span><br>    <span class="hljs-comment">// bio_data_dir表明bio是read还是write</span><br>__rq = elv_rb_find(&amp;dd-&gt;sort_list[bio_data_dir(bio)], sector);<br><span class="hljs-keyword">if</span> (__rq) &#123;<br>BUG_ON(sector != blk_rq_pos(__rq));<br><span class="hljs-comment">// 检查是否可以合并</span><br><span class="hljs-keyword">if</span> (elv_bio_merge_ok(__rq, bio)) &#123;<br>*rq = __rq;<br><span class="hljs-keyword">return</span> ELEVATOR_FRONT_MERGE;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> ELEVATOR_NO_MERGE;<br>&#125;<br></code></pre></td></tr></table></figure><p>当bio成功地合入进了一个request之后，request的请求返回增大了，elv会检查request的前一个request或者后一个request，尝试将这两个request进行合并，那么如何找到当前request的前一个或者后一个呢？</p><p>部分调度器在注册的时候会注册next_request和former_request两个hook，用于找到request的后一个或者前一个request，对于mq-deadline来说这两个函数分别为elv_rb_latter_request()和elv_rb_former_request()，这两个函数都是elv的通用函数，通过按照LBA排列的红黑树，可以很方便地找到当前request的前一个或者后一个request。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">struct</span> request *<span class="hljs-title function_">elv_rb_latter_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">rbnext</span> =</span> rb_next(&amp;rq-&gt;rb_node);<br><br><span class="hljs-keyword">if</span> (rbnext)<br><span class="hljs-keyword">return</span> rb_entry_rq(rbnext);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">struct</span> request *<span class="hljs-title function_">elv_rb_former_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">rbprev</span> =</span> rb_prev(&amp;rq-&gt;rb_node);<br><br><span class="hljs-keyword">if</span> (rbprev)<br><span class="hljs-keyword">return</span> rb_entry_rq(rbprev);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>dd_merged_requests()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 将两个request合并后通知调度器</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dd_merged_requests</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-keyword">struct</span> request *req,</span><br><span class="hljs-params">       <span class="hljs-keyword">struct</span> request *next)</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * if next expires before rq, assign its expire time to rq</span><br><span class="hljs-comment"> * and move into next position (next will be deleted) in fifo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!list_empty(&amp;req-&gt;queuelist) &amp;&amp; !list_empty(&amp;next-&gt;queuelist)) &#123;<br><span class="hljs-keyword">if</span> (time_before((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)next-&gt;fifo_time,<br>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)req-&gt;fifo_time)) &#123;<br>            <span class="hljs-comment">// next是被合并的那个IO，</span><br>            <span class="hljs-comment">// 当next的到期时间在req之前时，要将req的到期时间提前到next一样，这样保证next的到期时间，并且要调整req在fifo队列里的位置为next的位置</span><br>list_move(&amp;req-&gt;queuelist, &amp;next-&gt;queuelist);<br>req-&gt;fifo_time = next-&gt;fifo_time;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * kill knowledge of next, this one is a goner</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 将next移除出mq-deadline，因为它已经跟req合并了</span><br>deadline_remove_request(q, next);<br>&#125;<br></code></pre></td></tr></table></figure><p>将request移除出mq-deadline:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">deadline_del_rq_rb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> deadline_data *dd, <span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> data_dir = rq_data_dir(rq);<br><span class="hljs-comment">// 如果移除的是批量下发的下一个request，那么需要找到下一个批量下发的request</span><br><span class="hljs-keyword">if</span> (dd-&gt;next_rq[data_dir] == rq)<br>dd-&gt;next_rq[data_dir] = deadline_latter_request(rq);<br><span class="hljs-comment">// 从红黑树移除</span><br>elv_rb_del(deadline_rb_root(dd, rq), rq);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * remove rq from rbtree and fifo.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">deadline_remove_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> *<span class="hljs-title">dd</span> =</span> q-&gt;elevator-&gt;elevator_data;<br><span class="hljs-comment">// 从fifo队列移除</span><br>list_del_init(&amp;rq-&gt;queuelist);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We might not be on the rbtree, if we are doing an insert merge</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!RB_EMPTY_NODE(&amp;rq-&gt;rb_node))<br>deadline_del_rq_rb(dd, rq); <span class="hljs-comment">// 从红黑树移除</span><br><br>elv_rqhash_del(q, rq);<br><span class="hljs-keyword">if</span> (q-&gt;last_merge == rq)<br>q-&gt;last_merge = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>deadline_latter_request()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> request *<br><span class="hljs-title function_">deadline_latter_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br>    <span class="hljs-comment">// 红黑树是按照LBA的顺序排列的，因此可以轻松地找到下一个LBA顺序的IO</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">node</span> =</span> rb_next(&amp;rq-&gt;rb_node);<br><br><span class="hljs-keyword">if</span> (node)<br><span class="hljs-keyword">return</span> rb_entry_rq(node);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后调用dd_request_merged()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dd_request_merged</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-keyword">struct</span> request *req,</span><br><span class="hljs-params">      <span class="hljs-keyword">enum</span> elv_merge type)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> *<span class="hljs-title">dd</span> =</span> q-&gt;elevator-&gt;elevator_data;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * if the merge was a front merge, we need to reposition request</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// request完成了合并(无论是bio合并到了request还是与其他的某个request合并，亦或者都发生了)，此时request的起始LBA发生了变化，因此在红黑树上的位置也要发生改变</span><br><span class="hljs-keyword">if</span> (type == ELEVATOR_FRONT_MERGE) &#123;<br>        <span class="hljs-comment">// 先将request取下</span><br>elv_rb_del(deadline_rb_root(dd, req), req);<br>        <span class="hljs-comment">// 再插入到新的位置</span><br>deadline_add_rq_rb(dd, req);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>deadline_add_rq_rb()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">deadline_add_rq_rb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> deadline_data *dd, <span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> *<span class="hljs-title">root</span> =</span> deadline_rb_root(dd, rq);<br><br>elv_rb_add(root, rq);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="request插入到mq-deadline"><a href="#request插入到mq-deadline" class="headerlink" title="request插入到mq-deadline"></a>request插入到mq-deadline</h2><p>当bio不能合并到现有的request时，会生成一个新的request，然后将request插入到mq-deadline中等待调度。</p><p>dd_insert_requests()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dd_insert_requests</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx,</span><br><span class="hljs-params">       <span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>, <span class="hljs-type">bool</span> at_head)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span> =</span> hctx-&gt;<span class="hljs-built_in">queue</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> *<span class="hljs-title">dd</span> =</span> q-&gt;elevator-&gt;elevator_data;<br><br>spin_lock(&amp;dd-&gt;lock);<br><span class="hljs-keyword">while</span> (!list_empty(<span class="hljs-built_in">list</span>)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>;</span><br><span class="hljs-comment">// 将request取出       </span><br>rq = list_first_entry(<span class="hljs-built_in">list</span>, <span class="hljs-keyword">struct</span> request, queuelist);<br>list_del_init(&amp;rq-&gt;queuelist);<br>        <span class="hljs-comment">// 插入到mq-deadline</span><br>dd_insert_request(hctx, rq, at_head);<br>&#125;<br>spin_unlock(&amp;dd-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>dd_insert_request()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dd_insert_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx, <span class="hljs-keyword">struct</span> request *rq,</span><br><span class="hljs-params">      <span class="hljs-type">bool</span> at_head)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span> =</span> hctx-&gt;<span class="hljs-built_in">queue</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> *<span class="hljs-title">dd</span> =</span> q-&gt;elevator-&gt;elevator_data;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> data_dir = rq_data_dir(rq);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This may be a requeue of a write request that has locked its</span><br><span class="hljs-comment"> * target zone. If it is the case, this releases the zone lock.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 插入之前如果是持有了zone write lock的要解锁，关于zone看下面的简短解释</span><br>blk_req_zone_write_unlock(rq);<br><br><span class="hljs-keyword">if</span> (blk_mq_sched_try_insert_merge(q, rq))<br><span class="hljs-keyword">return</span>;<br><br>blk_mq_sched_request_inserted(rq);<br><br>    <span class="hljs-comment">// 对于穿透性IO，直接插入到dispatch队列</span><br><span class="hljs-keyword">if</span> (at_head || blk_rq_is_passthrough(rq)) &#123;<br><span class="hljs-keyword">if</span> (at_head)<br>list_add(&amp;rq-&gt;queuelist, &amp;dd-&gt;dispatch);<br><span class="hljs-keyword">else</span><br>list_add_tail(&amp;rq-&gt;queuelist, &amp;dd-&gt;dispatch);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 普通io插入到mq-deadline的红黑树</span><br>deadline_add_rq_rb(dd, rq);<br><br><span class="hljs-keyword">if</span> (rq_mergeable(rq)) &#123;<br>elv_rqhash_add(q, rq);<br><span class="hljs-keyword">if</span> (!q-&gt;last_merge)<br>q-&gt;last_merge = rq;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * set expire time and add to fifo list</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 设置request的超时时间</span><br>rq-&gt;fifo_time = jiffies + dd-&gt;fifo_expire[data_dir];<br>        <span class="hljs-comment">// 将request同时插入到fifo队列</span><br>list_add_tail(&amp;rq-&gt;queuelist, &amp;dd-&gt;fifo_list[data_dir]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里插入一下关于“zoned block device”，为了提高存储密度，有些设备被划分为若干个区域，这些区域的写IO只能顺序地写，不能随机写，能够随机读。因此这个区域的写IO必须是顺序的，mq-deadline的调度方式会打破IO来的顺序，因此需要在各个流程特殊处理zoned的情况。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 最后将request插入到mq-deadline的红黑树</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">deadline_add_rq_rb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> deadline_data *dd, <span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> *<span class="hljs-title">root</span> =</span> deadline_rb_root(dd, rq);<br><br>elv_rb_add(root, rq);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mq-deadline分发request"><a href="#mq-deadline分发request" class="headerlink" title="mq-deadline分发request"></a>mq-deadline分发request</h2><p>启动硬件队列派发后会调用调度器注册的hook：dispatch_request接口获得一个可以派发的request，mq-deadline注册的派发函数为：dd_dispatch_request()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> request *<span class="hljs-title function_">dd_dispatch_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> *<span class="hljs-title">dd</span> =</span> hctx-&gt;<span class="hljs-built_in">queue</span>-&gt;elevator-&gt;elevator_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>;</span><br><span class="hljs-comment">// 由于mq-deadline是全局(块设备局域内)的，因此这里需要加锁</span><br>spin_lock(&amp;dd-&gt;lock);<br>rq = __dd_dispatch_request(dd);<br>spin_unlock(&amp;dd-&gt;lock);<br><br><span class="hljs-keyword">return</span> rq;<br>&#125;<br></code></pre></td></tr></table></figure><p>__dd_dispatch_request()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *__<span class="hljs-title">dd_dispatch_request</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> *<span class="hljs-title">dd</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>, *<span class="hljs-title">next_rq</span>;</span><br><span class="hljs-type">bool</span> reads, writes;<br><span class="hljs-type">int</span> data_dir;<br><br>    <span class="hljs-comment">// 如果dispatch队列不为空，则优先派发dispatch队列上的穿透性IO</span><br><span class="hljs-keyword">if</span> (!list_empty(&amp;dd-&gt;dispatch)) &#123;<br>rq = list_first_entry(&amp;dd-&gt;dispatch, <span class="hljs-keyword">struct</span> request, queuelist);<br>list_del_init(&amp;rq-&gt;queuelist);<br><span class="hljs-keyword">goto</span> done;<br>&#125;<br><span class="hljs-comment">// 看read队列和write队列是否是空的</span><br>reads = !list_empty(&amp;dd-&gt;fifo_list[READ]);<br>writes = !list_empty(&amp;dd-&gt;fifo_list[WRITE]);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * batches are currently reads XOR writes</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 批量派发，按照request的LBA顺序依次派发，先尝试从write队列获取批量派发的下一个request，获取不到则尝试从read队列获取。</span><br>rq = deadline_next_request(dd, WRITE);<br><span class="hljs-keyword">if</span> (!rq)<br>rq = deadline_next_request(dd, READ);<br><span class="hljs-comment">// 如果批量派发的个数在规定限制内，则可以派发，否则需要检查fifo有无到期的IO</span><br><span class="hljs-keyword">if</span> (rq &amp;&amp; dd-&gt;batching &lt; dd-&gt;fifo_batch)<br><span class="hljs-comment">/* we have a next request are still entitled to batch */</span><br><span class="hljs-keyword">goto</span> dispatch_request;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * at this point we are not running a batch. select the appropriate</span><br><span class="hljs-comment"> * data direction (read / write)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 优先看read队列是否由到期的IO</span><br><span class="hljs-keyword">if</span> (reads) &#123;<br>BUG_ON(RB_EMPTY_ROOT(&amp;dd-&gt;sort_list[READ]));<br><span class="hljs-comment">// 如果write队列有到期的IO，并且read让write“饥饿”的次数超过了2次，则去派发write</span><br>        <span class="hljs-comment">// 否则派发read</span><br><span class="hljs-keyword">if</span> (deadline_fifo_request(dd, WRITE) &amp;&amp;<br>    (dd-&gt;starved++ &gt;= dd-&gt;writes_starved))<br><span class="hljs-keyword">goto</span> dispatch_writes;<br><br>data_dir = READ;<br><br><span class="hljs-keyword">goto</span> dispatch_find_request;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * there are either no reads or writes have been starved</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 派发write，并将starved置为0，表示read又可以抢占write了</span><br><span class="hljs-keyword">if</span> (writes) &#123;<br>dispatch_writes:<br>BUG_ON(RB_EMPTY_ROOT(&amp;dd-&gt;sort_list[WRITE]));<br><br>dd-&gt;starved = <span class="hljs-number">0</span>;<br><br>data_dir = WRITE;<br><br><span class="hljs-keyword">goto</span> dispatch_find_request;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// 无论是派发read还是write，都走到这里</span><br>dispatch_find_request:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * we are not running a batch, find best request for selected data_dir</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 先获取批量派发的下一个request</span><br>next_rq = deadline_next_request(dd, data_dir);<br>    <span class="hljs-comment">// 如果队列有到期的IO，或者批量派发没有下一个IO了则从fifo队列里取出第一个IO来派发</span><br><span class="hljs-keyword">if</span> (deadline_check_fifo(dd, data_dir) || !next_rq) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * A deadline has expired, the last request was in the other</span><br><span class="hljs-comment"> * direction, or we have run out of higher-sectored requests.</span><br><span class="hljs-comment"> * Start again from the request with the earliest expiry time.</span><br><span class="hljs-comment"> */</span><br>rq = deadline_fifo_request(dd, data_dir);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The last req was the same dir and we have a next request in</span><br><span class="hljs-comment"> * sort order. No expired requests so continue on from here.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 否则派发批量IO</span><br>rq = next_rq;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For a zoned block device, if we only have writes queued and none of</span><br><span class="hljs-comment"> * them can be dispatched, rq will be NULL.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!rq)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>dd-&gt;batching = <span class="hljs-number">0</span>;<br><br>dispatch_request:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * rq is the selected appropriate request.</span><br><span class="hljs-comment"> */</span><br>dd-&gt;batching++;<br>deadline_move_request(dd, rq); <span class="hljs-comment">// 将IO从mq-deadline移除</span><br>done:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If the request needs its target zone locked, do it.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 如果访问的是zoned区域，则必须加上zoned锁</span><br>blk_req_zone_write_lock(rq);<br>rq-&gt;rq_flags |= RQF_STARTED;<br><span class="hljs-keyword">return</span> rq;<br>&#125;<br></code></pre></td></tr></table></figure><p>deadline_next_request()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 找到批量派发的下一个IO</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> request *<br><span class="hljs-title function_">deadline_next_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> deadline_data *dd, <span class="hljs-type">int</span> data_dir)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(data_dir != READ &amp;&amp; data_dir != WRITE))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// 批量派发的下一个IO已经被置上了</span><br>rq = dd-&gt;next_rq[data_dir];<br><span class="hljs-keyword">if</span> (!rq)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// 如果批量派发的是读IO，或者是写但是这个写没有zoned属性，则直接派发</span><br><span class="hljs-keyword">if</span> (data_dir == READ || !blk_queue_is_zoned(rq-&gt;q))<br><span class="hljs-keyword">return</span> rq;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Look for a write request that can be dispatched, that is one with</span><br><span class="hljs-comment"> * an unlocked target zone.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 如果是写IO，则需要看是否加了zoned锁，如果没有加则不能派发，找到一个加了zoned锁的写IO派发</span><br>    <span class="hljs-comment">// 因为zoned device区域的写IO必须是顺序的，不能打乱顺序</span><br>spin_lock_irqsave(&amp;dd-&gt;zone_lock, flags);<br><span class="hljs-keyword">while</span> (rq) &#123;<br><span class="hljs-keyword">if</span> (blk_req_can_dispatch_to_zone(rq))<br><span class="hljs-keyword">break</span>;<br>rq = deadline_latter_request(rq);<br>&#125;<br>spin_unlock_irqrestore(&amp;dd-&gt;zone_lock, flags);<br><br><span class="hljs-keyword">return</span> rq;<br>&#125;<br></code></pre></td></tr></table></figure><p>deadline_check_fifo()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deadline_check_fifo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> deadline_data *dd, <span class="hljs-type">int</span> ddir)</span><br>&#123;<br>    <span class="hljs-comment">// 判断fifo队列的第一个IO是否过期</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span> =</span> rq_entry_fifo(dd-&gt;fifo_list[ddir].next);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * rq is expired!</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (time_after_eq(jiffies, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)rq-&gt;fifo_time))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>deadline_fifo_request()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> request *<br><span class="hljs-title function_">deadline_fifo_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> deadline_data *dd, <span class="hljs-type">int</span> data_dir)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(data_dir != READ &amp;&amp; data_dir != WRITE))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (list_empty(&amp;dd-&gt;fifo_list[data_dir]))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// 跟deadline_next_request的解释一样的</span><br>rq = rq_entry_fifo(dd-&gt;fifo_list[data_dir].next);<br><span class="hljs-keyword">if</span> (data_dir == READ || !blk_queue_is_zoned(rq-&gt;q))<br><span class="hljs-keyword">return</span> rq;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Look for a write request that can be dispatched, that is one with</span><br><span class="hljs-comment"> * an unlocked target zone.</span><br><span class="hljs-comment"> */</span><br>spin_lock_irqsave(&amp;dd-&gt;zone_lock, flags);<br>list_for_each_entry(rq, &amp;dd-&gt;fifo_list[WRITE], queuelist) &#123;<br><span class="hljs-keyword">if</span> (blk_req_can_dispatch_to_zone(rq))<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>rq = <span class="hljs-literal">NULL</span>;<br>out:<br>spin_unlock_irqrestore(&amp;dd-&gt;zone_lock, flags);<br><br><span class="hljs-keyword">return</span> rq;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="request结束"><a href="#request结束" class="headerlink" title="request结束"></a>request结束</h2><p>request结束时调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dd_finish_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span> =</span> rq-&gt;q;<br><span class="hljs-comment">// 写访问结束要释放zoned锁，如果有必要的话</span><br><span class="hljs-keyword">if</span> (blk_queue_is_zoned(q)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> *<span class="hljs-title">dd</span> =</span> q-&gt;elevator-&gt;elevator_data;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>spin_lock_irqsave(&amp;dd-&gt;zone_lock, flags);<br>blk_req_zone_write_unlock(rq);<br>spin_unlock_irqrestore(&amp;dd-&gt;zone_lock, flags);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mq-deadline退出"><a href="#mq-deadline退出" class="headerlink" title="mq-deadline退出"></a>mq-deadline退出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dd_exit_queue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> elevator_queue *e)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span> *<span class="hljs-title">dd</span> =</span> e-&gt;elevator_data;<br><br>BUG_ON(!list_empty(&amp;dd-&gt;fifo_list[READ]));<br>BUG_ON(!list_empty(&amp;dd-&gt;fifo_list[WRITE]));<br><span class="hljs-comment">// 释放掉init时申请的内存</span><br>kfree(dd);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>mq-deadline适合于对实时性敏感的程序，它能保证IO在规定的时间内能下发下去，如果下层设备不出问题那么就能保证IO能够在期限内做出响应。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.dazhuanlan.com/hechuanzi/topics/1392171">https://www.dazhuanlan.com/hechuanzi/topics/1392171</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
